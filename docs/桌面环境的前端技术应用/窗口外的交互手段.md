# 窗口外的交互手段

electron应用主要的交互手段当然是窗口,但我们都知道各个操作系统都有一些自己的额外交互逻辑,本文将探讨这些内容.

本文的例子在[electron-other_interface分支](https://github.com/hsz1273327/TutorialForFront-EndWeb/tree/electron-other_interface)

## 不同操作系统窗口以外的交互手段

首先让我们看看各个操作系统窗口以外的交互手段有哪些

> Linux(以Ubuntu为例)

Ubuntu现在使用的是Gnome桌面,提供了顶部右侧系统托盘(System Tray)和侧边程序坞(Dock)两处窗口以外的交互手段

![ubuntu窗口以外的交互手段](./source/linux-other-interface.png)

一些能后台运行的应用启动后会在系统托盘放置上自己的图标以提供一些额外快捷操作,而程序坞中则可以固定应用方便快速找到执行左键开启,右键快捷操作以及一些自定义的中键滚轮操作等.

> macos

MacOS提供了顶部右侧状态栏菜单(Status Bar Menu)和底部(可以改到侧边)程序坞(Dock)两处窗口以外的交互手段

![MacOS窗口以外的交互手段]()

一些能后台运行的应用启动后会在状态栏菜单放置上自己的图标以提供一些额外快捷操作,而程序坞中则可以固定应用方便快速找到执行一些快捷操作.

> windows

Windows提供了系统托盘(System Tray)和任务栏(Taskbar),两处窗口以外的交互手段,他们统一都在一个长条状的托盘中,这个托盘win10中可以整体移动放置到侧边或底部,在win11中则固定在底部.


![Windows窗口以外的交互手段]()

一些能后台运行的应用启动后会在系统托盘放置上自己的图标以提供一些额外快捷操作,而任务栏中则可以固定应用方便快速找到执行一些快捷操作.


从上面看其实虽然名字可能不同,但位置,体验用法上还是很接近的:

1. 都有一个或在底部或在顶部角落里只有应用启动后才会出现小图标区域
2. 都有一个或在底部或在侧边可以放置应用图标用于快速启动的托盘区域

我们统一将第一种称为系统托盘,将第二种称为程序坞

## 菜单对象

在开始介绍之前,我们先来介绍下electron中的菜单对象,毕竟这是electron中很多组件构建的基础

electron中的菜单对象(Menu)是专门用来构造按钮等交互组件的工具,一般来说用它的步骤是

1. 构造menu对象
2. 将menu对象注册到对应交互组件

第二步涉及到交互组建这边先不介绍,我们先专注于如何构造menu对象

要构造menu对象最常用的方法是使用模板,所谓模板是一个`Array<MenuItemConstructorOptions>`形式的数组,而`MenuItemConstructorOptions`满足如下接口

```typescript
interface MenuItemConstructorOptions{
    /**
     * 选项被点击后触发的操作
     */
    click?: (menuItem: MenuItem, window: (BaseWindow) | (undefined), event: KeyboardEvent) => void;
    /**
     * 预设的用途,有定义click的情况下将失效
     */
    role?: ('undo' | 'redo' | 'cut' | 'copy' | 'paste' | 'pasteAndMatchStyle' | 'delete' | 'selectAll' | 'reload' | 'forceReload' | 'toggleDevTools' | 'resetZoom' | 'zoomIn' | 'zoomOut' | 'toggleSpellChecker' | 'togglefullscreen' | 'window' | 'minimize' | 'close' | 'help' | 'about' | 'services' | 'hide' | 'hideOthers' | 'unhide' | 'quit' | 'showSubstitutions' | 'toggleSmartQuotes' | 'toggleSmartDashes' | 'toggleTextReplacement' | 'startSpeaking' | 'stopSpeaking' | 'zoom' | 'front' | 'appMenu' | 'fileMenu' | 'editMenu' | 'viewMenu' | 'shareMenu' | 'recentDocuments' | 'toggleTabBar' | 'selectNextTab' | 'selectPreviousTab' | 'showAllTabs' | 'mergeAllWindows' | 'clearRecentDocuments' | 'moveTabToNewWindow' | 'windowMenu');
    /**
     * 按钮类型,包括 \
     * `normal`, 普通按钮
     * `separator`, 分割线
     * `submenu`, 子菜单
     * `checkbox`, 多选菜单栏
     * `radio`. 单选菜单栏
     */
    type?: ('normal' | 'separator' | 'submenu' | 'checkbox' | 'radio');
    // 标签
    label?: string;
    // 子标签
    sublabel?: string;
    /**
     * macos下才会有用
     * 鼠标悬停在菜单选项时的说明文案
     * @platform darwin
     */
    toolTip?: string;
    // 菜单选项的图标
    icon?: (NativeImage) | (string);
    /**
     * 确定菜单选项是否可用,为false时置灰且不让点击
     */
    enabled?: boolean;
    /**
     * 确定菜单选项是否可见
     */
    visible?: boolean;
    /**
     * 仅在`type`为`checkbox`或`radio`时生效,菜单选项是否已被选中
     */
    checked?: boolean;
    // 定义快捷键,比如'CmdOrCtrl+S'这种
    accelerator?: Accelerator;
    /**
     * 仅在macos平台生效
     * 当菜单选项不可见时是否快捷键还能使用,默认为`true`
     * @platform darwin
     */
    acceleratorWorksWhenHidden?: boolean;
    /**
     * 仅在linux和windows平台生效
     * 默认为true,用于控制快捷键是否会被注册到系统.
     * @platform linux,win32
     */
    registerAccelerator?: boolean;
    /**
     * 仅在macos平台生效
     * 仅在`role`为`shareMenu`时生效
     * 定义SharingItem
     * @platform darwin
     */
    sharingItem?: SharingItem;
    /**
     * 仅在`type`为`submenu`时生效
     * 定义子菜单
     */
    submenu?: (MenuItemConstructorOptions[]) | (Menu);
    /**
     * 指定菜单id,一般不需要
     */
    id?: string;
    /**
     * 指定将本菜单选项放置在哪些菜单选项之前,一般不用设置
     */
    before?: string[];
    /**
     * 指定将本菜单选项放置在哪些菜单选项之后,一般不用设置
     */
    after?: string[];
    /**
     * 指定将本菜单选项放置在哪些菜单组选项之前,一般不用设置
     */
    beforeGroupContaining?: string[];
    /**
     * 指定将本菜单选项放置在哪些菜单组选项之后,一般不用设置
     */
    afterGroupContaining?: string[];
}
```

我们当然并不需要所有字段都填,一般填`label`,`type`和`clicked`就够了,之后我们可以用接口`Menu.buildFromTemplate()`将模板构造为上下文,而这个上下文就是我们设置到各种交互对象上用到的东西了

```typescript
import {

  Menu,

} from 'electron'
///
const template = [
  { label: 'Item1', type: 'radio' },
  { label: 'Item2', type: 'radio' },
  { label: 'Item3', type: 'radio', checked: true },
  { label: 'Item4', type: 'radio' },
  { label: '退出', type: 'normal', click: () => app.quit() }
]
const contextMenu = Menu.buildFromTemplate(template)
...
```

### 菜单项类型

不考虑特殊用途,菜单项类型可以分为`普通按钮(normal)`,多选按钮`checkbox`和单选按钮`radio`,

### 菜单分组

### 子菜单

## 系统托盘

一般是需要长期驻留在系统中的应用才会占用系统托盘,比如微信qq这类即时通讯工具,音乐电台类音乐播放器工具,后台挂着下载的下载工具,或者防火墙这类才会用到.

electron中使用类`Tray`来规定其行为,基本的形式如下

```typescript
import {
 
  Tray,
  nativeImage,
  Menu,
  MenuItem
} from 'electron'
// 导入图标图片
import icon from '../../resources/icon.png?asset'
...
// 初始化系统托盘定义
function init_tray(): void {
  // 定义系统托盘的图标
  const tray_icon = nativeImage.createFromPath(icon)
  const tray = new Tray(tray_icon)
  // 定义系统托盘中点击后弹出的菜单
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Item1', type: 'radio' },
    { label: 'Item2', type: 'radio' },
    { label: 'Item3', type: 'radio', checked: true },
    { label: 'Item4', type: 'radio' },
    { label: '退出', type: 'normal', click: () => app.quit() }
  ])
  tray.setContextMenu(contextMenu)
  // 设置鼠标指针在托盘图标上悬停时显示的文本(linux下不支持)
  tray.setToolTip('This is my application')
  // 设置macos中显示在状态栏中托盘图标旁边的标题
  tray.setTitle('This is my title')
}
...
app.whenReady().then(() => {
  ...
  const mainwindow = createWindow()
  ...
  init_tray()
  ...
})
```

通常系统托盘中必然会有一个`退出`按钮,这样如果程序在后台运行没有窗口时也可以用它关闭.
<!-- 
#### dock行为(macos,linux)

dock是macos中的概念,用来注册常用软件和正在运行中的程序方便快速访问快速切换,现在的gnome体系下也有.不过electron中只能定义macos的dock行为

```typescript
import {
 
  Tray,
  nativeImage,
  Menu,
  MenuItem
} from 'electron'
// 导入图标图片
import icon from '../../resources/icon.png?asset'
...
// 设置macos下dock的行为
function init_dock(): void {
  app.dock.setIcon(icon)
  app.dock.setBadge('my application')
  app.dock.setMenu(
    Menu.buildFromTemplate([
      { label: 'New Window', click: (): void => console.log('New Window') },
      { label: 'New Window with Settings', submenu: [{ label: 'Basic' }, { label: 'Pro' }] },
      { label: 'New Command...' }
    ])
  )
}
...
app.whenReady().then(() => {
  ...
  const mainwindow = createWindow()
  ...
  if (process.platform !== 'darwin') {
    init_dock()
  }
  ...
})
``` -->
