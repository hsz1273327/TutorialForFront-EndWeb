# 浏览器环境

浏览器是js的主战场.js为浏览器而生,但它并不是浏览器环境的全部,只是刚好js可以操作浏览器环境中的所有元素.打个比方浏览器是一台高达,js是这台高达的驾驶员.高达驾驶员得对自己的高达有充分的了解才能很好的驾驭它,写浏览器环境js的程序员(通常称为前端)也必须了解浏览器环境才能很好的完成这个环境下的js开发.


## 浏览器

我们知道网络服务常见的有两种:
+ C/S模式即客户端服务器模式
+ B/S模式即浏览器服务器模式

浏览器可以理解为一个标准而通用的客户端.它专为网络应用而生.在B/S模式结构中:

+ `服务器`
    1. 提供供浏览器渲染的前端资源
    2. 接收与用户交互时用户通过浏览器中渲染的页面提交的请求数据
    3. 向浏览器发送业务需要的数据

+ `浏览器`
    1. 通过域名(hostname)找到对应的服务器ip并确定连接的路径
    2. 渲染通过http协议访问服务器获取到的前端资源
    3. 提供相应的事件和接口让前端资源渲染出来的页面可以满足交互需求.

可以看出B/S模式中前端资源是服务器和浏览器之间的媒介,服务器需要使用前端资源告诉浏览器要如何处理渲染,浏览器则负责将前端资源渲染成服务器指定的样子以供用户使用.

因此浏览器和服务器间必须建立一套规范来规定浏览器对前端资源的渲染行为和边界,以避免相互无法兼容.

最终各界统一使用html作为浏览器解析服务器端的标记语言,用css作为浏览器对html中构造的dom元素的样式渲染声明语言,用js作为浏览器可以执行的脚本语言.并使用html来规范浏览器支持渲染的行为和边界.
虽然到现在各个厂商的浏览器还不是接口,行为完全一致,但总体上讲已经相当一致了.

## 前端资源

通常我们说的前端资源是指的浏览器访问指定路径后由服务端发送回来用于渲染成页面的多种数据的集合.这些资源大致可以包含以下种类:

+ `html文件`用于声明页面初始元素的文件
+ `css文件`用于声明页面元素的初识样式的文件
+ `js文件`用于根据交互事件,时间等来触发改变页面元素行为的文件
+ `多媒体文件`用于展示的图片,音频,视频等多媒体文件,比如页面图标的`.ico`文件,动态图`.gif`,一般图片`.jpg/.png`,文档`.pdf`,音频`.mp3`,视频`.mp4`等.
+ `其他文件`用于单纯的下载.
+ `数据`,通常是由服务的接口返回而不是由静态html服务返回, 常见的序列化格式有json和xml.

## 浏览器渲染页面

浏览器渲染的步骤如下:

1. 处理HTML标记并构建DOM树
2. 处理CSS标记并构建CSSOM树
3. 将DOM与CSSOM合并成一个渲染树
4. 根据渲染树来布局,计算每个节点的布局信息
5. 将各个节点绘制到屏幕上
6. 如果DOM或CSSOM被修改,就会从3开始重新执行上面所有步骤

![浏览器渲染页面流程](source/浏览器渲染流程.webp)

在第一步时浏览器会解析HTML文档,以完成以下步骤:

1. 读取HTML的原始字节,根据文件制定编码(现在通常是utf-8)解析为各个字符
2. 将字符串转化为各种标签,HTML是XML的子集,这个步骤就是解析xml
3. 将标签转化为node节点
4. 使用节点构建DOM树

![html渲染流程](source/html渲染流程.webp)

浏览器解析HTML时,遇到link标签会发出请求并返回CSS资源,从而开始解析CSS.CSS字节转换为字符,接着转换成令牌和节点,最后构建生成CSSOM.

![css渲染流程](source/css渲染流程.webp)

CSSOM和DOM是独立的数据结构,渲染树由这两个树构建而成,构建完成后计算每个可见元素的布局,并输出给绘制流程,将像素渲染到屏幕上.

构建渲染树的步骤:

1. 从DOM树的根节点开始遍历每个可见节点(display:none与visibility:hidden的区别)
2. 对于每个可见节点为其找到适配的CSSOM规则并应用它
3. 生成渲染树
4. 布局阶段:输出盒模型
5. 绘制:输出到屏幕上的像素

### 阻塞渲染

CSS是阻塞渲染的资源,需要将它尽早尽快地下载到客户端,以便缩短首次渲染的时间.这就是为什么我们将外部样式的引入放在head标签中的原因,在body渲染前先把相对完整CSSOM Tree构建好.

对于某些CSS样式只在特定条件下使用可以添加媒体查询解决.请注意"阻塞渲染"仅是指浏览器是否需要暂停网页的首次渲染直至该资源准备就绪.无论哪一种情况,浏览器仍会下载CSS资源,只不过非阻塞渲染的资源优先级较低罢了.

使用`script`标签引入JavaScript代码默认也会阻塞渲染.为了实现最佳性能,可以让JavaScript异步执行,并去除关键渲染路径中任何不必要的JavaScript.但我们可以为其添加属性以改变这种行为:

+ `async`属性:加载和渲染后续文档元素的过程将和脚本的加载与执行并行执行.无顺序
+ `defer`属性:加载后续文档元素的过程将和脚本的加载并行进行,但脚本的执行要在所有元素解析完成之后,DOMContentLoaded事件触发之前完成.

## `hello world!`

前端项目提供展示和交互,无非不过可以分为:

+ 使用html和css展示内容,并配合js监听操作以提供交互.
+ 使用js配合与服务端的通信规范或获取本地资源接口获取用户需要的资源内容.
+ 将获取到的资源内容在本地处理,之后在DOM中渲染出来展示.

本文的例子是一个前端项目的最简单样板[浏览器环境-helloworld[](),](https://github.com/hsz1273327/TutorialForJavascript/tree/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83-helloworld)实现了抓取github最新注册的用户的用户名,并展示出来的功能.有兴趣的可以看下.

本例子使用html中的fetch接口获取github公开restful api中需要的数据.

