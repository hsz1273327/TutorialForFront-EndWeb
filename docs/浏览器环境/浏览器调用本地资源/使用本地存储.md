# 本地存储

在早期的html服务中,前端是不应该存在本地存储的,毕竟http协议在设计之初就是一个基于短连接的协议.
但服务可以没有状态,但用户需要有状态,总要有一种方式让服务器知道使用的人是谁,这就带来了状态.
也就必须有本地存储让浏览器记住一些用户对特定网站的状态信息,于是诞生了最简单的本地存储--`cookie`.

但`cookie`的限制不少,它有长度限制,是最简单的键值对形式,并且他会在每次对服务的请求中附带上.
尤其在现在前端工程化的趋势中,前端项目很多时候会保存许多用户状态或者操作的中间状态,已然相当接近客户端了,`cookie`的机制显然已经不能满足需求了.
在比较新的浏览器中现在都已经支持一些其他本地存储方式了,其中的代表是`Web Storage`和`Indexed DB`,另外也有更加激进的方案`websql`

本章的代码在**[C2-S2](https://github.com/TutorialForJavascript/frontend-basic/tree/master/code/C2/S2)**

## 域

提本地存储就不得不提域,这是一个在web开发中绕不开的问题.试想如果要让浏览器知道用户在某个网站上的信息该怎么办?很容易可以想到可以做个映射,
不同的网站存各自的东西就好,这就是最朴素的域的想法了.当然`域`不光解决存储问题,更关键的是用于安全问题,解决`XSS`,`CSFR`等攻击.这个我们在与`服务端交互`部分细聊.

### 同源策略

同源策略/`SOP`(Same origin policy)是一种约定,由Netscape公司1995年引入浏览器,它是浏览器最核心也最基本的安全功能,所谓同源是指"协议+域名+端口"三者相同,即便两个不同的域名指向同一个ip地址,也非同源.浏览器在多数情况下只会允许对同源资源进行操作和访问.

在本地存储这个场景下,也就是说`A`站的前端页面无法访问到`B`站存在本地的数据.

## 本文的例子

本文将使用一个相同的例子,使用不同的本地存储技术分别做实现.这个例子很简单--保存之前[表单](https://tutorialforjavascript.github.io/web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E6%A6%82%E8%A7%88/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E8%A7%84%E8%8C%83/%E4%BA%A4%E4%BA%92%E4%BA%8B%E4%BB%B6.html#%E8%A1%A8%E5%8D%95form)中页面存储的用户信息.

我们的页面会复用其中的现有界面和代码,只是把其中打印到命令行的部分替换为存储到本地存储.

之后我们为页面添加一个表格将保存的数据全都一次展示出来,每次插入都会触发新增一条记录,而展示则需要点击一个按钮控件`button`.这个展示我们会使用[模板标签](https://tutorialforjavascript.github.io/web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E6%A6%82%E8%A7%88/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E8%A7%84%E8%8C%83/%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE.html)来实现.

+ index.html

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>测试模板</title>
    <script src="https://cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"> </script>
    <script src="index.js" async="async"></script>
</head>
<body>
    <main>
        <form id="test_form">
            <fieldset>
                <legend>Person Info</legend>
                <p>Gender:</p>
                <input type="radio" name="gender" value="male" checked>Male
                <br>
                <input type="radio" name="gender" value="female">Female
                <br>
                <p>First name:<input type="text" name="firstname" minlength=2 maxlength=10></p>
                <br>
                <p>Last name:<input type="text" name="lastname" minlength=2 maxlength=10></p>
                <br>
                <p>Birthday:<input type="date" name=birthday min="1960-01-01" max="2019-02-22"></p>
                <br>
                <p>Email:<input type="email" name=email></p>
                <br>
                <p>Tel:<input type="tel" name=tel></p>
                <br>
                <p>Home Page:<input type="url" name=homepage></p>
                <br>
                <input type="reset" value="Reset" accesskey="r" />
                <input type="submit" value="Submit" accesskey="s" />
            </fieldset>
        </form>
        <button id="show">Show Table List</button>
        <table border="1">
            <caption>已有用户</caption>
            <thead>
                <tr>
                    <th >用户id</th>
                    <th scope="col">First name</th>
                    <th scope="col">Last name</th>
                    <th scope="col">Gender</th>
                    <th scope="col">Birthday</th>
                    <th scope="col">Email</th>
                    <th scope="col">Tel</th>
                    <th scope="col">Home Page</th>

                </tr>
            </thead>
            <tbody id="rows">
            </tbody>
        </table>

    </main>
    <template id="table_template">
        <tr>
            <th scope="row" class="id"></th>
            <td class="firstname"></td>
            <td class="lastname"></td>
            <td class="gender"></td>
            <td class="birthday"></td>
            <td class="email"></td>
            <td class="tel"></td>
            <td class="homepage"></td>
        </tr>
    </template>
</body>
</html>
```

展示部分复用外,我们也规定好除了存取以外的js代码:

+ `formRender`用于定义存的交互逻辑,其中调用`Storage.saveOne(this_md5, table)`来保存
+ `showRender`用于定义读取并展示的交互逻辑,其中调用`Storage.loadAll()`来取出数据

这样我们只要实现`Storage`对象,其有两个方法:

+ `saveOne(this_md5, table)`用于保存一条数据
+ `Storage.loadAll()`用于读取全部数据

## cookie

虽然[`cookie`]([https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie))已经有点过气,但架不住它是目前支持最广泛的本地存储工具.虽然各家cookie的个数限制和容量限制各不相同,但大致上,容量在5000字节以下.

其本质是一段键值组成的字符串.

js使用`document.cookie`来访问当前域的cookie.对于`cookie`的个增删改查操作可以查看文档,这边不做复述.

针对我们的例子,这边大致讲下实现时的思路:

首先由于cookie只能存字符串,要保存对象我们只能先将其编码为json,而键我们则是用json的md5来创建.这个md5就是其id了.

然后是其保存形式,cookie保存的形式类似:`key1=value1;key2=value2`因此需要先将数据按`;`分割以获得每一条数据,然后再在每条数据中按`=`分割获得md5的值和对应的json字符串,之后解析json字符串即可得到每条数据的对象.

+ Storage

```js
const Storage = {
    saveOne: function (md5_id, table) {
        document.cookie = `${md5_id}=${JSON.stringify(table)}`
    },
    loadAll: function () {
        if (document.cookie.length>0){
            let data = document.cookie.split(";")
            let result = []
            for (let i of data) {
                let content = i.split("=")
                let id = content[0]
                let body = content[1]
                let table = JSON.parse(body)
                table.id = id
                result.push(table)
            }
            return result
        }else{
            return false
        }
    }
}
```

本节的代码在**[C2-S2-P1](https://github.com/TutorialForJavascript/frontend-basic/tree/master/code/C2/S2/P1)**


## Web Storage

[`webstorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API)是一个键值对数据存储工具.提供两种类型的API:localStorage和sessionStorage,两者的区别看名字就有大概了解:

+ `localStorage`在本地永久性存储数据,除非显式将其删除或清空.其对象为`Window.localStorage`或`localStorage`

+ `sessionStorage`存储的数据只在会话期间有效,关闭浏览器则自动删除.其对象为`Window.sessionStorage`或`sessionStorage`

两个对象都有共同的API.

Storage同样还是键值对存储.因此接口简单但不像关系数据库那样有个固定的schema.有时候并不是太好用.

从容量上讲WebStorage一般浏览器提供5M的存储空间,用来存储视频,图片这类明显不够,但对于绝大部分状态信息已经绰绰有余.
webstorage一样受`域`限制.

从浏览器兼容性来看主流浏览器都已经支持`webstorage`了.

既然接口一致,我们就使用`localStorage`作为例子好了.

### api

借用typescript的接口我们来看下`Storage`的描述:

属性:

```ts
interface Storage {
    readonly attribute unsigned long length;
    DOMString? key(unsigned long index);
    getter DOMString getItem(DOMString key);
    setter creator void setItem(DOMString key, DOMString value);
    deleter void removeItem(DOMString key);
    void clear();
};
```

1. length:唯一的属性，只读，用来获取storage内的键值对数量。
2. key：根据index获取storage的键名
3. getItem：根据key获取storage内的对应value
4. setItem：为storage内添加键值对
5. removeItem：根据键名，删除键值对
6. clear：清空storage对象

事件:

```ts
interface StorageEvent : Event {
    readonly attribute DOMString key;
    readonly attribute DOMString? oldValue;
    readonly attribute DOMString? newValue;
    readonly attribute DOMString url;
    readonly attribute Storage? storageArea;
};
```

HTML5规定了一个storage事件，在WebStorage发生变化的时候触发，可以用此监视不同页面对storage的修改

1. key:键值对的键
2. oldValue：修改之前的value
3. newValue：修改之后的value
4. url：触发改动的页面url
5. StorageArea：发生改变的Storage

实际操作中Storage用法很简单,就和python中的某个全局字典差不多,不太一样的地方也就是遍历比较麻烦了

+ 创建或修改键值对:

`localStorage.setItem(key,value)`或者`localStorage[key]=value`

+ 读取键对应的值:

`localStorage[key]`

+ 删除键值对:

`localStorage.removeItem(key)`

+ 清空所有数据:

`localStorage.clear()`

+ 遍历所有数据:

```js
for (let i of Object.keys(localStorage)){
    ...
}
```

### 修改例子

本节的代码在**[C2-S2-P2](https://github.com/TutorialForJavascript/frontend-basic/tree/master/code/C2/S2/P2**

由于我们的代码结构,我们只需要修改`Storage`对象即可,因为`localStorage`依然是键值对存储,且依然只接受字符串(由于js是弱类型,不是字符串的对象会被保存为字面量),我们还是使用json先将值序列化.

+ Storage

```js
const Storage = {
    saveOne: function (md5_id, table) {
        localStorage.setItem(md5_id,JSON.stringify(table))
    },
    loadAll: function () {
        if (localStorage.length>0){
            let keys = Object.keys(localStorage)
            let result = []
            for (let id of keys) {
                let body = localStorage[id]
                let table = JSON.parse(body)
                table.id = id
                result.push(table)
            }
            return result
        }else{
            return false
        }
    }
}
```

## Indexed DB

Web Storage使用简单字符串键值对在本地存储数据,方便灵活,但是对于大量结构化数据存储力不从心,[IndexedDB](https://www.w3.org/TR/IndexedDB/)是为了能够在客户端存储大量的结构化数据,并且使用索引高效检索的API.

indexedDB依然受域的限制,但除了可以存储字符串,indexedDB也可以存bytes.在容量方面,indexedDB各个浏览器的实现细节不同,火狐无上限,chrome每一条记录大小不能超过130M.
indexedDB同时支持[webWorker](),这也是它相比其他方案优秀之处.

虽然多数浏览器已经支持indexedDB,但不同浏览器中它的对象并不完全一样,且标准接口使用的是事件驱动的方式,这种并不符合我们的使用习惯,我们可以使用封装好的[Dexie.js](http://dexie.org/)

要使用它最简单的方式是在`index.html`中`head`中加一行`<script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>`

### `Dexie.js`的使用方法

indexedDB用起来比较接近MongoDB,通常我们使用`Dexie.js`的异步接口,主要的接口包括:

+ `let db = new Dexie("PersonInfoDatabase")`新建一个数据库连接实例
+ `db.version(1).stores({tablename: "key1,key2,..."})`为数据库建立一个表,并规定其使用的字段
+ `db.transaction('rw', this.db.person, async () => {...}`为数据库创建一个事务操作的`Promise`第三位的异步函数就是事务操作的具体内容.
+ `db.<tablename>`就是表对象,可以在上面的事务异步函数内使用,`toArray()`,`count()`,`add(obj)`,`where(exp)`等异步方法可以用于获取需要的数据或做增删改查操作.

### 修改例子

本节的代码在**[C2-S2-P3](https://github.com/TutorialForJavascript/frontend-basic/tree/master/code/C2/S2/P3)**

由于我们使用了异步接口,我们的代码会进行了相对多的变化:

+ Storage


新增了字段`db`用于保存使用的数据库对象,方法`init_db()`在`main`函数中先就调用,用来规定数据库中的表和各自表的key.

同时我们的`saveOne`和`loadAll`现在返回的是事务操作的Promise.

```js
const Storage = {
    db: new Dexie("PersonInfoDatabase"),
    init_db: function () {
        this.db.version(1).stores({
            person: "id,firstname,lastname,gender,birthday,email,tel,homepage"
        })
    },
    saveOne: function (md5_id, table) {
        return this.db.transaction('rw', this.db.person, async () => {
            // Make sure we have something in DB:
            table.id = md5_id
            await this.db.person.add(table)
        })
    },
    loadAll: function () {
        return this.db.transaction('rw', this.db.person, async () => {
            if ((await this.db.person.count()) > 0) {
                let result = await this.db.person.toArray()
                return result
            } else {
                return false
            }
        })

    }
}
```

+ 调用保存和读取

由于一般函数中无法使用`await`关键字,我们就需要在保存和读取时使用Promise的`then(result)`接口和`catch(error)`接口定义返回值得使用方式和错误处理方式.

```js
let tables_promise = Storage.loadAll()
tables_promise.then((result) => {
    ...
}).catch(e => {
    alert(e.stack || e);
})
```

## websql(html5未被收录)

websql是被废弃的一个html5标准,目前支持的浏览器包括`Safari`, `Chrome`和`Opera`,它使用sqlite的sql方言作为标准,并且可以自定义数据库大小.

websql通常用在一些基于浏览器的客户端技术上,纯前端项目难得会用.我们希望使用websql的异步接口,可以使用[websql-promisified](https://github.com/oskarer/websql-promisified)配合原生接口使用.这个包我们无法直接使用,可以去它的github上找到源码,然后删掉最后一行的export语句,新加一个方法.我们将这个包命名为`websql-promisified.js`放在我们的es文件夹中和index.js一起编译.

```js
...

function websql(db) {
  return Object.create(prototype, {
    db: {
      value: db
    }
  })
}
```

我们需要在html文件中引用这个包`<script src="websql.js"></script>`

之后就可以使用了.

### 接口

websql的操作其实就是使用sql语句执行对应的操作.它接口很少,配合`websql-promisified`的话大致有如下几个接口:

+ 创建数据库
  
    ```js
    const db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
    ```
    可以允许有5个参数:
    + 数据库名称
    + 版本号
    + 描述文本
    + 数据库大小,单位bytes
    + 创建回调

+ 数据库接口异步化

    ```js
    import websql from 'websql-promisified'
    const db_promise = websql(db)
    ```

+ 创建事务Promise

    ```js
    let result = await websqlPromise.transaction((tx) => {
        ...
    })
    ```

    这个result是一个数组,其第`i`位即为这个事务中第`i`条`tx.executeSql()`的返回值.


+ 在事务中执行sql语句

    ```js
    tx.executeSql('SELECT * FROM someTable');
    ```

    允许按顺序最多有三个参数:

    + sql语句字符串
    + sql语句字符串中如果有`?`作为占位符可以在第二位的array中按出现顺序补上
    + 执行完后(tx, result)为参数的回调函数.

    由于有模板字符串,实际上第二个参数已经没啥用了.


### 修改例子

本节的代码在**[C2-S2-P4](https://github.com/TutorialForJavascript/frontend-basic/tree/master/code/C2/S2/P4)**

前文提到的异步化模块的处理是这个例子中最大的变化,剩下的其实就简单了

+ Storage

storage中定义了`db`为我们的数据库对象,`db_promise`为`db`的异步化包装对象.我们在方法`init_db`中构造`db_promise`,并创建其中的表.

剩下的就只是编写sql语句实现插入和查询罢了.

```js
const Storage = {
    db: openDatabase('PersonInfoDatabase', '1.0', 'Test DB', 2 * 1024 * 1024),
    db_promise: null,
    init_db: function () {
        this.db_promise = websql(this.db)
        this.db.transaction(function (tx) {
            tx.executeSql(
                'CREATE TABLE IF NOT EXISTS Person (' +
                'id TEXT PRIMARY KEY NOT NULL,' +
                'firstname TEXT NOT NULL,' +
                'lastname TEXT NOT NULL,' +
                'gender TEXT NOT NULL,' +
                'birthday TEXT NOT NULL,' +
                'email TEXT NOT NULL,' +
                'tel TEXT NOT NULL,' +
                'homepage TEXT NOT NULL)'
            )
        })
    },
    saveOne: function (md5_id, table) {
        return this.db_promise.transaction(function (tx) {
            tx.executeSql(
                `INSERT INTO Person VALUES ('${md5_id}','${table.firstname}','${table.lastname}','${table.gender}','${table.birthday}','${table.email}','${table.tel}','${table.homepage}');`
            )
        })
    },
    loadAll: function () {
        return this.db_promise.transaction(function (tx) {
            tx.executeSql(
                `SELECT * FROM Person`
            )
        })
    }
}
```

在调用部分我们需要注意下`result`中的结果顺序,每个请求的结果是按请求顺序返回的.而数据则放在`result[i].rows`中.
