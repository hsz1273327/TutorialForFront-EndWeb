# 浏览器环境的前端应用

浏览器是js的主战场.js为浏览器而生,但它并不是浏览器环境的全部,只是刚好js可以操作浏览器环境中的所有元素.打个比方浏览器是一台高达,js是这台高达的驾驶员.高达驾驶员得对自己的高达有充分的了解才能很好的驾驭它,写浏览器环境js的程序员(通常称为前端)也必须了解浏览器环境才能很好的完成这个环境下的js开发.

## 浏览器

我们知道网络服务常见的有两种:

+ C/S模式即客户端服务器模式
+ B/S模式即浏览器服务器模式

浏览器可以理解为一个标准而通用的客户端.它专为网络应用而生.在B/S模式结构中:

+ `服务器`
    1. 提供供浏览器渲染的前端资源
    2. 接收与用户交互时用户通过浏览器中渲染的页面提交的请求数据
    3. 向浏览器发送业务需要的数据

+ `浏览器`
    1. 通过域名(hostname)找到对应的服务器ip并确定连接的路径
    2. 渲染通过http协议访问服务器获取到的前端资源
    3. 提供相应的事件和接口让前端资源渲染出来的页面可以满足交互需求.

可以看出B/S模式中前端资源是服务器和浏览器之间的媒介,服务器需要使用前端资源告诉浏览器要如何处理渲染,浏览器则负责将前端资源渲染成服务器指定的样子以供用户使用.

因此浏览器和服务器间必须建立一套规范来规定浏览器对前端资源的渲染行为和边界,以避免相互无法兼容.

最终各界统一使用html作为浏览器解析服务器端的标记语言,用css作为浏览器对html中构造的dom元素的样式渲染声明语言,用js作为浏览器可以执行的脚本语言.并使用html来规范浏览器支持渲染的行为和边界.
虽然到现在各个厂商的浏览器还不是接口,行为完全一致,但总体上讲已经相当一致了.

目前主流的现代浏览器都已经支持了大部分的ES8+版本的js语法,因此本文也将以ES语法原生的进行演示.

### 浏览器的工作原理

现代浏览器是一个非常复杂软件,以chrome为例,毕竟现在内嵌的浏览器基本都是chrominum,了解其工作原理相对比较有价值.Chrome浏览器它采用的是多进程架构,按处理的工作范围可以分为两个主要大类:

+ `浏览器进程(browser process)`,单例,负责浏览器的浏览器主体部分,包括前进后退,收藏夹,以及网络请求处理和文件处理等.
+ `渲染进程(renderer process)`,用于渲染页面,也是前端工程的主战场.Chrome会尽可能为每一个tab甚至是页面里面的每一个iframe都分配一个单独的进程

当然除了上面说的这两个,还有如`扩展进程(Extension Process)`和`工具进程(utility process)`等,他们也有自己的职责范围,但不是我们需要主要留意的方向

如果你想看一下你的Chrome浏览器现在有多少个进程在跑可以点击浏览器右上角的更多按钮,选择更多工具和任务管理器就可以看到.

让我们来看一个用户浏览网页最简单的情景.你在浏览器导航栏里面输入一个URL然后按下回车键,浏览器接着会从互联网上获取相关的数据并把网页展示出来这个过程也就是`导航`(`navigation`)的过程,让我们看看这个过程中发生了什么.

#### 导航

`导航`过程可以总结为如下几个步骤

1. `处理输入`,当用户开始在tab导航栏上面输入内容的时候,`浏览器进程`的`UI线程`(UI thread)做的第一件事就是询问"你输入的字符串是一些搜索的关键词(search query)还是一个URL地址呢?".因为对于Chrome浏览器来说导航栏的输入既可能是一个可以直接请求的域名还可能是用户想在搜索引擎里面搜索的关键词信息,所以当用户在导航栏输入信息的时候UI线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求你输入的站点资源.

2. `开始导航`,无论是网址还是关键词,当用户按下回车键的时候,`浏览器进程`的`UI线程`会叫`浏览器进程`的`网络线程(network thread)`初始化一个网络请求来获取站点的内容(关键字就是默认搜索引擎的查询地址).这时候tab上会展示一个提示资源正在加载中的旋转圈圈,而且`网络线程`会进行一系列诸如DNS寻址以及为请求建立TLS连接的操作.这时如果网络线程收到服务器的`HTTP 301`重定向响应,它就会告知`浏览器进程`的`UI线程`进行重定向然后它会再次发起一个新的网络请求.

3. `读取响应`,无论进行几次网络请求,最终我们会获得到请求的响应.网络线程在收到HTTP响应的主体(payload)流(stream)时在必要的情况下它会先检查一下流的前几个字节以确定响应主体的具体媒体类型(MIME Type).响应主体的媒体类型一般可以通过HTTP头部的`Content-Type`来确定,不过`Content-Type`有时候会缺失或者是错误的,这种情况下浏览器就要进行MIME类型嗅探来确定响应类型了.MIME类型嗅探并不是一件容易的事情但这不是我们讨论的重点,重点是浏览器会最终确定响应的类型.
    + 如果响应的主体是一个HTML文件,浏览器会将获取的响应数据交给渲染进程(renderer process)来进行下一步的工作.
    + 如果拿到的响应数据是一个其他文件,响应数据就会交给下载管理器`download manager`来处理.
    下载器这里先不做讨论.我们假设响应的类型是html文件.网络线程在把内容交给渲染进程之前还会对内容做`SafeBrowsing`检查.如果请求的域名或者响应的内容和某个已知的病毒网站相匹配,网络线程会给用户展示一个警告的页面.除此之外,网络线程还会做`CORB(Cross Origin Read Blocking)`检查来确定那些敏感的跨站数据不会被发送至渲染进程

4. `寻找一个渲染进程`,在`浏览器进程`的`网络线程`做完所有的检查后并且能够确定浏览器应该导航到该请求的站点,它就会告诉`浏览器进程`的`UI线程`所有的数据都已经被准备好了.`浏览器进程`的`UI线程`在收到网络线程的确认后会为这个网站寻找一个`渲染进程(renderer process)`来渲染界面.由于网络请求可能需要长达几百毫秒的时间才能完成,为了缩短导航需要的时间,浏览器会在之前的一些步骤里面做一些优化.例如在第二步中当`UI线程`发送URL链接给网络线程后它其实已经知晓它们要被导航到哪个站点了,所以在网络线程干活的时候,UI线程会主动地为这个网络请求启动一个`渲染进程`.如果一切顺利的话(没有重定向之类的东西出现)`浏览器进程`的`网络线程`准备好数据后页面的`渲染进程`就已经准备好了,这就节省了新建渲染进程的时间.不过如果发生诸如网站被重定向到不同站点的情况,刚刚那个渲染进程就不能被使用了,它会被摒弃,一个新的渲染进程会被启动.

5. `提交(commit)导航`,到这一步的时候,数据和渲染进程都已经准备好了,`浏览器进程`会通过IPC告诉`渲染进程`去提交本次`导航(commit navigation)`.除此之外`浏览器进程`还会将刚刚接收到的响应数据流传递给对应的`渲染进程`让它继续接收到来的HTML数据.一旦`浏览器进程`收到`渲染进程`的回复说`导航`已经被提交了,导航这个过程就结束了.文档就会正式进入加载阶段(document loading phase).到了这个时候,导航栏会被更新,安全指示符(security indicator)和站点设置UI(site settings UI)会展示新页面相关的站点信息.当前tab的会话历史(session history)也会被更新,这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面.为了方便你在关闭了tab或窗口(window)的时候还可以恢复当前tab和会话(session)内容,当前的会话历史会被保存在磁盘上面.

6. `加载阶段`会以html文件为入口解析渲染本身以及导入的其他前端资源为页面,而这一切都会发生在`渲染进程`中.在`渲染进程`里`主线程(main thread)`处理了绝大多数你发送给用户的代码.如果你使用了`web worker`或者`service worker`,相关的代码将会由`工作线程(worker thread)`处理,而`合成(compositor)线程`以及`光栅(raster)线程`运行在`渲染进程`里面用来高效流畅地渲染出页面内容.

## 前端资源

通常我们说的前端资源是指的浏览器访问指定路径后由服务端发送回来用于渲染成页面的多种数据的集合.这些资源大致可以包含以下种类:

| 资源类型     | 说明                                                                                             | 提供位置                 |
| ------------ | ------------------------------------------------------------------------------------------------ | ------------------------ |
| `html文件`   | 用于声明页面初始元素的文件                                                                       | 本地域                   |
| `css文件`    | 用于声明页面元素的初识样式的文件                                                                 | 本地域或者第三方网络路径 |
| `js文件`     | 用于根据交互事件,时间等来触发改变页面元素行为的文件                                              | 本地域或者第三方网络路径 |
| `多媒体文件` | 用于展示的图片,音频,视频等多媒体文件,比如页面图标的`.ico`文件,动态图`.gif`,一般图片`.jpg/.png`等 | 本地域或者第三方网络路径 |
| `其他文件`   | 用于单纯的下载                                                                                   | 本地域                   |
| `数据`       | 通常是由服务的接口返回而不是由静态html服务返回, 常见的序列化格式有json和xml.                     | 本地域                   |

一般来说像css,js和图片我们可以选择服务器本地提供也可以选择使用第三方CDN提供的公共资源.其中尤其重要的是js资源,前端项目我们完全可以只在本地域提供我们自己业务相关的代码,而那些比如加密呀什么的已经有第三方实现的库我们可以通过CDN加载.最常用的CDN是`https://cdn.jsdelivr.net/`.其中托管了npm,github上的资源.这让我们几乎不需要再本地下载三方库

### 前端资源与web技术的客户端开发

本章是后续各个平台客户端开发的基础,基本上基于web技术的客户端开发都和浏览器环境的web前端开发有着千丝万缕的联系:

+ chrome插件完全复用html和css,只是比一般浏览器前端多一些特有的js接口
+ electron本质上就是个chromium封装,因此也是完全复用html和css,也是比一般浏览器前端多一些特有的js接口
+ 小程序开发一般来说元素也是使用类似html的标签,样式也是css的子集,也是会有一些专有的js接口实现一些特殊功能.
+ 移动端原生开发一般经过react-native,它和小程序类似也是使用类似html的标签,样式也是css的子集,也是会有一些专有的js接口实现一些特殊功能.

而在数据层面,现在各个平台客户端一般也都是使用基于http协议的数据后台.

本系列使用vue作为开发框架,介绍vue的基本用法也是本章节的重点.但在介绍之前我们还是先熟悉主要的前端资源.

## `hello world!`

前端项目提供展示和交互,无非不过可以分为:

+ 使用html和css展示内容,并配合js监听操作以提供交互.
+ 使用js配合与服务端的通信规范或获取本地资源接口获取用户需要的资源内容.
+ 将获取到的资源内容在本地处理,之后在DOM中渲染出来展示.

本文的例子是一个前端项目的最简单样板[浏览器环境-helloworld](https://github.com/hsz1273327/TutorialForFront-EndWeb/tree/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83-helloworld)实现了抓取github最新注册的用户的用户名,并展示出来的功能.有兴趣的可以看下.

本例子使用html中的fetch接口获取github公开restful api中需要的数据.
