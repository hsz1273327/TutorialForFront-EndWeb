# 图表

图表是数据可视化使用的工具.表格提供结构化的数据让我们可以清晰的查看数据;而图则让数据可以更直观的展现.

对于表格,我们通常用内容列表来实现.对于图,社区提供了一个基本可用的图表组件库[@nativescript-community/ui-chart](https://github.com/nativescript-community/ui-chart).它基于画板因此性能不错.但总的来说样式并不丰富只能算能用.

`@nativescript-community/ui-chart`接口基本与[MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)一致.

要使用它我们需要先安装`@nativescript-community/ui-chart`,然后在入口文件中注册自己需要的组件.每个组件都可以设置一些基本的属性,比如图例上的样式,是否可以缩放,是否可以拖拽点击等,一些类型的图还会有比如x轴,y轴,网格线等额外的属性可以设置.而图表要渲染的数据则通过若干个设置项来表达,每一个设置项会包括数据以及图例文本,最终调用`.setData(data)`接口后图表就会渲染起来.我们也可以在组件上设置属性`hardwareAccelerated="true"`开启硬件渲染,这可以提高渲染效率.

总体来说.`@nativescript-community/ui-chart`的配置化做的并不好,因此处理数据时不会像echarts那么方便,图的种类也没那么多,但好歹是有,总比没有好.

## 二维表格



## `ScatterChart`散点图

散点图一般用于展示数据分布.

### 注册组件

```Vue
import { ScatterChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('ScatterChart', ()=>ScatterChart);
```

### 使用

散点图中每条数据的形式满足`Array<Point>`,其中`Point`满足接口.

```ts
interface Point {
  x?: number,
  icon?: ImageSource,
  y: number
}
```

当不设置`x`时x会取值为数据在列表中的位置.当我们需要渲染自己的图形时可以填上`icon`字段.

散点图可以额外设置x轴,y轴,网格等属性.它的每一条要渲染的折线必须是一个`ScatterDataSet`类的实例.而`ScatterDataSet`类的构造函数参数为一个`List[Dict[str,float]]`形式的数组,图例文本,数组中每个元素中x轴的属性名和数组中每个元素中y轴的属性名.我们可以使用方法`.setScatterShape(ScatterShape.X)`设置点的形状,支持的形状包括:

+ `ScatterShape.SQUARE`方块
+ `ScatterShape.CIRCLE`圆点
+ `ScatterShape.TRIANGLE`三角
+ `ScatterShape.CROSS` 十字星
+ `ScatterShape.X`叉
+ `CHEVRON_UP`上v型
+ `ScatterShape.CHEVRON_DOWN`下v型

除了形状,还可以设置颜色进行区分,包括:

+ `.setColor('blue')`设置颜色图标颜色
+ `.setScatterShapeHoleRadius(3)`设置图标(方块,圆点,三角)有中心孔,参数为孔直径
+ `.setScatterShapeHoleColor('green')`设置有中心孔的图标中心孔的颜色

在要渲染的`ScatterDataSet`类的实例都构造好后需要用一个`ScatterData`类的实例将他们都打包起来,最后调动`.setData(data)`接口实现渲染.

> 例子:

```vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <ScatterChart ref="chart" @loaded="onChartLoaded" />
    </StackLayout>
  </Page>
</template>
  
<script lang="ts">
import Vue from "nativescript-vue";

import { ScatterChart, ScatterShape } from '@nativescript-community/ui-chart/charts/ScatterChart';
import { ScatterData } from '@nativescript-community/ui-chart/data/ScatterData';
import { ScatterDataSet } from '@nativescript-community/ui-chart/data/ScatterDataSet';
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis";
import { LegendForm, Legend, LegendOrientation, LegendVerticalAlignment, LegendHorizontalAlignment } from '@nativescript-community/ui-chart/components/Legend';
export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as ScatterChart;
      // //显示fps
      // chart.drawFrameRate = true;

      chart.setDrawGridBackground(false);
      chart.setTouchEnabled(true);
      chart.setMaxHighlightDistance(50);
      chart.setDragEnabled(true);
      chart.setScaleEnabled(true);
      chart.setMaxVisibleValueCount(200);
      chart.setPinchZoom(true);
      // 设置图例
      const l = chart.getLegend();
      l.setEnabled(true);
      l.setVerticalAlignment(LegendVerticalAlignment.TOP);
      l.setHorizontalAlignment(LegendHorizontalAlignment.RIGHT);
      l.setOrientation(LegendOrientation.VERTICAL);
      l.setDrawInside(false);
      l.setXOffset(5);
      const yl = chart.getAxisLeft();
      yl.setAxisMinimum(0); // this replaces setStartAtZero(true)
      chart.getAxisRight().setEnabled(false);
      const xl = chart.getXAxis();
      //// 设置x轴的粗度
      xl.setAxisLineWidth(3);
      //// 设置x轴所在的位置,默认在顶部
      xl.setPosition(XAxisPosition.BOTTOM);
      //// 设置隐藏y轴的网格
      xl.setDrawGridLines(false);

      // 设置待渲染的设置对象,构造函数参数为待渲染的数据, 图例标签,待渲染数据中代表x轴的属性名,待渲染数据中代表y轴的属性名

      const values1 = [];
      const values2 = [];
      const values3 = [];
      const range = 100;
      for (let i = 0; i < 20; i++) {
          values1.push({ y: Math.random() * range + 3, x: Math.random() * 5});
          values2.push({ y: Math.random() * range + 3 + 0.33 , x: Math.random() * 5});
          values3.push({ y: Math.random() * range + 3 + 0.66 , x: Math.random() * 5});
      }
      console.log(values1)
      // create a dataset and give it a type
      const set1 = new ScatterDataSet(values1, 'DS 1',"x","y");
      set1.setForm(LegendForm.SQUARE);
      set1.setScatterShape(ScatterShape.SQUARE);
      set1.setColor('red');
      const set2 = new ScatterDataSet(values2, 'DS 2',"x","y");
      set2.setForm(LegendForm.SQUARE);
      set2.setScatterShape(ScatterShape.CIRCLE);
      set2.setScatterShapeHoleColor('green');
      set2.setScatterShapeHoleRadius(3);
      set2.setColor('blue');
      const set3 = new ScatterDataSet(values3, 'DS 3',"x","y");
      set3.setForm(LegendForm.SQUARE);
      set3.setScatterShape(ScatterShape.X);
      set3.setColor('green');
      set1.setScatterShapeSize(8);
      set2.setScatterShapeSize(8);
      set3.setScatterShapeSize(8);
      // create a data object with the data sets
      const data = new ScatterData([set1, set2, set3]);
      // data.setValueTypeface(tfLight);
      
      chart.setData(data);
      chart.invalidate();
    },
  },
});
</script>
```

## `BubbleChart`气泡图

气泡图可以认为是散点图的扩展,除了可以展示三个变量之间的关系及数据分布情况

### 注册组件

```Vue
import { ScatterChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('ScatterChart', ()=>ScatterChart);
```

### 使用

散点图与散点图最大的区别就是数据要增加`size`值,这个`size`用于控制点的大小.其中每条数据的形式满足`Array<WeightedPoint>`,其中`WeightedPoint`满足接口

```ts
interface WeightedPoint {
  x?: number,
  icon?: ImageSource,
  y: number,
  size: number,
}
```

当不设置`x`时x会取值为数据在列表中的位置.当我们需要渲染自己的图形时可以填上`icon`字段.

与散点图不同,它不能设置形状只能设置颜色,如果不设置`icon`则默认为圆形点.

默认情况下size的值会被打印在图上,我们可以使用如下设置去掉size的值.

```ts
data.setDrawValues(false);
data.setValueTextSize(8);
data.setValueTextColor('white');
data.setHighlightCircleWidth(1.5);
```

> 例子:

```vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <BubbleChart ref="chart" @loaded="onChartLoaded" />
    </StackLayout>
  </Page>
</template>
  
<script lang="ts">
import Vue from "nativescript-vue";

import { BubbleChart } from '@nativescript-community/ui-chart/charts/BubbleChart';
import { BubbleData } from '@nativescript-community/ui-chart/data/BubbleData';
import { BubbleDataSet } from '@nativescript-community/ui-chart/data/BubbleDataSet';
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis";
import { LegendForm, LegendOrientation, LegendVerticalAlignment, LegendHorizontalAlignment } from '@nativescript-community/ui-chart/components/Legend';
export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as BubbleChart;

      chart.setDrawGridBackground(false);
      chart.setTouchEnabled(true);
      // enable scaling and dragging
      chart.setDragEnabled(true);
      chart.setScaleEnabled(true);
      chart.setMaxVisibleValueCount(200);
      chart.setPinchZoom(true);
      const l = chart.getLegend();
      l.setEnabled(true)
      l.setVerticalAlignment(LegendVerticalAlignment.TOP);
      l.setHorizontalAlignment(LegendHorizontalAlignment.RIGHT);
      l.setOrientation(LegendOrientation.VERTICAL);
      l.setDrawInside(false);
      const yl = chart.getAxisLeft();
      yl.setSpaceTop(30);
      yl.setSpaceBottom(30);
      yl.setDrawZeroLine(false);
      chart.getAxisRight().setEnabled(false);
      const xl = chart.getXAxis();
      xl.setPosition(XAxisPosition.BOTTOM);

      // 设置待渲染的设置对象,构造函数参数为待渲染的数据, 图例标签,待渲染数据中代表x轴的属性名,待渲染数据中代表y轴的属性名

      const values1 = [];
      const values2 = [];
      const values3 = [];
      for (let i = 0; i < 20; i++) {
          values1.push({
              y: Math.random() * 100,
              x: Math.random() * 10,
              size: Math.random() * 100,
          });
          values2.push({
              y: Math.random() * 100,
              x: Math.random() * 10,
              size: Math.random() * 100,
          });
          values3.push({
              y: Math.random() * 100,
              x: Math.random() * 10,
              size: Math.random() * 100
          });
      }
      // create a dataset and give it a type
      const set1 = new BubbleDataSet(values1, 'DS 1');
      set1.setForm(LegendForm.SQUARE);
      set1.setDrawValues(true);
      set1.setColor('red');
      const set2 = new BubbleDataSet(values2, 'DS 2');
      set2.setForm(LegendForm.SQUARE);
      set2.setDrawValues(true);
      set2.setColor('green');
      const set3 = new BubbleDataSet(values3, 'DS 3');
      set3.setForm(LegendForm.SQUARE);
      set3.setDrawValues(true);
      set3.setColor('blue');
      // create a data object with the data sets
      const data = new BubbleData([set1, set2, set3]);
      data.setDrawValues(false);
      data.setValueTextSize(8);
      data.setValueTextColor('white');
      data.setHighlightCircleWidth(1.5);
      chart.setData(data);
      chart.invalidate();
    },
  },
});
</script>
```

## `LineChart`折线图

折线图一般用于展示数据取值的连续变化,比如用于展示数值随时间的变化情况.

### 注册组件

```Vue
import { LineChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('LineChart', () => LineChart);
```

### 使用

折线图中每条数据的形式满足`Array<Point>`,其中`Point`满足接口

```ts
interface Point {
  x?: number,
  y: number
}
```

如果不设置x则x的取值为在列表中的位置.

折线图可以额外设置x轴,y轴,网格,填充区等属性,同时还可以设置`LimitLine`标明极值.它的每一条要渲染的折线必须是一个`LineDataSet`类的实例.而`LineDataSet`类的构造函数参数为一个`List[Dict[str,float]]`形式的数组,图例文本,数组中每个元素中x轴的属性名和数组中每个元素中y轴的属性名.在要渲染的`LineDataSet`类的实例都构造好后需要用一个`LineData`类的实例将他们都打包起来,最后调动`.setData(data)`接口实现渲染.

> 例子:

```Vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <LineChart
        ref="chart"
        width="300"
        height="400"
        @loaded="onChartLoaded"
        hardwareAccelerated="true"
      >
      </LineChart>
    </StackLayout>
  </Page>
</template>
  
<script lang="ts">
import Vue from "nativescript-vue";
import { LineChart } from "@nativescript-community/ui-chart/charts/LineChart";
import { LineDataSet } from "@nativescript-community/ui-chart/data/LineDataSet";
import { LineData } from "@nativescript-community/ui-chart/data/LineData";
import { LegendForm } from "@nativescript-community/ui-chart/components/Legend";
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis"
import { LimitLine, LimitLabelPosition } from '@nativescript-community/ui-chart/components/LimitLine';
import { DashPathEffect } from "@nativescript-community/ui-canvas";
import { Font } from '@nativescript/core';
import { FontStyle, FontWeight } from '@nativescript/core/ui/styling/font';
export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as LineChart;

      // 设置图表的背景色
      chart.backgroundColor = "white";

      // 设置为非只读可操作
      chart.setTouchEnabled(true);
      // 设置不画出网格
      chart.setDrawGridBackground(false);

      // 设置为可拖拽
      chart.setDragEnabled(true);
      // 设置为可伸缩
      chart.setScaleEnabled(true);

      // 设置强制捏合手势用于聚焦
      chart.setPinchZoom(true);

      //设置启用每次点击突出显示
      chart.setHighlightPerTapEnabled(true);
      //设置启用每次拖拽突出显示
      chart.setHighlightPerDragEnabled(true);

  
      // 设置图例标签
      const legend = chart.getLegend();
      /// 启用图例
      legend.setEnabled(true);
      /// 设置图例上的字体
      legend.setFont(new Font("serif", 10, FontStyle.ITALIC, FontWeight.EXTRA_LIGHT));
            
      // 设置坐标轴
      /// 设置x轴
      const xAxis = chart.getXAxis();
      //// 设置x轴的粗度
      xAxis.setAxisLineWidth(3);
      //// 设置x轴所在的位置,默认在顶部
      xAxis.setPosition(XAxisPosition.BOTTOM)
      //// 设置隐藏y轴的网格
      xAxis.setDrawGridLines(false)
      //设置x轴为红色
      // xAxis.setAxisLineColor('red');
      //// x轴网格使用虚线
      // xAxis.enableGridDashedLine(10, 10, 0);
      //// 设置x轴的label展示的字符串
      xAxis.setValueFormatter({
        getAxisLabel(value: number): string {
          let v: string | number = value;
          if (value == 0) {
            v = "日";
          }
          return `周${v}`;
        },
      });
            
      /// 设置y轴
      const yAxis = chart.getAxisLeft();
      //// 设置y轴宽度
      yAxis.setAxisLineWidth(3);
      //// 设置y轴的取值范围
      yAxis.setAxisMaximum(100);
      yAxis.setAxisMinimum(0);
      //// 设置y轴颜色
      // yAxis.setAxisLineColor('blue');
      //// y轴使用虚线
      // yAxis.enableGridDashedLine(10, 30, 0);
      //// 设置隐藏x轴的网格
      // yAxis.setDrawGridLines(false)
      
      /// 设置右轴
      const rightAxis = chart.getAxisRight();
      rightAxis.setEnabled(false);
      // //// 启用右轴
      // rightAxis.setEnabled(true);
      // //// 设置右轴颜色
      // rightAxis.setAxisLineColor('red');
      // //// 设置右轴宽度
      // rightAxis.setAxisLineWidth(2);
      // //// 设置右轴是否画网格线
      // rightAxis.setDrawGridLines(false)

      /// 设置极值线
      const ll1 = new LimitLine(90, 'Upper Limit');
      ll1.setLineWidth(4);
      ll1.enableDashedLine(10, 10, 0);
      ll1.setLabelPosition(LimitLabelPosition.RIGHT_TOP);
      ll1.setTextSize(10);
      const ll2 = new LimitLine(10, 'Lower Limit');
      ll2.setLineWidth(4);
      ll2.enableDashedLine(10, 10, 0);
      ll2.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
      ll2.setTextSize(10);

      // 在数据后面而不是在上面画限制线
      yAxis.setDrawLimitLinesBehindData(true);
      xAxis.setDrawLimitLinesBehindData(true);
      // 添加极值线
      yAxis.addLimitLine(ll1);
      yAxis.addLimitLine(ll2);
      //xAxis.addLimitLine(llXAxis);

      
      // 构造要渲染的数据,index为横轴,value为纵轴
      const myData = new Array(7).fill(0).map((v, i) => ({
          x: i,
          y: Math.random() * 100,
        }));

      // 设置待渲染的设置对象,构造函数参数为待渲染的数据, 图例标签,待渲染数据中代表x轴的属性名,待渲染数据中代表y轴的属性名
      const sets = [];
      const set = new LineDataSet(myData, "test line", "x", "y");
      /// 设置线条颜色
      set.setColor("blue");
      /// 设置是否开启y轴图标
      set.setDrawIcons(false);
      /// 设置使用虚线,参数为线条长度,空白长度,阶段
      // set.enableDashedLine(10, 5, 0);
      /// 设置点颜色
      set.setCircleColor("black");
      /// 设置线条宽度
      set.setLineWidth(1);
      /// 设置点的直径
      set.setCircleRadius(3);
      /// 设置点为实心点
      set.setDrawCircleHole(false);
      /// 自定义图例
      //// 设置图标样式
      set.setForm(LegendForm.LINE);
      set.setFormLineWidth(1);
      set.setFormLineDashEffect(new DashPathEffect([10, 5], 0));
      set.setFormSize(15);
      //设置值的文本字体大小
      set.setValueTextSize(9);
      // 将选择线画为虚线
      set.enableDashedHighlightLine(10, 5, 0);
      // 设置填充区
      set.setDrawFilled(true);
      set.setFillFormatter({
        getFillLinePosition(dataSet: any, dataProvider: any) {
          return chart.getAxisLeft().getAxisMinimum();
        },
      });
      // 设置填充区颜色set color of filled area
      set.setFillColor("red");

      sets.push(set);
      const ld = new LineData(sets);

      //将数据设置进组件中渲染
      chart.setData(ld);
    },
  },
});
</script>
```

## `BarChart`柱状图

柱状图可以理解为折线图的扩展,但一般用于观察数据的离散变化,比如展示几个竞品在不同地区的销售数据.

### 注册组件

```Vue
import { BarChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('BarChart', ()=>BarChart);
```

### 使用

柱状图中每条数据的形式满足`Array<Point>`,其中`Point`满足接口

```ts
interface Point {
  x?: number,
  y: number
}
```

如果不设置x则x的取值为在列表中的位置.

和折线图同样,柱状图可以设置x轴,y轴,网格,`LimitLine`极值,但不能设置填充区.而比起折线图来由于需要区分不同的实体,一般我们会将图例样式设置为`LegendForm.SQUARE`用`set.setStackLabels(["a", "b", "c", "d", "e", "f", "g"]);`而不是`xAxis.setValueFormatter()`填充x轴上的文本,并用`bd.setBarWidth()`设置柱宽,用`bd.groupBars(0, 0.3, 0.1)`将不同实体的柱分开展示

> 例子:

```Vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <BarChart
        ref="chart"
        width="300"
        height="400"
        @loaded="onChartLoaded"
        hardwareAccelerated="true"
      >
      </BarChart>
    </StackLayout>
  </Page>
</template>
  
<script lang="ts">
import Vue from "nativescript-vue";
import { BarChart } from "@nativescript-community/ui-chart/charts/BarChart";
import { BarData } from "@nativescript-community/ui-chart/data/BarData";
import { BarDataSet } from "@nativescript-community/ui-chart/data/BarDataSet";
import { LegendForm } from "@nativescript-community/ui-chart/components/Legend";
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis";
import {
  LimitLine,
  LimitLabelPosition,
} from "@nativescript-community/ui-chart/components/LimitLine";
import { DashPathEffect } from "@nativescript-community/ui-canvas";
import { Font } from "@nativescript/core";
import { FontStyle, FontWeight } from "@nativescript/core/ui/styling/font";
export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as BarChart;

      // 设置图表的背景色
      chart.backgroundColor = "white";

      // 设置为非只读可操作
      chart.setTouchEnabled(true);
      // 设置不画出网格
      chart.setDrawGridBackground(false);

      // 设置为可拖拽
      chart.setDragEnabled(true);
      // 设置为可伸缩
      chart.setScaleEnabled(true);

      // 设置强制捏合手势用于聚焦
      chart.setPinchZoom(true);

      //设置启用每次点击突出显示
      chart.setHighlightPerTapEnabled(true);
      //设置启用每次拖拽突出显示
      chart.setHighlightPerDragEnabled(true);

      // 设置图例标签
      const legend = chart.getLegend();
      /// 启用图例
      legend.setEnabled(true);
      /// 设置图例上的字体
      legend.setFont(
        new Font("serif", 10, FontStyle.ITALIC, FontWeight.EXTRA_LIGHT)
      );

      // 设置坐标轴
      /// 设置x轴
      const xAxis = chart.getXAxis();
      //// 设置x轴的粗度
      xAxis.setAxisLineWidth(3);
      //// 设置x轴所在的位置,默认在顶部
      xAxis.setPosition(XAxisPosition.BOTTOM);
      //// 设置隐藏y轴的网格
      xAxis.setDrawGridLines(false);
      // xAxis.setValueFormatter({
      //   getAxisLabel(value: number): string {
      //     let v: string | number = value;
      //     if (value == 0) {
      //       v = "日";
      //     }
      //     return `周${v}`;
      //   },
      // });
      //设置x轴为红色
      // xAxis.setAxisLineColor('red');
      //// x轴网格使用虚线
      // xAxis.enableGridDashedLine(10, 10, 0);

      /// 设置y轴
      const yAxis = chart.getAxisLeft();
      //// 设置y轴宽度
      yAxis.setAxisLineWidth(3);
      //// 设置y轴的取值范围
      yAxis.setAxisMaximum(100);
      yAxis.setAxisMinimum(0);
      //// 设置y轴颜色
      // yAxis.setAxisLineColor('blue');
      //// y轴使用虚线
      // yAxis.enableGridDashedLine(10, 30, 0);
      //// 设置隐藏x轴的网格
      yAxis.setDrawGridLines(false)

      /// 设置右轴
      const rightAxis = chart.getAxisRight();
      rightAxis.setEnabled(false);
      // //// 启用右轴
      // rightAxis.setEnabled(true);
      // //// 设置右轴颜色
      // rightAxis.setAxisLineColor('red');
      // //// 设置右轴宽度
      // rightAxis.setAxisLineWidth(2);
      // //// 设置右轴是否画网格线
      // rightAxis.setDrawGridLines(false)

  
      //xAxis.addLimitLine(llXAxis);

      // 设置待渲染的设置对象,构造函数参数为待渲染的数据, 图例标签,待渲染数据中代表x轴的属性名,待渲染数据中代表y轴的属性名
      const sets = [];

      for (let x of ["red", "yellow", "blue"]) {
        // 构造要渲染的数据,index为横轴,value为纵轴
        const myData = new Array(7).fill(0).map((v, i) => ({
          x: i,
          y: Math.random() * 100,
        }));
        const set = new BarDataSet(myData, `test bar ${x}`, "x", "y");
        /// 设置线条颜色
        set.setColor(x);
        /// 设置是否开启y轴图标
        set.setDrawIcons(false);
        /// 设置使用虚线,参数为线条长度,空白长度,阶段

        /// 自定义图例
        //// 设置图标样式
        set.setForm(LegendForm.SQUARE);
        // set.setFormLineWidth(1);
        // set.setFormLineDashEffect(new DashPathEffect([10, 5], 0));
        // set.setFormSize(15);
        //设置值的文本字体大小
        set.setValueTextSize(9);
        set.setStackLabels(["a", "b", "c", "d", "e", "f", "g"]);
        // 将选择线画为虚线
        // set.enableDashedHighlightLine(10, 5, 0);

        sets.push(set);
      }

      const bd = new BarData(sets);
      bd.setBarWidth(0.1)
      bd.groupBars(0, 0.3, 0.1);
      //将数据设置进组件中渲染
      chart.setData(bd);
    },
  },
});
</script>
```

## `HorizontalBarChart`水平柱状图

水平柱状图和柱状图一样适用于展示离散变化.只是转了个90度方便做成长条利于观察而已.

### 注册组件

```Vue
import { HorizontalBarChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('HorizontalBarChart', ()=>HorizontalBarChart);
```

### 使用

柱状图中每条数据的形式满足`Array<Point>`,其中`Point`满足接口

```ts
interface Point {
  x?: number,
  y: number
}
```

如果不设置x则x的取值为在列表中的位置

> 例子:

```Vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <HorizontalBarChart ref="chart" @loaded="onChartLoaded" />
    </StackLayout>
  </Page>
</template>
  
<script lang="ts">
import Vue from "nativescript-vue";
import { HorizontalBarChart } from "@nativescript-community/ui-chart/charts/HorizontalBarChart";
import { BarData } from "@nativescript-community/ui-chart/data/BarData";
import { BarDataSet } from "@nativescript-community/ui-chart/data/BarDataSet";
import { LegendForm } from "@nativescript-community/ui-chart/components/Legend";
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis";
import {
  LimitLine,
  LimitLabelPosition,
} from "@nativescript-community/ui-chart/components/LimitLine";
import { DashPathEffect } from "@nativescript-community/ui-canvas";
import { Font } from "@nativescript/core";
import { FontStyle, FontWeight } from "@nativescript/core/ui/styling/font";
export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as HorizontalBarChart;

      // 设置图表的背景色
      chart.backgroundColor = "white";

      // 设置为非只读可操作
      chart.setTouchEnabled(true);
      // 设置不画出网格
      chart.setDrawGridBackground(false);

      // 设置为可拖拽
      chart.setDragEnabled(true);
      // 设置为可伸缩
      chart.setScaleEnabled(true);

      // 设置强制捏合手势用于聚焦
      chart.setPinchZoom(true);

      //设置启用每次点击突出显示
      chart.setHighlightPerTapEnabled(true);
      //设置启用每次拖拽突出显示
      chart.setHighlightPerDragEnabled(true);

      // 设置图例标签
      const legend = chart.getLegend();
      /// 启用图例
      legend.setEnabled(true);
      /// 设置图例上的字体
      legend.setFont(
        new Font("serif", 10, FontStyle.ITALIC, FontWeight.EXTRA_LIGHT)
      );

      // 设置坐标轴
      /// 设置x轴
      const xAxis = chart.getXAxis();
      //// 设置x轴的粗度
      xAxis.setAxisLineWidth(3);
      //// 设置x轴所在的位置,默认在顶部
      xAxis.setPosition(XAxisPosition.BOTTOM);
      //// 设置隐藏y轴的网格
      xAxis.setDrawGridLines(false);

      /// 设置y轴
      const yAxis = chart.getAxisLeft();
      //// 设置y轴宽度
      yAxis.setAxisLineWidth(3);
      //// 设置y轴的取值范围
      yAxis.setAxisMaximum(100);
      yAxis.setAxisMinimum(0);

      yAxis.setDrawGridLines(false)

      const sets = [];

      for (let x of ["red", "yellow", "blue"]) {
        // 构造要渲染的数据,index为横轴,value为纵轴
        const myData = new Array(7).fill(0).map((v, i) => ({
          x: i,
          y: Math.random() * 100,
        }));
        const set = new BarDataSet(myData, `test bar ${x}`, "x", "y");
        /// 设置线条颜色
        set.setColor(x);
        /// 设置是否开启y轴图标
        set.setDrawIcons(false);
        /// 设置使用虚线,参数为线条长度,空白长度,阶段


        set.setForm(LegendForm.SQUARE);

        set.setValueTextSize(9);
        set.setStackLabels(["a", "b", "c", "d", "e", "f", "g"]);

        sets.push(set);
      }

      const bd = new BarData(sets);
      bd.setBarWidth(0.1)
      bd.groupBars(0, 0.3, 0.1);
      //将数据设置进组件中渲染
      chart.setData(bd);
    },
  },
});
</script>
```

## `CandleStickChart`蜡烛图

蜡烛图一般也就是k线图,用于展示开始值,结束值,最高值,最低值这4个数据的连续变化情况.

### 注册组件

```Vue
import { CandleStickChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('CandleStickChart', ()=>CandleStickChart);
```

### 使用

柱状图中每条数据的形式满足`Array<KPoint>`,其中`Point`满足接口

```ts
interface KPoint {
  x?: number,
  high: number,
  low: number,
  open: number,
  close: number,
}
```

如果不设置x则x的取值为在列表中的位置.

而在图形上,我们知道k线图有框有上下影线,框表示open,close的值,上下影线则表示最大值最小值.通常如果open>close则表示涨,反之为跌.我们可以通过设置`.setDecreasingColor()`和`.setIncreasingColor()`设置涨跌框的颜色;使用`.setDecreasingPaintStyle()`和`.setIncreasingPaintStyle()`设置涨跌框的样式,支持的样式在`@nativescript-community/ui-canvas`模块中,包括

+ `Style.FILL` 填充满
+ `Style.FILL_AND_STROKE`
+ `Style.STROKE`空框

我们也可以设置影线样式.`setShadowWidth()`可以用于设置影线宽度.`.setShadowColor()`用于设置影线颜色,我们也可以使用`.setShadowColorSameAsCandle(true)`让影线和框颜色一致.

> 例子:

```vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <CandleStickChart ref="chart" @loaded="onChartLoaded" />
    </StackLayout>
  </Page>
</template>
  

<script lang="ts">
import Vue from "nativescript-vue";
import { Color } from "@nativescript/core";
import { CandleStickChart } from "@nativescript-community/ui-chart/charts/CandleStickChart";
import { CandleData } from "@nativescript-community/ui-chart/data/CandleData";
import { CandleDataSet } from "@nativescript-community/ui-chart/data/CandleDataSet";
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis";
import { AxisDependency } from "@nativescript-community/ui-chart/components/YAxis";
import { Style } from "@nativescript-community/ui-canvas";
export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as CandleStickChart;

      // 设置最大可以看见的
      chart.setMaxVisibleValueCount(60);
      // scaling can now only be done on x- and y-axis separately
      chart.setPinchZoom(false);
      chart.getLegend().setEnabled(false);
      chart.setDrawGridBackground(false);
      const xAxis = chart.getXAxis();
      xAxis.setPosition(XAxisPosition.BOTTOM);
      xAxis.setDrawGridLines(false);
      const leftAxis = chart.getAxisLeft();
      //        leftAxis.setEnabled(false);
      leftAxis.setLabelCount(7, false);
      leftAxis.setDrawGridLines(false);
      leftAxis.setDrawAxisLine(false);
      const rightAxis = chart.getAxisRight();
      rightAxis.setEnabled(false);

      // 构造要渲染的数据,index为横轴,value为纵轴

      const values1 = [];
      chart.resetTracking();
      const values = [];
      for (let i = 0; i < 30; i++) {
        const multi = 100 + 1;
        const val = Math.random() * 40 + multi;
        const high = Math.random() * 9 + 8;
        const low = Math.random() * 9 + 8;
        const open = Math.random() * 6 + 1;
        const close = Math.random() * 6 + 1;
        const even = i % 2 == 0;
        values.push({
          high: val + high,
          low: val - low,
          open: even ? val + open : val - open,
          close: even ? val - close : val + close,
        });
      }
      const set1 = new CandleDataSet(values, "Data Set");
      set1.setDrawIcons(false);
      set1.setAxisDependency(AxisDependency.LEFT);
      
      //设置open<close
      set1.setDecreasingColor("green");
      set1.setDecreasingPaintStyle(Style.FILL);
      //设置open>close
      set1.setIncreasingColor("red");
      set1.setIncreasingPaintStyle(Style.STROKE);
      //设置当open==close的情况
      // set1.setNeutralColor("blue");
      //设置影线
      // set1.setShadowColor("darkgray");
      set1.setShadowColorSameAsCandle(true);
      set1.setShadowWidth(0.7);
      
      const data = new CandleData([set1]);
      chart.setData(data);
    },
  },
});
</script>
```

## `PieChart`饼图

饼图一般用于展示统计数据占比.比如一个产品不同地区的销售量比例这类.

### 注册组件

```Vue
import { PieChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('PieChart', ()=>PieChart);
```

### 使用

饼图通常只会有一条数据,这个数据的形式满足`Array<PieValue>`,其中`PieValue`满足接口

```ts
interface PieValue {
  y: number,
  label: string,
}
```

每个元素在列表中的位置会体现在饼图中渲染的位置顺序上.

> 例子:

```vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <PieChart ref="chart" @loaded="onChartLoaded" />
    </StackLayout>
  </Page>
</template>
  

<script lang="ts">
import Vue from "nativescript-vue";
import {
  LegendHorizontalAlignment,
  LegendOrientation,
  LegendVerticalAlignment,
} from "@nativescript-community/ui-chart/components/Legend";
import { ColorTemplate } from "@nativescript-community/ui-chart/utils/ColorTemplate";
import { PieChart } from "@nativescript-community/ui-chart/charts/PieChart";
import { PieData } from "@nativescript-community/ui-chart/data/PieData";
import { PieDataSet } from "@nativescript-community/ui-chart/data/PieDataSet";

import { PieEntry } from "@nativescript-community/ui-chart/data/PieEntry";
import { BaseEntry } from "@nativescript-community/ui-chart/data/BaseEntry";
import { AxisBase } from "@nativescript-community/ui-chart/components/AxisBase";
import { BarEntry } from "@nativescript-community/ui-chart/data/BarEntry";
import { Entry } from "@nativescript-community/ui-chart/data/Entry";
import { RadarEntry } from "@nativescript-community/ui-chart/data/RadarEntry";
import { BubbleEntry } from "@nativescript-community/ui-chart/data/BubbleEntry";
import { CandleEntry } from "@nativescript-community/ui-chart/data/CandleEntry";

export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as PieChart;

      // 设置使用百分比数值
      chart.setUsePercentValues(true);
      chart.getDescription().setEnabled(false);
      chart.setExtraOffsets(5, 10, 5, 5);
      chart.setDragDecelerationFrictionCoef(0.95);
      // 设置中心文本
      chart.setDrawCenterText(true);
      chart.setCenterText("中心文本");
      // 中间留出空洞和空洞样式
      chart.setDrawHoleEnabled(true);
      chart.setHoleColor("white");
      chart.setHoleRadius(58);
      //透明环样式
      chart.setTransparentCircleColor("white");
      chart.setTransparentCircleAlpha(110);
      chart.setTransparentCircleRadius(61);
      //触摸旋转样式设置
      chart.setRotationEnabled(true);
      chart.setRotationAngle(0);
      // 设置点击高亮
      chart.setHighlightPerTapEnabled(true);
      //设置图例
      const l = chart.getLegend();
      l.setEnabled(true);
      l.setVerticalAlignment(LegendVerticalAlignment.TOP);
      l.setHorizontalAlignment(LegendHorizontalAlignment.RIGHT);
      l.setOrientation(LegendOrientation.VERTICAL);
      l.setDrawInside(false);
      l.setXEntrySpace(7);
      l.setYEntrySpace(0);
      l.setYOffset(0);
      //设置实体label的样式
      chart.setEntryLabelColor("white");
      chart.setEntryLabelTextSize(12);
      chart.setDrawEntryLabels(true);
    

      // 构造要渲染的数据,index为横轴,value为纵轴
      let entries = [];
      const parties = [
        "Party A",
        "Party B",
        "Party C",
        "Party D",
        "Party E",
        "Party F",
        "Party G",
        "Party H",
        "Party I",
        "Party J",
        "Party K",
        "Party L",
        "Party M",
        "Party N",
        "Party O",
        "Party P",
        "Party Q",
        "Party R",
        "Party S",
        "Party T",
        "Party U",
        "Party V",
        "Party W",
        "Party X",
        "Party Y",
        "Party Z",
      ];
      for (let i = 0; i < 10; i++) {
        entries.push({
          y: Math.random() * 50 + 50 / 5,
          label: parties[i % parties.length],
        });
      }
      const dataSet = new PieDataSet(entries, "Pie test labels", "y");
      dataSet.setSliceSpace(3);
      dataSet.setIconsOffset({ x: 0, y: 40 });
      dataSet.setSelectionShift(5);
     
      //设置颜色,颜色从ColorTemplate中获取,渲染时按位置获取颜色
      const colors = [];
      colors.push(...ColorTemplate.VORDIPLOM_COLORS);
      colors.push(...ColorTemplate.JOYFUL_COLORS);
      colors.push(...ColorTemplate.COLORFUL_COLORS);
      colors.push(...ColorTemplate.LIBERTY_COLORS);
      colors.push(...ColorTemplate.PASTEL_COLORS);
      colors.push(ColorTemplate.getHoloBlue());
      dataSet.setColors(colors);
      //设置渲染每一块时展示的对应文本,只有`getPieLabel`有用其他都只是为了满足接口
      dataSet.setValueFormatter({
        getFormattedValue(value: number, entry?: BaseEntry): string {
          return "";
        },
        getAxisLabel(value: number, axis: AxisBase): string {
          return "";
        },
        getBarLabel(value: any, entry: BarEntry): string {
          return "";
        },
        getBarStackedLabel(value: any, entry: BarEntry): string {
          return "";
        },
        getPointLabel(value: any, entry: Entry): string {
          return "";
        },
        getPieLabel(value: any, entry: PieEntry): string {
          return `${entry.label}:${value}`;
        },
        getRadarLabel(value: any, entry: RadarEntry): string {
          return "";
        },
        getBubbleLabel(value: any, entry: BubbleEntry): string {
          return "";
        },
        getCandleLabel(value: any, entry: CandleEntry): string {
          return "";
        },
      });
      //启用渲染每一块上的文本标识
      dataSet.setDrawValues(true);
      const data = new PieData([dataSet]);

      data.setValueTextSize(11);
      data.setValueTextColor("white");
      chart.setData(data);
    },
  },
});
</script>
```

## `RadarChart`雷达图

雷达图一般用于展示一组数据中各个变量的权重高低情况,非常适用于展示性能数据.我们在网页部分的英雄模拟器中就是使用的雷达图展示每个英雄的战斗力属性.

`RadarChart`似乎并没有开发好,有一些bug需要在安装好模块后进行修改--修改`node_modules/@nativescript-community/ui-chart/renderer/XAxisRendererRadarChart.js`文件中`XAxisRendererRadarChart->renderAxisLabels`方法

```ts
//const labels = axis.mLabels; //修改这个为下面
const labels = chart.mData.mLabels;
```

如果不修改,我们就没办法为雷达图设置每一条线上的文本标签

### 注册组件

```Vue
import { RadarChart } from "@nativescript-community/ui-chart/charts"

Vue.registerElement('RadarChart', ()=>RadarChart);
```

### 使用

饼图通常只会有一条数据,这个数据的形式满足`Array<RenderValue>`,其中`RenderValue`满足接口

```ts
interface RenderValue {
  y: number
}
```

每个元素在列表中的位置会体现在饼图中渲染的位置顺序上.

雷达图主要的展示元素为同心多边形,看着像蜘蛛网.它的X轴被扭曲为了最外层多边形的边,Y轴则成了中心点向上的半径.X轴和Y轴的设置和其他组件没有太大区别,主要不同的就是对这个`蜘蛛网`的设置.

我们可以用`.setWebxxx()`方法设置这个`蜘蛛网`上的纬线,用`.setWebxxxInner()`方法设置这个`蜘蛛网`上的经线.而数据的标签则需要在`RadarData`实例上通过方法`.setLabels()`设置

> 例子:

```vue
<template>
  <Page actionBarHidden="true">
    <StackLayout>
      <RadarChart ref="chart" @loaded="onChartLoaded" />
    </StackLayout>
  </Page>
</template>
  

<script lang="ts">
import Vue from "nativescript-vue";

import { RadarChart } from "@nativescript-community/ui-chart/charts/RadarChart";
import { RadarData } from "@nativescript-community/ui-chart/data/RadarData";
import { RadarDataSet } from "@nativescript-community/ui-chart/data/RadarDataSet";

import { PieEntry } from "@nativescript-community/ui-chart/data/PieEntry";
import { BaseEntry } from "@nativescript-community/ui-chart/data/BaseEntry";
import { AxisBase } from "@nativescript-community/ui-chart/components/AxisBase";
import { BarEntry } from "@nativescript-community/ui-chart/data/BarEntry";
import { Entry } from "@nativescript-community/ui-chart/data/Entry";
import { RadarEntry } from "@nativescript-community/ui-chart/data/RadarEntry";
import { BubbleEntry } from "@nativescript-community/ui-chart/data/BubbleEntry";
import { CandleEntry } from "@nativescript-community/ui-chart/data/CandleEntry";
import { ViewPortHandler } from "@nativescript-community/ui-chart/utils/ViewPortHandler";

export default Vue.extend({
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as RadarChart;

      // 设置点击高亮
      chart.setHighlightPerTapEnabled(true);
      chart.setWebColor("red");
      chart.setWebColorInner("blue");

      //y轴
      let yl = chart.getYAxis()
      yl.setSuggestedAxisMinimum(0)
      yl.setSpaceMax(2)
      let xl = chart.getXAxis()
      xl.setTextColor("green");

      // 构造要渲染的数据,index为横轴,value为纵轴
      let entries = [];
      const parties = ["Party A", "Party B", "Party C", "Party D", "Party E"];
      for (let i = 0; i < 5; i++) {
        entries.push({
          y: Math.random() * 10,
        });
      }
      const dataSet = new RadarDataSet(entries, "性能指标", "y");
      dataSet.setValueFormatter({
        getFormattedValue(value: number, entry?: BaseEntry): string {
          return "";
        },
        getAxisLabel(value: number, axis: AxisBase): string {
          return "";
        },
        getBarLabel(value: any, entry: BarEntry): string {
          return "";
        },
        getBarStackedLabel(value: any, entry: BarEntry): string {
          return "";
        },
        getPointLabel(value: any, entry: Entry): string {
          return "";
        },
        getPieLabel(value: any, entry: PieEntry): string {
          return "";
        },
        getRadarLabel(value: any, entry: RadarEntry): string {
          return `${value}`;
        },
        getBubbleLabel(value: any, entry: BubbleEntry): string {
          return "";
        },
        getCandleLabel(value: any, entry: CandleEntry): string {
          return "";
        },
      });
      dataSet.setDrawValues(true);
      const data = new RadarData([dataSet]);
      data.setLabels(parties);
      chart.setData(data);
    },
  },
});
</script>
```

## 动态刷新数据

很多时候,尤其折线图和蜡烛图,我们会需要动态刷新当前数据.上面的静态渲染方式就需要进行修正了.

整体来说动态刷新数据要做两件事

1. 给chart对象更新数据
2. 通知chart对象重新渲染

和上面静态图表不同,通常我们会在动态图表的`@loaded`上绑定一个构造图表基本形态的函数,这个函数一般会给一个空的data或者一个静态的data进行对图表的初始化.而更新这个图表的数据则放在单独的函数中要么定时调用要么通过监听其他比如sse这样的技术来实现数据刷新.在数据更新后我们还要按顺序调用`data.notifyDataChanged()`来通知data对象dataset已经改变,以及`chart.notifyDataSetChanged()`来通知chart对象data已经改变

> 例子:一个定时更新的折线图

```vue
<template>
  <Page actionBarHidden="true">
    <GridLayout rows="*,auto,auto">
      <LineChart
        ref="chart"
        @loaded="onChartLoaded"
        :hardwareAccelerated="hardwareAccelerated"
      />
      <Switch row="1" v-model="hardwareAccelerated" />
      <Button row="2" text="stop" @tap="stop" />
    </GridLayout>
  </Page>
</template>
  

<script lang="ts">
import Vue from "vue";
import { Color, Frame, Font } from "@nativescript/core";
import { setInterval } from "@nativescript/core/timer";
import { LineChart } from "@nativescript-community/ui-chart/charts/LineChart";
import { LegendForm } from "@nativescript-community/ui-chart/components/Legend";
import { AxisDependency } from "@nativescript-community/ui-chart/components/YAxis";
import { XAxisPosition } from "@nativescript-community/ui-chart/components/XAxis";
import { LineDataSet } from "@nativescript-community/ui-chart/data/LineDataSet";
import { LineData } from "@nativescript-community/ui-chart/data/LineData";
import { ColorTemplate } from "@nativescript-community/ui-chart/utils/ColorTemplate";
import { AxisBase } from "@nativescript-community/ui-chart/components/AxisBase";
import { ViewPortHandler } from "@nativescript-community/ui-chart/utils/ViewPortHandler";
import Denque from "denque";

interface Data {
  hardwareAccelerated: boolean;
  timer: number | null;
  indexVal: Denque;
}
export default Vue.extend({
  data: function (): Data {
    return {
      hardwareAccelerated: false,
      timer: null,
      indexVal: new Denque([], { capacity: 20 }),
    };
  },
  methods: {
    onChartLoaded() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as LineChart;
      chart.setTouchEnabled(true);
      chart.setDragEnabled(true);
      chart.setScaleEnabled(true);
      chart.setDrawGridBackground(false);
      chart.setPinchZoom(true);
      chart.backgroundColor = "lightgray";
      // 绑定一个空的数据对象
      const data = new LineData();
      data.setValueTextColor("white");
      chart.setData(data);
      // 设置图例
      const l = chart.getLegend();
      l.setForm(LegendForm.LINE);
      l.setTypeface(Font.default.withFontFamily("OpenSans-Light"));
      l.setTextColor("white");
      // 设置x轴
      const xl = chart.getXAxis();
      xl.setTextColor("red");
      xl.setDrawGridLines(false);
      xl.setAvoidFirstLastClipping(true);
      xl.setEnabled(true);
      xl.setPosition(XAxisPosition.BOTTOM);
      xl.setValueFormatter({
        getAxisLabel: (
          value: any,
          axis: AxisBase,
          viewPortHandler: ViewPortHandler
        ): string => {
          //在保存的dequeue中找到value对应的时间信息
          let indexarray =this.indexVal.toArray();
          let res = indexarray.filter((e) => e.index == Math.floor(value))
          if (res.length != 1){
            return `${value}`
          }
          let now= res[0].datetime
          return `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;
        },
      });

      // 设置左轴
      const leftAxis = chart.getAxisLeft();
      leftAxis.setTypeface(Font.default.withFontFamily("OpenSans-Light"));
      leftAxis.setTextColor("white");
      leftAxis.setAxisMaximum(100);
      leftAxis.setAxisMinimum(0);
      leftAxis.setDrawGridLines(true);
      //设置右轴
      const rightAxis = chart.getAxisRight();
      rightAxis.setEnabled(false);
    },
    start() {
      if (!this.timer) {
        this.timer = setInterval(this.addEntry, 1000);
      }
    },
    stop() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    },
    addEntry() {
      // In case user leaves this page
      if (!this.$refs.chart) {
        this.stop();
        return;
      }
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as LineChart;
      const data = chart.getData();
      if (data != null) {
        let set = data.getDataSetByIndex(0);
        // set.addEntry(...); // can be called as well
        if (set == null) {
          set = this.createSet();
          data.addDataSet(set);
        }
        // 构造数据
        let datetime = new Date();
        let y = Math.random() * 40 + 30;
        let e = { y };
        // 将数据推入dataset
        data.addEntry(e, 0);
        // 获取数据在dataset中的index
        let dset = data.getDataSetByIndex(0);
        let eindex = dset.getEntryIndex(e);
        //将横轴输入存入dequeue
        let labelindex = { datetime, index: eindex };
        this.indexVal.push(labelindex);
        
        // 通知data对象dataset已经改变
        data.notifyDataChanged();
        // 通知chart对象data已经改变
        chart.notifyDataSetChanged();
        // 设置可见数据条目最大数量
        chart.setVisibleXRangeMaximum(120);
        // x轴调到最后
        chart.moveViewToX(data.getEntryCount());
      }
    },
    createSet() {
      const set = new LineDataSet(null, "Dynamic Data");
      set.setAxisDependency(AxisDependency.LEFT);
      set.setColor(ColorTemplate.getHoloBlue());
      set.setCircleColor("white");
      set.setLineWidth(2);
      set.setCircleRadius(4);
      set.setFillAlpha(65);
      set.setFillColor(ColorTemplate.getHoloBlue());
      set.setHighLightColor(new Color(255, 244, 117, 117));
      set.setValueTextColor("white");
      set.setValueTextSize(9);
      set.setDrawValues(false);
      return set;
    },
    redraw() {
      const eleview = this.$refs.chart as Vue;
      const chart = eleview.nativeView as LineChart;
      chart.invalidate();
    },
    onNavigationButtonTap() {
      Frame.topmost().goBack();
    },
  },
  mounted() {
    this.start();
  },
});
</script>

```
