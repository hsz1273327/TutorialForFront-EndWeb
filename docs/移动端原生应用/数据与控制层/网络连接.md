# 网络连接

现在的手机应用几乎都会用到网络,基本上用途有

+ 从远端服务器上拉取内容
+ 从远端服务器上接收消息
+ 将本地数据上传回远端服务器

和在浏览器中一样,移动端的网络连接是不安全不稳定的外网环境,因此通常它也和浏览器中使用相同的网络协议:

+ http协议,通常是RESTful接口,用于执行请求响应模式的短连接,用sse技术,实现从远端服务器上接收消息的功能避免轮询
+ websocket协议,实现客户端与服务端的双工通讯
+ webrtc协议,实现p2p网络

同时由于手机也算是嵌入式设备,一些时候也会使用`MQTT`协议订阅消息.

## 调试时的网络设定

通常我们调试都是在模拟器上,模拟器环境的网络环境和本地并不一样,在android上要访问开发机上的localhost需要使用`10.0.2.2`地址.

我们开发时本地起的服务器通常不会用TLS,这时android环境下我们还需要在`App_Resource/Android/src/main/res/AndroidManifest.xml`,找到`application`节点,属性上加上
`android:usesCleartextTraffic="true"`就可以了.

## Http

Http是最常用的网络传输协议,移动端自然也用的最多.http协议的优势是适用范围广技术成熟,而且请求响应模式也最易调试.

### 原生实现

[nativescript官方核心库中有现成的客户端实现](https://docs.nativescript.org/core/http).这个接口实现的很简单,没有任何性能优化,也没有额外功能,当然正常使用也够.

```ts
async function getUsers() {
    try {
        let resp: UserInfo[] = await Http.getJSON(url)
        users.value = resp.map((x) => x.login)
    } catch (e) {
        console.log(`getUsers get error ${e}`)
    }
}
```

`Http`包提供了下面几个简便方法用于执行http的GET请求

| 接口                                                                    | 说明                                                                                                           |
| ----------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `Http.getString(url: string): Promise<string>`                          | `GET`方法请求,返回值body解析为string类型后异步返回                                                             |
| `Http.getJSON<T>(url: string): Promise<T>`                              | `GET`方法请求,返回值body用`JSON.parse`解析后异步返回,泛型T是解析后json对象的类型                               |
| `Http.getImage(url: string): Promise<ImageSource>`                      | `GET`方法请求,返回值body解析为[ImageSource对象](https://docs.nativescript.org/api/class/ImageSource)后异步返回 |
| `Http.getFile(url: string, destinationFilePath: string): Promise<File>` | `GET`方法请求,返回值body写入到指定路径`destinationFilePath`中,并异步的返回这个路径的文件对象                   |

如果需要相对复杂的请求,比如`POST`请求,带header的请求等就需要使用接口`Http.request(options: HttpRequestOptions): Promise<HttpResponse>`.

其中`HttpRequestOptions`接口形式为

```ts
interface HttpRequestOptions {
  content: string | FormData | ArrayBuffer;
  dontFollowRedirects: boolean;
  headers: any;
  method: string;
  timeout: number;
  url: string;
}
```

`HttpResponse`接口形式为

```ts
interface HttpResponse {
  content: HttpContent;
  headers: Headers;
  statusCode: number;
}
```

而`HttpContent`接口形式为

```ts
interface HttpContent {
  raw: any;
  toArrayBuffer: () => ArrayBuffer;
  toFile: (destinationFilePath?: string) => File;
  toImage: () => Promise<ImageSource>;
  toJSON: (encoding?: HttpResponseEncoding) => any;
  toString: (encoding?: HttpResponseEncoding) => string;
}
```

原生的http客户端接口可谓相当简陋,没有连接池,也没有表单格式解析,但也胜在简单,如果仅用于请求资源或者调用RESTful接口这些也够用了.

### 社区提供的https请求支持

原生的HTTP接口简单够用,但如果你有如下需求,你还是用社区提供的[@nativescript-community/https](https://github.com/nativescript-community/https)比较好.

+ 需要自定义TLS证书签名
+ 需要使用请求池
+ 链接需要可以静默恢复
+ 全程后台线程执行
+ 透明的gzip压缩
+ HTTP/2特性
+ 希望使用更加对象化的表单和RESTful接口请求
+ 需要Cache
+ 基础cookie支持

安装也很简单,`ns plugin add @nativescript-community/https`即可.

使用上兼容自带的HTTP接口,只是增加了

+ `enableSSLPinning({ host: 'httpbin.org', certificate })`和`disableSSLPinning()`用于设置本地的TLS证书.设置的接口为

    ```ts
    interface HttpsSSLPinningOptions {
        host: string; //域名
        certificate: string; //证书文件(.cer)位置
        allowInvalidCertificates?: boolean;//默认值`false`,如果使用自签名证书需要设置为true
        validatesDomainName?: boolean;//默认值`true`,确定是否应使用固定证书验证域名
        commonName?: string;//仅对android有效,默认即为host的值,如果CN证书和主机不同就需要设置
    }
    ```

+ `setCache({diskLocation: path,diskSize: int})`用于设置请求的缓存,设置项接口为

  ```ts
    interface CacheOptions{
      diskLocation: string; //缓存保存位置
      diskSize: number; //缓存占用磁盘大小
      memorySize?: number; //缓存占用内存大小
      forceCache?: boolean; //是否强制缓存
    }
  ```

+ 请求设置接口有2处优化,增加了5个字段,,接口如下:

  ```ts
  interface HttpsRequestOptions extends HttpRequestOptions {
      headers?: Headers; //接口有变化,Headers结构{[k: string]: string;}
      content?: string | any; //接口有变化,现在主要是放纯字符串,而且成了可选

      cachePolicy?: 'noCache' | 'onlyCache' | 'ignoreCache';//请求时设置缓存策略
      onProgress?: (current: number, total: number) => void;//仅ios有用,设置进度回调
      body?: HttpsRequestObject | HttpsFormDataParam[] | File; //部分替代content的功能,用于传输json,multipart的表单数据或文件.
      params?: HttpsRequestObject;//接口有变化, HttpsRequestObject结构 {[key: string]: string | number | boolean | HttpsRequestObject | any[] | HttpsFormDataParam;}
      allowLargeResponse?: boolean;//允许返回大的返回值
      cookiesEnabled?: boolean; //默认true
  }
  ```

+ 可以`getString`,`getJSON`,`getImage`,`getFile`支持传入`HttpsRequestOptions`代替url.当传入的是`HttpsRequestOptions`时按`HttpsRequestOptions`设置的请求,也就不一定是GET方法了,同时增加了`getBinary(arg: string | HttpsRequestOptions): Promise<ArrayBuffer>`接口用于返回ArrayBuffer

+ `request`接口参数增加了一个可选参数`useLegacy`用于确保返回错误时response数据保存到`content`字段和自带的HTTP接口一致

+ `HttpsRequestOptions`中`headers`的`Content-Type`为`"multipart/form-data"`时可以`body`传数据,数据的结构为

    ```ts
    {  
        data: any;
        parameterName: string;
        fileName?: string;
        contentType?: string;
    }[]
    ```

+ `HttpsRequestOptions`中`headers`的`Content-Type`为`"application/json"`时可以`body`传数据,结构为

    ```ts
  {
    [key: string]: string | number | boolean | HttpsRequestObject | any[] | HttpsFormDataParam;
  }
    ```

+ 返回值的`HttpContent`接口形式有变化

```ts
interface HttpsContent {
    contentLength: number;
    toArrayBuffer(): ArrayBuffer; ; //变成了同步接口
    toArrayBufferAsync(): Promise<ArrayBuffer>;

    toString(): string; //变成了同步接口
    toStringAsync(): Promise<string>; 
    toJSON(): T;; //变成了同步接口
    toJSONAsync(): Promise<T>;
    toImage(): Promise<ImageSource>;
    toFile(destinationFilePath: string): Promise<File>;
}
```

### sse支持

目前并没有能用的sse库,有个库[triniwiz/nativescript-sse](https://github.com/triniwiz/nativescript-sse)可以参考,但亲测无法使用.

## websocket

websocket客户端是浏览器环境下自带的对象,[@valor/nativescript-websockets](https://github.com/valor-software/nativescript-plugins/blob/master/packages/nativescript-websockets/README.md)在nativescript环境下也构造了和浏览器环境下一样的websocket接口.用起来很简单,`ns plugin add @valor/nativescript-websockets`安装好后在入口文件`app.ts`中使用`import '@valor/nativescript-websockets'`即可.之后在任意位置就可以直接使用`Websocket`类了

```ts
...
const ws = new WebSocket("ws://10.0.2.2:3000")
ws.onclose = (ev) => {
    console.log(`disconnected type: ${ev.type} message: ${ev.message}`);
}
ws.onmessage = (message_event) => console.log(`get message ${Object.keys(message_event)}`)
ws.onopen = (ev) => { console.log(`ws opened`) }

while (ws.readyState !== WebSocket.OPEN) {
    delay(1000)
}
console.log("can send")
ws.send('helloworld')
...
```








## webrtc


https://github.com/nativescript-community/ui-webview?tab=readme-ov-file#nativescript-webview-rtc

## mqtt

https://github.com/edusperoni/nativescript-plugins/blob/main/packages/nativescript-mqtt/README.md