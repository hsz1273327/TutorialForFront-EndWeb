# 网络连接

现在的手机应用几乎都会用到网络,基本上用途有

+ 从远端服务器上拉取内容
+ 从远端服务器上接收消息
+ 将本地数据上传回远端服务器

和在浏览器中一样,移动端的网络连接是不安全不稳定的外网环境,因此通常它也和浏览器中使用相同的网络协议:

+ http协议,通常是RESTful接口,用于执行请求响应模式的短连接,用sse技术,实现从远端服务器上接收消息的功能避免轮询
+ websocket协议,实现客户端与服务端的双工通讯
+ webrtc协议,实现p2p网络

同时由于手机也算是嵌入式设备,一些时候也会使用`MQTT`协议订阅消息.

## Http

Http是最常用的网络传输协议,移动端自然也用的最多.http协议的优势是适用范围广技术成熟,而且请求响应模式也最易调试.

### 原生实现

[nativescript官方核心库中有现成的客户端实现](https://docs.nativescript.org/core/http).这个接口实现的很简单,没有任何性能优化,也没有额外功能,当然正常使用也够.

```ts
async function getUsers() {
    try {
        let resp: UserInfo[] = await Http.getJSON(url)
        users.value = resp.map((x) => x.login)
    } catch (e) {
        console.log(`getUsers get error ${e}`)
    }
}
```

`Http`包提供了下面几个简便方法用于执行http的GET请求

| 接口                                                                    | 说明                                                                                                           |
| ----------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `Http.getString(url: string): Promise<string>`                          | `GET`方法请求,返回值body解析为string类型后异步返回                                                             |
| `Http.getJSON<T>(url: string): Promise<T>`                              | `GET`方法请求,返回值body用`JSON.parse`解析后异步返回,泛型T是解析后json对象的类型                               |
| `Http.getImage(url: string): Promise<ImageSource>`                      | `GET`方法请求,返回值body解析为[ImageSource对象](https://docs.nativescript.org/api/class/ImageSource)后异步返回 |
| `Http.getFile(url: string, destinationFilePath: string): Promise<File>` | `GET`方法请求,返回值body写入到指定路径`destinationFilePath`中,并异步的返回这个路径的文件对象                   |

如果需要相对复杂的请求,比如`POST`请求,带header的请求等就需要使用接口`Http.request(options: HttpRequestOptions): Promise<HttpResponse>`.

其中`HttpRequestOptions`接口形式为

```ts
interface HttpRequestOptions {
  content: string | FormData | ArrayBuffer;
  dontFollowRedirects: boolean;
  headers: any;
  method: string;
  timeout: number;
  url: string;
}
```

`HttpResponse`接口形式为

```ts
interface HttpResponse {
  content: HttpContent;
  headers: Headers;
  statusCode: number;
}
```

而`HttpContent`接口形式为

```ts
interface HttpContent {
  raw: any;
  toArrayBuffer: () => ArrayBuffer;
  toFile: (destinationFilePath?: string) => File;
  toImage: () => Promise<ImageSource>;
  toJSON: (encoding?: HttpResponseEncoding) => any;
  toString: (encoding?: HttpResponseEncoding) => string;
}
```

原生的http客户端接口可谓相当简陋,没有连接池,也没有表单格式解析,但也胜在简单,如果仅用于请求资源或者调用RESTful接口这些也够用了.

### 后台Http推送

官方插件库提供了[background-http](https://docs.nativescript.org/plugins/background-http)库.这个库就是将重负载的请求挂到一个子线程中去执行.这在简单应用中相当方便,但如果你的应用本身会用到多线程的Worker,那我建议还是统一放到worker中处理比较好.
但要使用它我们需要先在入口初始化

```ts
import { init } from '@nativescript/background-http'
init()
```

之后就是创建一个会话在调用会话接口上传了.

// upload configuration
var bghttp = require('@nativescript/background-http');

var session = bghttp.session('image-upload');
var request = {
    url: url,
    method: 'POST',
    headers: {
        'Content-Type': 'application/octet-stream',
    },
    description: 'Uploading ' + name,
};






https://github.com/nativescript-community/https

https://github.com/triniwiz/nativescript-sse

## websocket

https://github.com/valor-software/nativescript-plugins/blob/master/packages/nativescript-websockets/README.md

## webrtc

https://github.com/triniwiz/nativescript-webrtc
https://github.com/nativescript-community/ui-webview?tab=readme-ov-file#nativescript-webview-rtc
## mqtt

https://github.com/edusperoni/nativescript-plugins/blob/main/packages/nativescript-mqtt/README.md