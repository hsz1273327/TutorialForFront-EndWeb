# 本地数据存储

一个应用总会需要数据,产生数据,而手机作为一个个人终端,自然也就需要有数据的本地存取功能.

nativescript中数据存储常用的有两种方式

1. 利用文件系统
2. 利用数据存储接口

当然着两种方式本质上都是利用文件系统,毕竟数据存储接口也是建立在文件系统之上的,只是额外多了一层抽象.

## 移动端本地数据的存储

通常一个合规的应用应该相对于其他应用在数据上是独立的,即自己仅保管和访问自己的数据.这也就限制了应用可以访问的本地空间范围.当然了android应用很多就很流氓,他们会去扫别的应用的数据,这种操作至少是不提倡的,因此这边也就不会介绍了.

在nativescript中根据平台的架构不同为不同平台提供了不同的可访问空间,他们都使用[`@nativescript/core`中的文件系统接口](https://docs.nativescript.org/core/file-system#filesystem-api)进行访问.

这其中又分为3个主要接口:

+ [knownFolders](https://docs.nativescript.org/api/namespace/knownFolders)和[Folder](https://docs.nativescript.org/api/class/Folder),提供上面提到的本地空间的文件夹和对应操作
+ [File](https://docs.nativescript.org/api/class/File),提供文件读写操作
+ [path](https://docs.nativescript.org/api/namespace/path),提供路径编辑操作

其中`Folder`和`File`是基类`FileSystemEntity`的子类

### 已知可访问位置

已知可访问位置都保存在`knownFolders`下,它们是比较推荐我们开发中使用的本地路径目录.下面是各平台的已知可访问位置:

| 项目                 | 说明                                                 | 接口                              | android | ios  |
| -------------------- | ---------------------------------------------------- | --------------------------------- | ------- | ---- |
| 应用的本地根路径     | 当前应用的根目录,项目私有                            | `knownFolders.currentApp()`       | 支持    | 支持 |
| 应用的文档文件夹路径 | 当前应用的文档路径,项目私有                          | `knownFolders.documents()`        | 支持    | 支持 |
| 应用的临时文件夹路径 | 当前应用的临时文件夹路径,项目私有                    | `knownFolders.temp()`             | 支持    | 支持 |
| 应用的桌面文件夹     | `NSDesktopDirectory`文件夹.不存在调用后会被创建      | `knownFolders.ios.desktop()`      | 不支持  | 支持 |
| 应用的开发者文件夹   | `NSDeveloperDirectory`文件夹.不存在调用后会被创建    | `knownFolders.ios.developer()`    | 不支持  | 支持 |
| 应用的下载文件夹     | `NSDownloadsDirectory`文件夹.不存在调用后会被创建    | `knownFolders.ios.downloads()`    | 不支持  | 支持 |
| 应用的链接文件夹     | `NSLibraryDirectory`文件夹.不存在调用后会被创建      | `knownFolders.ios.library()`      | 不支持  | 支持 |
| 应用的电影文件夹     | `NSMoviesDirectory`文件夹.不存在调用后会被创建       | `knownFolders.ios.movies()`       | 不支持  | 支持 |
| 应用的音乐文件夹     | `NSMusicDirectory`文件夹.不存在调用后会被创建        | `knownFolders.ios.music()`        | 不支持  | 支持 |
| 应用的图片文件夹     | `NSPicturesDirectory`文件夹.不存在调用后会被创建     | `knownFolders.ios.pictures()`     | 不支持  | 支持 |
| 应用的共享文件夹     | `NSSharedPublicDirectory`文件夹.不存在调用后会被创建 | `knownFolders.ios.sharedPublic()` | 不支持  | 支持 |

我们可以用`folder.isKnown`来判定一个文件夹是否是已知可访问位置.

### 路径操作

android,ios和普通类unix操作系统使用同样的路径系统,`path`则是处理路径的模块.这个接口比较简单,主要也就是`path.join(oldpath,ext)`这个接口.

而`File`和`Folder`的实例都可以调用属性`.path`获取到对应对象的所在路径.

```ts
import {knownFolders,path} from '@nativescript/core'
path.join(knownFolders.currentApp().path, "data/flick.json")
```

### 文件文件夹操作

不多赘述,无非就是创建删除等操作,下表给出接口(小写为实例方法,大写为类方法)

| 项目           | File                                                                     | Folder                                                                     |
| -------------- | ------------------------------------------------------------------------ | -------------------------------------------------------------------------- |
| 获取或创建     | `File.frompath(string) => File`                                          | `Folder.frompath(string) => Folder`                                        |
| 判断是否存在   | `File.exists(path: string) => boolean`                                   | `Folder.exists(path: string) => boolean`                                   |
| 上次修改时间   | `file.lastModified`:Date                                                 | `folder.lastModified`:Date                                                 |
| 名字           | `file.name`:string                                                       | `folder.name`:string                                                       |
| 父级           | `file.parent`:Folder                                                     | `folder.parent`:Folder                                                     |
| 路径           | `file.path`:string                                                       | `folder.path`:string                                                       |
| 删除操作       | `file.remove() => Promise<any>`                                          | `folder.remove() => Promise<any>`                                          |
| 同步删除操作   | `file.removeSync(onError?: (error: any) => any) => void`                 | `folder.removeSync(onError?: (error: any) => any) => void`                 |
| 重命名操作     | `file.rename(newName: string) => Promise<any>`                           | `folder.rename(newName: string) => Promise<any>`                           |
| 同步重命名操作 | `file.renameSync(newName: string,onError?: (error: any) => any) => void` | `folder.renameSync(newName: string,onError?: (error: any) => any) => void` |

#### 文件夹操作

| 项目                                                        | 接口                                                                          |
| ----------------------------------------------------------- | ----------------------------------------------------------------------------- |
| 检查下一级是否包含对应名称的文件或文件夹                    | `folder.contains(name: string) => boolean`                                    |
| 遍历下一级执行对应操作                                      | `folder.eachEntity(onEntity: (entity: FileSystemEntity) => boolean): any`     |
| 获取下一级全部文件或文件夹对象                              | `folder.getEntitiesSync(onError?: (error: any) => any) => FileSystemEntity[]` |
| 在文件夹下级存在指定名字的文件则获取该文件,不存在就创建     | `folder.getFile(name: string) => File`                                        |
| 在文件夹下级存在指定名字的文件夹则获取该文件夹,不存在就创建 | `folder.getFolder(name: string) => Folder`                                    |
| 清空文件夹操作                                              | `folder.clear() => Promise<any>`                                              |
| 同步清空文件夹操作                                          | `folder.clearSync(onError?: (error: any) => void) => void`                    |

#### 文件读写

| 项目                                       | 接口                                                                                           |
| ------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| 复制文件到指定路径                         | `file.copy(dest: string) => Promise<boolean>`                                                  |
| 同步的复制文件到指定路径                   | `file.copySync(dest: string, onError?: (error: any) => any)=> any`                             |
| 字节模式(`rb`)读取文件                     | `file.read(): Promise<any>`                                                                    |
| 同步的字节模式(`rb`)读取文件               | `file.readSync(onError?: (error: any) => any)=> any`                                           |
| 字符串模式(`r`)读取文件,默认utf8编码       | `file.readText(encoding?: string)=> Promise<string>`                                           |
| 同步的字符串模式(`r`)读取文件,默认utf8编码 | `file.readTextSync(onError?: (error: any) => any, encoding?: string)=> string`                 |
| 字节模式(`wb`)写入文件                     | `file.write(content: any) => Promise<void>`                                                    |
| 同步的字节模式(`wb`)写入文件               | `file.writeSync(content: any, onError?: (error: any) => any) => void`                          |
| 字符串模式(`w`)写入文件                    | `file.writeText(content: string, encoding?: string)=> Promise<any>`                            |
| 同步的字符串模式(`w`)写入文件              | `file.writeTextSync(content: string,onError?: (error: any) => any,encoding?: string)=> void`   |
| 字节模式append模式(`ab`)写入文件           | `file.append(content: any) => Promise<void>`                                                   |
| 同步的字节模式append模式(`ab`)写入文件     | `file.appendSync(content: any, onError?: (error: any) => any) => void`                         |
| 字符串模式append模式(`a`)写入文件          | `file.appendText(content: string, encoding?: string) => Promise<any>`                          |
| 同步的字符串模式append模式(`a`)写入文件    | `file.appendTextSync(content: string,onError?: (error: any) => any,encoding?: string) => void` |

## 数据存储接口

数据存储接口大致分为3类:

+ 类[Web Storage](https://blog.hszofficial.site/TutorialForFront-EndWeb/#/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90/%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8?id=web-storage)的键值对存储接口,用于比较轻量级的数据保存
+ 类[indexed-db](https://blog.hszofficial.site/TutorialForFront-EndWeb/#/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90/%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8?id=indexed-db)的文档型非关系数据库接口,用于保存相对比较大的半结构化数据
+ 类[websql](https://blog.hszofficial.site/TutorialForFront-EndWeb/#/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90/%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8?id=websqlhtml5%e6%9c%aa%e8%a2%ab%e6%94%b6%e5%bd%95)的关系数据库接口,一般用于保存结构化的表格数据


### ApplicationSettings保存键值对型数据


### CouchBase保存半结构化文档数据


### sqlite保存结构化数据


#### 使用orm做对象化映射
