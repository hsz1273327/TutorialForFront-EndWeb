{"./":{"url":"./","title":"Introduction","keywords":"","body":"Javascript攻略 Javascript是当今最流行的编程语言之一,它诞生于网络技术,也几乎局限于网络技术.这是一门比较有争议的脚本语言. 一方面它相当简陋,在es6之前身为一个脚本语言其编程体验极差, 另一方面由于google的v8引擎和基于v8的node.js解释器的出现.js从只能做前端开发的浏览器脚本语言蜕变为全平台脚本语言.这让大量的前端开发者招到了新玩具从而迅速获得了一个极为庞大的社区. 在社区扩大后也涌现了一大批优秀的框架工具.事实上JS恐怕拥有着最打的编程社区,技术的更新换代恐怕也是所有语言中最快的.喜欢新鲜事物的人自然很喜欢这种状态,但这也让JS社区成了最碎片化的社区. 甚至于js也成了我见过唯一需要\"编译\"的脚本语言. Javascript的定位 JS的定位在历史上也是起起落落.最开始单纯作为浏览器脚本语言,到后来node.js出现一度有了JS成为前后端通用语言,拳打Java脚踢C,甚至因为其解释器很小资源消耗很低的特点还有了在嵌入式系统中应用的尝试,再到近年回归理性,基本确定了其应用范围就在前端和与前端最接近的一层后端--Web Gateway层以及一些脚本小工具上. 结合JS这门语言的特点这个定位相对还是比较理性客观的,首先浏览器前端脚本是js的自留地,其他语言基本完全没有插足的余地,其次,在虚拟机和语言特性层面,得力于google给力的v8以及天生没有多线程这一特点,js代码全部都是基于回调或者协程的,因此在io并发性能高的同时内存消耗很小,这一点也是它比python更适合开发服务端的原因.但和python一样,v8无法应用多核(永远单线程).因此在高负载情况下只能通过起多个进程的方式.因此js天生不适合做核心组件的开发语言.像什么Queue,数据库这种就基本没有js的事儿了. 如果要开发这种核心组件,还是要老老实实使用go,或者C靠谱. 本文针对人群 本文主要是为已经学过python的人而写的攻略文.一方面做数据科学的需要一定前端技术做可视化,也需要一定的网络技术用于项目落地.另一方面Javascript是一个很好的参照,让我们可以更好的理解编程技术.写这篇文章的一个很大的原因是JS是很好的函数式编程的学习语言. 一方面它足够流行,这样不至于学了一点用没有,成为屠龙技(比如各种lisp方言) 另一方面他有足够的部件实现和验证函数式编程. 因此本文也针对对函数式编程有兴趣的同学. 使用ES6标准 本文直接从ES6标准开始,绕开语法晦涩的低级标准,可以更好的服务于快速原型开发和结论验证. 语法糖丰富 低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难, ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本. 接近Python的开发习惯 Python是模块化编程的语言,而Js在设计初期就没考虑模块化的问题,低版本的js在编写时模块化方面 会让被python惯坏了的人非常不喜欢,ES6使用类似python的import语句,相对容易接受. 文章结构 单说JavaScript的话是一个很简单的语言,本文大致分为几个部分 执行环境 这部分讲node的执行环境,工欲善其事必先利其器,js作为后起之秀有着相当优秀和完善的工具链,但前面也讲过了社区非常碎片化因此不少工具功能相同,这对选择困难症非常不友好 这部分讲我常用的工具链,包括: node环境和包管理工具 api自动生成工具 测试工具 代码风格规范 基本语法 这部分会参照python介绍语法和一些惯用法 函数式编程 之所以讲JS一个很大的原因是它既热门又比python更加适合使用函数式编程 常见应用 最后是应用环节,本文会介绍常见的js框架用于解决一些实际问题,比如前端编程,chrome插件编写等.这个部分会有示例代码,但不定期更新 本文使用jupyter notebook结合jp-babel编写,gitbook解析编译生成网页. 本文主要参考自阮一峰大大的书和SICP,加上一些个人理解,本人才疏学浅如有错误望各位读者指正. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/":{"url":"执行环境/","title":"执行环境","keywords":"","body":"Javascript的执行环境 javascript有一个天然的执行环境--浏览器.但是更多的时候我们使用node.js作为执行环境.js的标准在各个平台实现往往并不同步. 为了保证代码可以在更广的平台上执行,通常我们是先用高级语法写源代码,再通过工具将源代码编译为低级语法的执行代码.而最常见的编译工具就是babel了. 当然了Js也有几个很有人气的方言,coffeescript,以及typescript,他们都各有特点,但本文不会介绍. 本章内容: Javascript执行环境 代码风格 api文档自动生成 代码测试工具 log工具 性能基准测试 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/Javascript执行环境.html":{"url":"执行环境/Javascript执行环境.html","title":"Javascript执行环境","keywords":"","body":"Javascript环境搭建 由于历史原因Javascript的运行环境有两种: 浏览器 浏览器环境复杂,一般通过babel转码的形式间接地使用ES6特性 node.js(v8虚拟机) v8引擎原生的支持一些ES6特性,但在有的时候也不得不通过使用Babel转码来实现一些特定的语法.使用node.js的原生ES6支持需要在使用node命令时后面带上--harmony参数,方便起见可以在环境变量中直接使用alias node=node --harmony语句,这样就可以在repl中使用ES6支持了,但如果要执行脚本,必须开启js的严格模式,也就是在每个脚本头上写上\"use strict\" 他们之间多数时候语法层面是通用的. npm npm是node.js的官方包管理工具,它可以用于全局环境的搭建,也可以用于单独项目的环境搭建,全局环境可以理解为python中的pip工具的功能,而单独项目管理可以理解为python中的虚拟环境类似概念,只是一个虚拟环境对应一个项目 npm的工具的操作有: 通用操作 npm search |查找包 npm view dependencies|查看包的依赖关系 npm view repository.url|查看包的源文件地址 npm view engines|查看包所依赖的Node的版本 npm root| 查看项目路径,可以加-g表示全局的package存储位置 npm install |安装包,可以加-g表示全局,--save表示计入配置文件的Dependencies,--save-dev表示计入配置文件的devDependencies npm uninstall |卸载包,可以加-g表示全局 npm update |更新包,可以加-g表示全局 npm outdated |检查过时的包,可以加-g表示全局 npm list| 查看当前目录下已安装的node包,注意事项：Node模块搜索是从代码执行的当前目录开始的，搜索结果取决于当前使用的目录中,node_modules下的内容。npm list parseable=true可以目录的形式来展现当前安装的所有node包,可以加-g表示全局 全局环境设置专用操作 操作 说明 npm adduser 创建npm的用户 npm config ls 查看npm在机器上的设置 单独项目专用操作 操作 说明 npm init 初始化一个项目,会生成一个package.json作为配置文件来管理该项目 package.json配置文件 package.json是一个node.js项目的配置文件,它大约是这样的: { \"name\": \"ex3\", //项目名 \"version\": \"1.0.0\", //版本 \"description\": \"\", //描述 \"main\": \"index.js\", //入口文件 \"scripts\": { //可运行的脚本 \"docs\": \"esdoc -c esdoc.json\", \"start\": \"gulp\", \"lint\": \"gulp lint\", \"test\":\"./node_modules/.bin/babel-node ./node_modules/.bin/isparta cover --report html ./node_modules/.bin/_mocha \" }, \"author\": \"hsz\",//作者 \"license\": \"ISC\",//版权声明 \"devDependencies\": {//开发用的依赖 \"babel-cli\": \"^6.6.5\", \"babel-core\": \"^6.7.4\", \"babel-eslint\": \"^6.0.2\", \"babel-loader\": \"^6.2.4\", \"babel-polyfill\": \"^6.7.4\", \"babel-preset-es2015\": \"^6.6.0\", \"babel-register\": \"^6.7.2\", \"chai\": \"^3.5.0\", \"esdoc\": \"^0.4.6\", \"eslint\": \"^2.7.0\", \"gulp\": \"^3.9.1\", \"gulp-clean\": \"^0.3.2\", \"gulp-eslint\": \"^2.0.0\", \"gulp-minify-html\": \"^1.0.6\", \"gulp-notify\": \"^2.2.0\", \"gulp-rename\": \"^1.2.2\", \"gulp-uglify\": \"^1.5.3\", \"gulp-util\": \"^3.0.7\", \"isparta\": \"^4.0.0\", \"mocha\": \"^2.4.5\", \"mochawesome\": \"^1.3.2\", \"webpack\": \"^1.12.14\" } } 有些工具他们可以使用package.json设置自己,有些不行. 依赖的版本声明 使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。 语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 如果只是修复bug，需要更新Z位。 如果是新增了功能，但是向下兼容，需要更新Y位。 如果有大变动，向下不兼容，需要更新X位。 版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如\"argv\": \"0.0.x\"表示依赖于0.0.x系列的最新版argv。 版本控制同样支持通配符 *: 任意版本 1.1.0: 指定版本 ~1.1.0: >=1.1.0 && ^1.1.0: >=1.1.0 && 其中 ~ 和 ^ 两个前缀让人比较迷惑，简单的来说： ~ 前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本。 ^ 前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会 匹配到 y 和 z 都是最新的版本。 特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z。 墙内换源 npm虽好,但无奈天朝有墙,我们只能用国内镜像作为源了 在你的home目录下,编辑~/.npmrc, registry =https://registry.npm.taobao.org index.js 习惯上一个项目的入口文件会被命名为index.js.这个没有强制但基本大家都这么干. babel环境 babel是js的语法编译器,它可以把高级语法的js代码编译为低级语法的js代码以适应各种环境.babel高度模块化,以至于让人觉得有点过度设计.其安装方法是 npm install --save-dev babel-cli npm install --save-dev babel-preset-env npm install --save-dev babel-register npm install --save-dev babel-polyfill 通常babel环境不装在全局,这样减少依赖冲突的可能. 其中 babel-cli提供命令行工具以及一个高级语法的解释器 babel-preset-env提供最近最常见的语法包组合 babel-register提供一个代码层面的工具,让代码在es5环境下也可以使用es6语法 babel-polyfill提供新的运行时特性 安装好后我们还需要配置需要的babel语法包,可以在package.json中通过babel字段定义 {... \"babel\": { \"presets\": [ [\"env\"] ] }, ... } 而我们通常将编译和执行操作写到package.json中方便调用: {... \"scripts\":{ \"run\":\"./node_modules/.bin/babel-node index.js\", \"build\": f\"./node_modules/.bin/babel es -d lib\", }, ... } 只有使用命令npm run run 即可执行项目,npm run build即可编译项目 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/代码风格.html":{"url":"执行环境/代码风格.html","title":"代码风格","keywords":"","body":"代码风格 JS作为一门很碎片化的编程语言,它的代码规范比较繁杂,很多公司都有自己的一套规范,本人的常用风格基本继承自python,总体的要点可以概括如下: 不使用var,尽量使用const 函数全局定义,使用function,在块域中尽量不要定义函数,非要定义就使用箭头函数,匿名函数尽量用箭头函数 4格缩进,{不放新行头放旧行尾 除了箭头函数表达式外所有要用{}都使用{}包裹 能用生成器的就不用容器,以减少内存使用 尽量单独使用小写字母l，大写字母O等容易混淆的字母。 文件命名尽量使用小写和-，如add_rule.js。 方法,函数命名使用Snake Case命名法，如function add_rule() 常量(全局的const)命名使用全部大写的方式,可以使用下划线 类命名使用Pascal命名法 类方法使用小驼峰命名法. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/api文档自动生成.html":{"url":"执行环境/api文档自动生成.html","title":"api文档自动生成","keywords":"","body":"api文档自动生成 python可以使用段注释自动的生成文档,但js不行,必须借助第三方工具实现,这个工具就是esdoc 安装依然是 npm install esdoc --save-dev 之后使用我们看个例子 例1: 用esdoc生成api文档并输出html文档 js文件: /** * this is MyClass. */ export default class MyClass { /** * @param {number} param this is param. * @return {number} this is return. */ method(param){} } 看注释,使用 /** * */ 包裹的注释可以成为文档,其中使用@开头的行会被辨识为是有特殊意义的标签 所有的标签说明可以在官网找到 需要注意的是: @param {number} param this is param. 代表输入的形参属性,要有几个参数写几个,按顺序写,{number}表示类型,param是形参名 后面的是说明 写配置 esdoc支持在package.json中设置,使用字段\"esdoc\" {..., \"esdoc\": { \"destination\": \"./docs\", \"source\": \"./es\", \"includes\": [r\"\\\\.js$\"], \"excludes\": [r\"\\\\.config\\\\.js$\"], \"coverage\": true,//是否统计覆盖率 \"plugins\": [ { \"name\": \"esdoc-standard-plugin\" } ] }, ... } 使用 可以使用命令esdoc来生成一个接口的静态页面,而且默认的还会把项目下的README.md文件渲染进去作为主页 但更常见的用法是在package.json中设置scripts {..., \"scripts\":{ ... \"doc\": \"./node_modules/.bin/esdoc\", ... }, ... } 要使用只需要执行命令npm run doc即可 如果要写项目文档,光API文档肯定不够,我们可以使用sphinx来构建项目的文档配合sphinxcontrib-autojs插件来构建 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/代码测试工具.html":{"url":"执行环境/代码测试工具.html","title":"代码测试工具","keywords":"","body":"代码测试工具 Javascript语言本身可以说是个残疾人,连基本的代码测试工具都没有,我们无法像在用python时那样简单的使用assert unittest这些语言自带工具或者标准包来做代码测试,测试工具几乎都是第三方的. 错误 基本错误 js也有一套简单的错误系统和错误处理机制,但很不好用,基本的错误包括: Error 错误的基类 AssertionError 断言错误 RangeError 超出容器范围错误 ReferenceError 变量未定义错误 SyntaxError 语法错误 TypeError 类型错误 EvalError eval()函数发生的错误 URIError 浏览器中访问地址出错 通常用js的不会自己定义错误,但需要定义的话也和python一样,继承就好了 抛出错误 js使用语法 throw new Error(msg) 来抛出错误 错误捕捉 js的错误捕捉语法是: try{ block1 }catch (error){ block2 }finally{ block2 } 这个语法和python的基本一一对应 断言 js并没有断言语句,但node环境有一个简单的标准库assert,可以使用 import assert from \"assert\" assert.equal(1,0) assert.js:83 throw new AssertionError(obj); ^ AssertionError [ERR_ASSERTION]: 1 == 0 at evalmachine.:1:8 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) at emit (internal/child_process.js:812:12) at process._tickCallback (internal/process/next_tick.js:63:19) 这个工具相当简单,但多数时候也够用了. 我们可以使用chai来实现断言功能 安装依然是npm安装 npm install chai --save-dev chai有三种断言风格 Assert风格 类似python中的assert语句 var assert = chai.assert assert.typeOf(foo, 'string') assert.equal(foo, 'bar') assert.lengthOf(foo, 3) assert.property(tea, 'flavors') assert.lengthOf(tea.flavors, 3) 这种风格代码最保守,我比较习惯用,标准库就有,就可以少装一个依赖 Expect 推断方法,相对更加接近口语化,英语看来就是\"我推测xxx是ooo\"这样 var expect = chai.expect expect(foo).to.be.a('string') expect(foo).to.equal('bar') expect(foo).to.have.length(3) expect(tea).to.have.property('flavors').with.length(3) 这种风格比较中庸,好像是最受欢迎的一种 Should 最口语化得一种风格,意识是\"xxx应该是ooo\" chai.should() foo.should.be.a('string') foo.should.equal('bar') foo.should.have.length(3) tea.should.have.property('flavors').with.length(3) 这种风格不建议用,会修改原型 测试框架 做代码测试可以使用mocha来做, 安装依然是npm npm install mocha --save-dev 同时为了输出代码覆盖率,可以安装nyc 之后修改package.json的scripts字段即可 { ..., \"scripts\":{ ... \"test\": \"./node_modules/.bin/nyc --reporter=text ./node_modules/.bin/mocha --require babel-polyfill --require babel-register\" ... }, ... } 如果想要html的展示可以使用 ./node_modules/.bin/nyc --reporter=html ./node_modules/.bin/mocha --require babel-polyfill --require babel-register 使用: 写测试代码: import assert from \"assert\" describe('Array', function() { describe('#indexOf()', function () { it('should return -1 when the value is not present', function () { assert.equal(-1, [1,2,3].indexOf(5)) assert.equal(-1, [1,2,3].indexOf(0)) }) }) }) 上例中 describe(des,func)方法是一个测试的描述,一般一个describe()描述一个方法或类 it(des,func)方法则是一个测试具体的一个分支,一般一个it()描述一个方法的一种可能输入条件 mocha支持定义钩子,可以使用的钩子有: before(func)定义某操作之前的操作 after(func) 定义某操作之后的操作 beforeEach(func)定义块内每个操作之前的操作 afterEach(func) 定义块内每个操作之后的操作 mocha支持测试自定义操作 skip(des,func)跳过某测试 only(des,func)只进行某操作 要执行测试只要使用命令npm run test即可 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/log工具.html":{"url":"执行环境/log工具.html","title":"log工具","keywords":"","body":"log工具 由于js在设计之初是作为浏览器脚本的,因此还是预留了调试用的log模块console的.但它是不完备的,它无法为log设定显示等级,也无法将log输出至文件或者其他媒介.个人认为输出至其他媒介并不是log模块本身最关心的,但没法设置log的显示等级是非常不现代的.因此这边推荐全平台的log工具pino.不过本文还是只讲标准的log生成对象console 还是得吐槽下js的简陋,连log工具功能都不齐. console对象 console是指的控制台,js是单线程的,因此它的log其实和python中的print差不多,就是将文本信息输出到特定位置而已,在浏览器中就是控制台,在node.js中就是terminal的标准输入输出. log分级 实际上标准的log是有分级的,标准是4个等级: console.log('文字信息') 文字信息 console.info('提示信息') 提示信息 console.warn('警告信息') 警告信息 console.error('错误信息') 错误信息 log的格式化输出 占位符 含义 %s 符串输出 %d or %i 整数输出 %f 浮点数输出 %o 打印javascript对象，可以是整数、字符串以及JSON数据 分组输出 所谓是分组其实就是缩进.分组可以多层嵌套 使用console.group()和console.groupEnd()包裹分组内容. 还可以使用console.groupCollapsed()来代替console.group()生成折叠的分组. 这种用法有点像python中上下文的感觉. console.group('第一个组') console.log(\"1-1\") console.log(\"1-2\") console.log(\"1-3\") console.groupEnd() console.groupCollapsed('第二个组') console.log(\"2-1\") console.log(\"2-2\") console.log(\"2-3\") console.groupEnd() 第一个组 1-1 1-2 1-3 第二个组 2-1 2-2 2-3 表格输出 使用console.table()可以将传入的对象,Map或数组以表格形式输出,这个函数适合输出格式化数据 console.table({ a:1, b:2 }) ┌─────────┬────────┐ │ (index) │ Values │ ├─────────┼────────┤ │ a │ 1 │ │ b │ 2 │ └─────────┴────────┘ console.table([1,2,3,4]) ┌─────────┬────────┐ │ (index) │ Values │ ├─────────┼────────┤ │ 0 │ 1 │ │ 1 │ 2 │ │ 2 │ 3 │ │ 3 │ 4 │ └─────────┴────────┘ console.table(new Map([['one',1], ['two', 2], ['three', 3]])) ┌───────────────────┬─────────┬────────┐ │ (iteration index) │ Key │ Values │ ├───────────────────┼─────────┼────────┤ │ 0 │ 'one' │ 1 │ │ 1 │ 'two' │ 2 │ │ 2 │ 'three' │ 3 │ └───────────────────┴─────────┴────────┘ console.table(new Set([\"a\",\"b\",\"c\"])) ┌───────────────────┬────────┐ │ (iteration index) │ Values │ ├───────────────────┼────────┤ │ 0 │ 'a' │ │ 1 │ 'b' │ │ 2 │ 'c' │ └───────────────────┴────────┘ 查看对象 使用Console.dir()显示一个对象的所有属性和方法,这个就有点像python中的dir(obj) console.dir({ a:1, b:2, c:()=>1 }) { a: 1, b: 2, c: [Function: c] } *查看dom节点 console.dirxml()这个接口算是浏览器脚本时代遗留的特有接口,用于查看html/xml生成的dom节点 console.dirxml(` 蚂蚁部落一 蚂蚁部落二 蚂蚁部落三 蚂蚁部落四 `) 蚂蚁部落一 蚂蚁部落二 蚂蚁部落三 蚂蚁部落四 条件输出 console.assert(exp,msg)这个接口在一定程度上式assert的替代 console.assert(true, \"你永远看不见我\") console.assert(false, \"你永远看不见我\") Assertion failed: 你永远看不见我 计次输出 使用console.count(tag)输出内容和被调用的次数可以使用console.countReset(tag)重置被调用的次数 (()=> { for(let i = 0; i 运行次数：: 1 运行次数：: 2 运行次数：: 3 运行次数1：: 1 追踪调用堆栈 使用Console.trace()来追踪函数被调用的过程,在复杂项目时调用过程非常多,用这个命令可以查看到栈上的信息 const add=(a, b)=> { console.trace(\"Add function\") return a + b } const add3=(a, b)=> { return add2(a, b) } const add2=(a, b)=> { return add1(a, b) } const add1=(a, b) =>{ return add(a, b) } let x = add3(1, 1) [object Object] at add (evalmachine.:2:13) at add1 (evalmachine.:15:12) at add2 (evalmachine.:11:12) at add3 (evalmachine.:7:12) at evalmachine.:18:9 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) 计时功能 使用console.time(tag)和console.timeEnd(tag)包裹需要计时的代码片段,输出运行这段代码的运行时间(毫秒记).一组time上下文使用tag参数做标识,一个tag就是一个计时器,最多同时运行10000个计时器.在其中可以插入console.timeLog(tag, value) console.time(\"Chrome中循环1000次的时间\") for(var i = 0; i Chrome中循环1000次的时间: 0.016ms 0 Chrome中循环1000次的时间: 0.159ms 1 Chrome中循环1000次的时间: 0.223ms 2 Chrome中循环1000次的时间: 0.278ms 3 Chrome中循环1000次的时间: 0.338ms 4 Chrome中循环1000次的时间: 0.389ms 5 Chrome中循环1000次的时间: 0.505ms 6 Chrome中循环1000次的时间: 0.579ms 7 Chrome中循环1000次的时间: 0.638ms 8 Chrome中循环1000次的时间: 0.694ms 9 Chrome中循环1000次的时间: 0.750ms 性能分析 使用console.profile()和console.profileEnd()进行性能分析,查看代码各部分运行消耗的时间.这个方法在node中需要使用--inspect标签打开调试模式才可以使用 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"执行环境/性能基准测试.html":{"url":"执行环境/性能基准测试.html","title":"性能基准测试","keywords":"","body":"性能基准测试 在大型项目中我们有可能会希望通过对比来查看某个功能的不同实现会有怎样不同的表现,这时候就可以使用Benchmark.js 安装: npm install --save-dev benchmark 使用: 例: 我们知道js中字符串相连是有两种方式的: \"asdfg\"+\"hjkl\" 'asdfghjkl' \"asdfg\".concat(\"hjkl\") 'asdfghjkl' 让我么来测测哪个快 待测代码 strconcat.js: export function str_plus(str1,str2) { return str1+str2 } export function str_concat(str1,str2) { return str1.concat(str2) } 测试代码strconcat.benchmark.js: import {str_plus,str_concat} from \"./strconcat\" import Benchmark from 'benchmark' let str1 = \"asdfg\" let str2 = \"hjkl\" let suite = new Benchmark.Suite // 添加测试 suite .add('+', function() { str_plus(str1,str2) }) .add('concat', function() { str_concat(str1,str2) }) // 每个测试跑完后，输出信息 .on('cycle', function(event) { console.log(String(event.target)) }) .on('complete', function() { console.log('Fastest is ' + this.filter('fastest').map('name')) }) // 这里的 async 不是 mocha 测试那个 async 的意思，这个选项与它的时间计算有关，默认勾上就好了。 .run({ 'async': true }) 之后再直接用babel-node运行即可 在交互环境中测试 我们同样可以在babel-node或者我们的jupyter notebook中做测试 function str_plus(str1,str2) { return str1+str2 } function str_concat(str1,str2) { return str1.concat(str2) } import Benchmark from 'benchmark' let str1 = \"asdfg\" let str2 = \"hjkl\" var suite = new Benchmark.Suite try{ // 添加测试 suite .add('+', function() { str_plus(str1,str2) }) .add('concat', function() { str_concat(str1,str2) }) // 每个测试跑完后，输出信息 .on('cycle', function(event) { console.log(String(event.target)) }) .on('complete', function() { console.log('Fastest is ' + this.filter('fastest').map('name')) }) // 这里的 async 不是 mocha 测试那个 async 的意思，这个选项与它的时间计算有关，默认勾上就好了。 .run({ 'async': true }) } catch(err) { console.log(err) } Suite { '0': Benchmark { name: '+', options: { async: false, defer: false, delay: 0.005, id: undefined, initCount: 1, maxTime: 5, minSamples: 5, minTime: 0, name: undefined, onAbort: undefined, onComplete: undefined, onCycle: undefined, onError: undefined, onReset: undefined, onStart: undefined }, async: false, defer: false, delay: 0.005, initCount: 1, maxTime: 5, minSamples: 5, minTime: 0, id: 1, fn: [Function], stats: { moe: 0, rme: 0, sem: 0, deviation: 0, mean: 0, sample: [], variance: 0 }, times: { cycle: 0, elapsed: 0, period: 0, timeStamp: 0 }, _timerId: Timeout { _called: false, _idleTimeout: 5, _idlePrev: [TimersList], _idleNext: [TimersList], _idleStart: 11585, _onTimeout: [Function], _timerArgs: undefined, _repeat: null, _destroyed: false, [Symbol(unrefed)]: false, [Symbol(asyncId)]: 29, [Symbol(triggerId)]: 26 } }, '1': Benchmark { name: 'concat', options: { async: false, defer: false, delay: 0.005, id: undefined, initCount: 1, maxTime: 5, minSamples: 5, minTime: 0, name: undefined, onAbort: undefined, onComplete: undefined, onCycle: undefined, onError: undefined, onReset: undefined, onStart: undefined }, async: false, defer: false, delay: 0.005, initCount: 1, maxTime: 5, minSamples: 5, minTime: 0, id: 2, fn: [Function], stats: { moe: 0, rme: 0, sem: 0, deviation: 0, mean: 0, sample: [], variance: 0 }, times: { cycle: 0, elapsed: 0, period: 0, timeStamp: 0 } }, name: undefined, options: { name: undefined }, length: 2, events: { cycle: [ [Function] ], complete: [ [Function] ] }, running: true } + x 66,246,030 ops/sec ±2.41% (83 runs sampled) concat x 70,009,103 ops/sec ±1.13% (90 runs sampled) Fastest is concat 可见其实+运算符还是蛮好,而concat运行更快 内存使用情况 一般的后台开发语言中,内存使用的大小几乎没有限制.但是,V8最初是为浏览器打造的,在V8下64位系统可以操纵1.4GB内存,32位系统可以操纵0.7GB内存.在这样的限制下,node几乎不能直接操纵大内存. node的process对象提供了对内存使用的快照接口process.memoryUsage() process.memoryUsage() { rss: 31166464, heapTotal: 18690048, heapUsed: 13056152, external: 8859 } 其中 rss:resident set size，进程的常驻内存,是给这个进程分配了多少物理内存(占总分配内存的一部分) 这些物理内存中包含堆，栈，和代码段 heapTotal: 已经申请到的堆内存 heapUsed: 当前堆内存使用量 external: 代表V8管理的绑定到Javascript的C++对象的内存使用情况. 几乎和C语言一样,对象,字符串,闭包等存于堆内存.变量存于栈内存.实际的JavaScript源代码存于代码段内存. process.memoryUsage() { rss: 31199232, heapTotal: 18690048, heapUsed: 13089784, external: 8895 } 因此要看一段代码用了多少内存,开头结尾处计算rss+heapUsed的差即可 let before = process.memoryUsage() let before_used = before.rss+before.heapUsed for (let i=0;i 200 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/":{"url":"基础语法/","title":"基础语法","keywords":"","body":"Javascript基础语法 ES6已经在稍微现代点的浏览器和node.js中实装,本文所讲的语法内容基本以ES6为基准,包括: 基本语法和代码结构 变量,值与运算 从运算符到函数 迭代器和生成器 基本容器 异步编程 面向对象编程 模块化编程 特殊对象和特殊接口 如果想要更加细节的js语法知识,可以看MDN上的文档 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/基本语法和代码结构.html":{"url":"基础语法/基本语法和代码结构.html","title":"基本语法和代码结构","keywords":"","body":"基本语法和代码结构 有一种说法,让一个程序员用一门新语言,只要告诉他怎么写if语句和for语句就行,当然这是一种夸张的说法,但基本语法和代码结构确实决定了代码的整体框架. 注释 Js沿用C和Java的注释风格, 单行注释 //这是单行注释 块注释 /* 这是块注释 */ 为了更好的输出文档,建议块注释使用EsDoc的规范写 /** *这是块注释 */ 代码结构 Js的代码结构类似C和java 使用;或者换行表示语句结束 使用{}包裹代码块 关键字 break |循环跳出 do |do..while instanceof|识别类型 typeof|识别类型(历史遗留) case|switch...case...default else|if...else new |创建新对象 var|创建变量(历史遗留) catch|try...catch...finally return |function的返回值 void|无论void后的表达式是什么，void操作符都会返回undefined. continue|进入下次循环 for |for循环 switch|switch...case...default while|while和do...while循环 debugger|保留字 function|定义函数和方法 this|对象自身 with|with语句(历史遗留) default|switch...case...default if|if...else语句 throw|抛出一个异常 delete|消除对象 in |for ...in try |try...catch...finally abstract|保留 arguments| 函数中存放传入参数的对象 boolean|布尔值 byte|字节 char|字符(保留字) class| 类 const|常数 double|双精度浮点数 (保留字) enum|保留 eval|字符串做代码运行 export|模块对外暴露 extends|继承 false|布尔值中的假 final |保留字 float|浮点数(保留字) goto |跳转 implements |保留字 import |模块导入 int |整型数(保留字) interface|保留字 let |定义变量 long |长整型(保留字) native |保留字 null|空对象 package |保留字 private |保留字 protected|保留字 public |保留字 short |短整型(保留字) static |静态声明 super |父类实例化 synchronized|保留字 throws |保留字 transient |保留字 true|真值 volatile|保留字 yield|生成器用关键字 function*|生成器用关键字 async function|async关键字 await |async关键字 控制结构 一般来说控制语句就是条件判断,循环,分支和try语句了,try语句在第一部分已经有介绍,这边不再复述 判断 JavaScript使用形如: if () { ... } else if () { ... } else{ ... } 这样的条件分支来实现判断语句 例计算一个年份是否是闰年(能被4或者400整除,但被100整除不算) function Leap(year) { if (year%100 !== 0 && year%4 ===0 ){ return true } else if(year%400 === 0){ return true } else { return false } } Leap(2421) false 循环 for循环 for循环形如: for (临时变量; 判断条件;改变临时变量) { ... } for ... of 循环 这个是for循环最常用最好用的方法了,在之前的数据结构部分已经有相对详细的讲解了 形如: for (temp of 容器){ ... } 注意:js中也有for in循环,然而并不好用,所以我就不写了.... while循环 for循环在已知循环的初始和结束条件时非常有用。而while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。 while循环形如: while (exp) { ... } do ... while循环 do ... while循环和while类似,只是它是先执行再判断. do ... while形如: do { ... } while (exp) break和continu 和c类似,break和continu还是一样的语义,分别代表跳出循环和跳过当次循环 分支switch switch语句依然沿用c风格,形如: switch (exp){ case value: block break case value: block break default: block } 千万不要忘了break Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/变量与值与对象.html":{"url":"基础语法/变量与值与对象.html","title":"变量与值与对象","keywords":"","body":"变量,值与标准数据类型 Js这门语言虽然是弱类型,但其语法设计师大量借鉴了java,变量是要申明的.这可能是python用户上来第一个不适应的地方. python中第一次为某个变量赋值相当于顺道就申明了这个变量.这种语法很简练,但其表达能力并不优秀,因为变量也是可以有类型的,像C/C++中可以定义常量,scala中可以定义可变量不可变量.python语法中自动忽略了这些,当然这种简化让可读性和易用性上升了,但也让性能优化变得更加困难了. 变量的作用域 js中作用域分为 块作用域--{}包裹,或者是逻辑表达式中定义的变量就属于这个 函数作用域 上层函数作用域(闭包) 全局作用域 类似python,js的变量查找规则也是由里到外一层一层查找的 例子: let aa = \"a\" function func(){ let b = \"b\" return function(){ let c = \"c\" { let d = \"d\" } let d = \"e\" return aa+b+c+d } } func()() 'abce' 变量声明 js中有3种声明关键字 var 这是以前js的遗留,它没有块级概念,在全局定义就是全局变量,在function中定义就是局部变量,但在块内它并不会在快运行完后消失,因此最好别用 let 取代var的声明关键字,有块概念,建议都用它,你必须在用到它之前先声明,这也是和var不同的地方 const 常量和代表这个变量指向的地址/指针/引用不会改变,其和let的作用域特点相同.需要注意的是js中的容器本身就是一个引用,const只能保证它保存的这个引用地址不变,并不能保证这个引用地址中保存的容器中各位内容不变,因此可以说常量是针对标准值类型的常量,对容器只能说部分有效,这点和python中的函数参数传递行为差不多. 变量的特殊操作 解构赋值 解构赋值是指将数据结构中的内容提取出来的一个操作,目前可以结构的有数组(Array)和对象(Object),解构时可以使用...rest符号代表剩余的部分,而这样的话rest变量就会获得剩下的内容组成的数组 let [a,b,c] = [1,2,4] console.log(`${a},${b},${c}`) 1,2,4 let [x,...y]=[1,2,3,4] console.log(`${x},${y}`) 1,2,3,4 对象的解构与数组有一个重要的不同.数组的元素是按次序排列的,变量的取值由它的位置决定; 而对象的属性没有次序,变量必须与属性同名,才能取到正确的值.如果等号左边的变量的次序与等号右边同名属性的次序不一致,这对取值完全没有影响;但如果左边的属性和右边的不一致,那么取出来就是undefined.也就是说对象的解构赋值的内部机制是先找到同名属性,然后再赋给对应的变量.其标准形式为: let {aa:x_1,bb:y_1,cc:z_1}={aa:1,bb:2,cc:3} console.log(`${x_1},${y_1},${z_1}`) 1,2,3 其中aa,bb,cc这种属性叫做模式匹配,也可以使用以下简略写法: let {aaa,bbb,ccc}={aaa:1,bbb:2,ccc:3} console.log(`${aaa},${bbb},${ccc}`) 1,2,3 值类型 Js内置类型大概就这么7种: Number 数值型 String 字符串型 Bool 布尔型 null 空值类型 undefined 未定义类型 object 对象类型 Symbol 标志位类型 我们可以用typeof函数来辨识一个值的类型,其返回值的取值范围就是上面7种.function也是typeof的一种可能的返回值.然而function是object. typeof(()=>{ return 1 }) 'function' ()=>{return 1} instanceof Object true Number 123 // 整数123 0.456 // 浮点数0.456 1.2345e3// 科学计数法表示1.2345x1000，等同于1234.5 -99// 负数 NaN // NaN表示Not a Number，当无法计算结果时用NaN表示,NaN这个特殊的Number与所有其他值都不相等，包括它自己 Infinity // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 0b111110111 //二进制数 0o767 //八进制数 0xfa223 //16进制数 1024547 Number类型的特殊处理: 计算精度 0.1+0.2 == 0.3 false 注意,这是因为我们的浮点数并没有设定精度,大家肯定都觉得本该是true呀,其实本来就该是错的(IEEE 754),浮点数必须有精度.一个解决方案是全部化成整数在算,另一个就是使用极小常量Number.EPSILON确定精度. 引入一个这么小的量的目的,在于为浮点数计算,设置一个误差范围.我们知道浮点数计算是不精确的.但是如果这个误差能够小于Number.EPSILON,我们就可以认为得到了正确结果.因此,Number.EPSILON的实质是一个可以接受的误差范围. (0.1 + 0.2 - 0.3).toFixed(20) '0.00000000000000005551' (0.1 + 0.2 - 0.3) true 整形数 用来判断一个值是否为整数.需要注意的是,在JavaScript内部,整数和浮点数是同样的储存方法,所以3和3.0被视为同一个值.要判断一个数是整数还是浮点数,那就得使用Number.isInteger()这个接口 Number.isInteger(1) true Number.isInteger(1.0) true Number.isInteger(1.1) false 整形数的另一个问题是大数精度,JavaScript能够准确表示的整数范围在-2^53到2^53之间(不含两个端点),超过这个范围就无法精确表示这个值,我们称这个范围内的书为安全数. 要判断一个整数是不是安全数可以使用接口Number.isSafeInteger() Number.MAX_SAFE_INTEGER 9007199254740991 Number.MIN_SAFE_INTEGER -9007199254740991 Number.isSafeInteger(2**53) false NaN 它表示不是一个数...但他自己确是数值类型,而且NaN不等于NaN...很矛盾哇 typeof(NaN) 'number' 0 == NaN false parseInt(\"asdf\") NaN NaN === NaN false 所以如果你要判断一个变量是不是NaN你得使用函数: isNaN(\"xxx\") isNaN(\"xxx\") true 如果你对一个变量是什么内容一无所知,那使用isNaN是不合理的,因为它没准就不是一个数,更不用说它是nan了,这种情况应该使用Number.isNaN()它只对数值有效 Number.isNaN(\"xxx\") false Infinity Infinity代表无限大,和NaN类似,要检查一个值是否非无穷可以使用函数isFinite() isFinite(Infinity) false isFinite(15) true 但这个接口的问题也和isNaN一样,对非数值型的会有歧义,可以使用Number.isFinite() isFinite(\"12\") true Number.isFinite(\"12\") false 数值运算和Math对象 js默认提供了多种通用的运算符用来做数值运算 +|加法 -|减法 *|乘法 /|除法 %|求余 **|乘方 并且提供了赋值运算: =|赋值 +=|自己加上后一个数 -=|自己减去后一个数 *=|自己乘后一个数 /=|自己除后一个数 %=|自己与后一个数求余 Math对象类似python的标准库math,提供了一些不太常用的基本数值计算方法和通用的常数 常数: E |返回算术常量 e，即自然对数的底数(约等于2.718) LN2 |返回 2 的自然对数(约等于0.693) LN10 |返回 10 的自然对数(约等于2.302) LOG2E |返回以 2 为底的 e 的对数(约等于 1.414) LOG10E|返回以 10 为底的 e 的对数(约等于0.434) PI |返回圆周率(约等于3.14159) SQRT1_2 |返回返回 2 的平方根的倒数(约等于 0.707) SQRT2 |返回 2 的平方根(约等于 1.414) 方法: random()| 返回 0 ~ 1 之间的随机数 fround(x)|方法返回一个数的单精度浮点数形式 round(x) |把数四舍五入为最接近的整数 trunc(x)|方法用于去除一个数的小数部分,返回整数部分 abs(x) |返回数的绝对值. sign(x)|方法用来判断一个数到底是正数、负数、还是零,它会返回五种值 参数为正数,返回+1; 参数为负数,返回-1; 参数为0,返回0; 参数为-0,返回-0; 其他值,返回NaN ceil(x)| 对数进行上舍入 floor(x)|对数进行下舍入 max(x,y)|返回 x 和 y 中的最高值 min(x,y)|返回 x 和 y 中的最低值 cos(x)|返回数的余弦 sin(x)|返回数的正弦 tan(x)|返回角的正切 acos(x)|返回数的反余弦值 asin(x)|返回数的反正弦值 atan(x)|以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 atan2(y,x)|返回从 x 轴到点 (x,y) 的角度(介于 -PI/2 与 PI/2 弧度之间) sinh(x)|返回x的双曲正弦(hyperbolic sine) cosh(x)|返回x的双曲余弦(hyperbolic cosine) tanh(x)|返回x的双曲正切(hyperbolic tangent) asinh(x)|返回x的反双曲正弦(inverse hyperbolic sine) acosh(x)|返回x的反双曲余弦(inverse hyperbolic cosine) atanh(x)|返回x的反双曲正切(inverse hyperbolic tangent) pow(x,y)|返回 x 的 y 次幂 sqrt(x)|返回数的平方根 hypot(...args)|方法返回所有参数的平方和的平方根 cbrt(x)|方法用于计算一个数的立方根 exp(x)|返回 e 的指数 log(x)|返回数的自然对数(底为e) expm1(x)|返回Math.exp(x) - 1 log1p(x)|方法返回1 + x的自然对数，即Math.log(1 + x).如果x小于-1,返回NaN. log10(x)|返回以10为底的x的对数.如果x小于0,则返回NaN log2(x)|返回以2为底的x的对数.如果x小于0,则返回NaN. clz32(x)|返回一个数的32位无符号整数形式有多少个前导0. imul(x,y)|方法返回两个数以32位带符号整数形式相乘的结果,返回的也是一个32位的带符号整数. toSource()|返回该对象的源代码.[兼容性] valueOf()|返回 Math 对象的原始值. 类型转换 Number()函数,将一个值转变为10进制数值类型 虽然js早期版本提供了Number(),parseInt()和parseFloat()三种用来将对象值转换为数值类型的方法,但因为 为了好记 为了与python统一记 适应ES6中没有后两种全局方法,而是在Number对象中新增了同名方法 我们就只搞第一个 Number()的转换特点如下: 布尔值 true变成1,false变成0 数值型 原来是啥还是啥 null 变成0 undefined NaN 字符串 只包含数字(包括前面有正负号的情况) 去掉前置的0转换成十进制整数 包括.符号,其他都是数 去掉前置的0转换成十进制浮点数数 包含0xf,0b和0x字样 作为16进制数转换成10进制数 空字符串 0 包括其他的字符 NaN 对象 调用valueOf()方法再转值,没有的话再试toString()方法 Symbol babel-node直接报错TypeError Number(\"1.23\") 1.23 Number(Symbol()) evalmachine.:1 Number(Symbol()); ^ TypeError: Cannot convert a Symbol value to a number at Number () at evalmachine.:1:1 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) at emit (internal/child_process.js:812:12) at process._tickCallback (internal/process/next_tick.js:63:19) 字符串 字符串是以单引号'或双引号\"括起来的任意文本,比如'abc',\"xyz\"等等.请注意''或\"\"本身只是一种表示方式,不是字符串的一部分,因此字符串'abc'只有a，b，c这3个字符. 和python中一样,js的字符串也是不可变值 字符串对象的默认属性和方法: 属性 描述 length 字符串的长度 字符串的运算符: 运算符 描述 + 字符串连接 字符串对象方法: anchor(anchorname) |创建 HTML 锚 big() |用大号字体显示字符串 small() |使用小字号来显示字符串 blink() |显示闪动字符串 bold() |使用粗体显示字符串 italics() |使用斜体显示字符串 fixed() |以打字机文本显示字符串 strike()| 使用删除线来显示字符串 sub() |把字符串显示为下标 sup() |把字符串显示为上标 toLocaleLowerCase() |把字符串转换为小写 toLocaleUpperCase()|把字符串转换为大写 toLowerCase() |把字符串转换为小写 toUpperCase() |把字符串转换为大写 toSource() |代表对象的源代码[兼容性] toString() |返回字符串。 valueOf() |返回某个字符串对象的原始值 fontcolor(color) |使用指定的颜色来显示字符串 fontsize(size) |使用指定的尺寸来显示字符串 lastIndexOf(searchvalue [,fromindex]) |从后向前搜索字符串 link(url) |将字符串显示为链接 localeCompare(target) |用本地特定的顺序来比较两个字符串 match(searchvalue/regexp) |找到一个或多个正则表达式的匹配 replace(regexp/substr,replacement) |替换与正则表达式匹配的子串 search(regexp) |检索与正则表达式相匹配的值 slice(start,end)| 提取字符串的片断，并在新的字符串中返回被提取的部分 concat(stringX,stringX,...,stringX) |连接字符串 split(separator[,howmany]) |把字符串分割为字符串数组.howmany可指定返回的数组的最大长度.如果设置了该参数,返回的子串不会多于这个参数指定的数组.如果没有设置该参数,整个字符串都会被分割,不考虑它的长度. substr(start[,length]) |从起始索引号提取字符串中指定数目的字符.length参数表示子串中的字符数.必须是数值.如果省略了该参数,那么返回从 stringObject 的开始位置到结尾的字串 substring(start[,stop])| 提取字符串中两个指定的索引号之间的字符.stop参数比要提取的子串的最后一个字符在 stringObject 中的位置多 1.如果省略该参数,那么返回的子串会一直到字符串的结尾. codePointAt(index)|返回在指定的位置的字符的 Unicode 编码 repeat(n)|返回字符串重复n次的字符串 includes(searchvalue [,fromindex])|返回布尔值,表示是否找到了参数字符串 startsWith(searchvalue [,fromindex])|返回布尔值,表示参数字符串是否在源字符串的头部 endsWith(searchvalue [,fromindex])|返回布尔值,表示参数字符串是否在源字符串的尾部 indexOf(searchvalue [,fromindex])|返回某个指定的字符串值在字符串中首次出现的位置,不存在则返回-1 unicode和utf-16编码支持 ES6允许采用\\u{xxxx}形式表示一个字符，其中“xxxx”表示字符的码点 '\\u{1F680}' '🚀' JavaScript内部,字符以UTF-16的格式储存,每个字符固定为2个字节.对于那些需要4个字节储存的字符(Unicode码点大于0xFFFF的字符),JavaScript会认为它们是两个字符. codePointAt方法会正确返回32位的UTF-16字符的码点.对于那些两个字节储存的常规字符,它的返回结果与charCodeAt方法相同. codePointAt方法返回的是码点的十进制值,如果想要十六进制的值,可以使用toString方法转换一下. '𠮷'是一个典型的4字节存储字符,我们以它举例 let s = '𠮷a' s.codePointAt(0) // 134071 134071 s.codePointAt(1) // 57271 57271 s.codePointAt(2) 97 同样的,要把一个4字节的utf-16字符从码点返回,我们可以用String.fromCodePoint,注意,这个是String对象的方法,不是字符串对象的 String.fromCodePoint(0x20BB7) '𠮷' 字符串查找 可以用于字符串查找的方法有: includes(searchvalue [,fromindex]) 返回布尔值,表示是否找到了参数字符串. startsWith(searchvalue [,fromindex]) 返回布尔值,表示参数字符串是否在源字符串的头部 endsWith(searchvalue [,fromindex]) 返回布尔值,表示参数字符串是否在源字符串的尾部. indexOf(searchvalue [,fromindex]) 返回某个指定的字符串值在字符串中首次出现的位置,不存在则返回-1 这四个方法都支持第二个参数表示开始搜索的位置.使用第二个参数n时endsWith的行为与其他两个方法有所不同.它针对前n个字符,而其他两个方法针对从第n个位置直到字符串结束. let hello = 'Hello world!'; console.log(s.startsWith('world', 6)) // true console.log(s.endsWith('Hello', 5)) // true console.log(s.includes('Hello', 6)) // false console.log(s.indexOf('llo')) false false false -1 重复字符串 repeat()方法可以返回一个由原字符串重复好几次的新字符串 'ni'+'coni'.repeat(2) 'niconiconi' 这个方法如果接收 负数或者Infinity， 会报错 0到-1之间的小数,NaN 等同于0 字符串 先转成数字再判断 模板字符串 不用再羡慕python中字符创的format()方法了,ES6中有了模板字符串,它使用``包裹,使用${varname}表示占位字符,而并不需要再用format()这样的方法来做占位符的匹配,占位字符会自己与作用域中的变量匹配 var temple = `${name}今年${age}岁啦 ` var name = \"小亮\" var age = 27 temple 'undefined今年undefined岁啦 ' 如果模板字符串中的变量没有声明将报错,如果要用模板本身,可以用包裹字符串的对象构建一个Fuction对象,来实现 let str = 'return ' + '`Hello ${name}!`'; let func1 = new Function('name', str); func1('Jack') 'Hello Jack!' function temple(name){ return `hello ${name}!` } temple('jack') 'hello jack!' 类型转换 类似number,把一个其他对象转换成字符串的方式是使用String()函数 它的规则是: 有toString()则调用它 值是null则返回\"null\" 值是undefined则返回\"undefined\" 布尔值 布尔值只有true/false两种值,要么是true,要么是false.可以直接用true、false表示布尔值 true true 和python类似,js也提供了大量的假值 假值 类型 0 Number NaN Number '' String false Boolean null Object undefined Undefined 这之外的值都是真值 null null表示一个\"空\"的值,它和0以及空字符串''不同,0是一个数值,''表示长度为0的字符串,而null表示\"空\". 在其他语言中也有类似JavaScript的null的表示,例如Java也用null,Swift用nil,Python用None表示.但是在JavaScript中还有一个和null类似的undefined.它表示\"未定义\". JavaScript的设计者希望用null表示一个空的值 但注意 typeof(null)返回的是object,只是因为事实上null应当表示一个空的对象指针. null null typeof(null) 'object' undefined undefined表示值未定义.它既是值得类型,也是这个类型唯一的值.事实证明这并没有什么卵用.大多数情况下,我们都应该用null.undefined仅仅在判断函数参数是否传递的情况下有用. object 这个比较特殊,object是特殊的标准类型,可以说除了其他外的所有对象都是object类型.对象是引用类型,如果变量x表示一个对象,当执行let y = x语句后,实际上y和x指向的是同一个对象.所以当你通过y改变对象的值,这种变化也会反映到x上. 在js中对象很容易创建,只要使用大括号,像python中写字典一样就行了 typeof({}) 'object' 就像python中的运算符一样,每个object都有几个对应的方法和属性,后面会详细讲 在后面面向对象的部分我们会详细解析Object对象 symbol 这个是ES6新增的类型,作用就一个,给一个对象做个唯一标识. JS中对象属性名都是字符串,这容易造成属性名的冲突.比如你使用了一个他人提供的对象,但又想为这个对象添加新的方法(mixin模式).新方法的名字就有可能与现有方法产生冲突.如果有一种机制保证每个属性的名字都是独一无二的就好了.这样就从根本上防止属性名的冲突.这就是ES6引入Symbol的原因. Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型,一种是原来就有的字符串,另一种就是新增的Symbol类型.凡是属性名属于Symbol类型就都是独一无二的,可以保证不会与其他属性名产生冲突. typeof(Symbol()) 'symbol' Symbol函数可以接受一个字符串作为参数,表示对Symbol实例的描述(可以理解为注释或者标签),主要是为了在控制台显示,或者转为字符串时,比较容易区分. let s1 = Symbol(\"is s1\") let s2 = Symbol(\"is s2\") s1 Symbol(is s1) s2 Symbol(is s2) s1.toString() 'Symbol(is s1)' s2.toString() 'Symbol(is s2)' 上面代码中s1和s2是两个Symbol值.如果不加参数,它们在控制台的输出都是Symbol(),不利于区分.有了参数以后就等于为它们加上了描述,输出的时候就能够分清,到底是哪一个值. 注意Symbol函数的参数只是表示对当前Symbol值的描述,因此相同参数的Symbol函数的返回值是不相等的. Symbol值不能与其他类型的值进行运算,会报错. 但可以用toString()方法返回字符串,也可以用Boolean()函数或者作为判断表达式的内容转变为布尔值,它的意义是\"存在\"或者\"非空\" Boolean(s1) true if (s1){ console.log(\"true\") } true Symbol的特点是不会重复,这样可以避免不小心重写覆盖,的主要用法: 作为对象中的属性(在面向对象部分详细讲用法) 作为常量 例1 function log(level,msg){ return console.log(level,msg) } log.levels = { DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn'), } log(log.levels.DEBUG, 'debug message') log(log.levels.INFO, 'info message') Symbol(debug) 'debug message' Symbol(info) 'info message' 例2 const COLOR_RED = Symbol(\"red\"); const COLOR_GREEN = Symbol(\"green\"); function getComplement(color) { switch (color) { case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error('Undefined color'); } } getComplement(COLOR_GREEN) Symbol(red) 常量使用Symbol值最大的好处,就是其他任何值都不可能有相同的值了,因此可以保证上面的switch语句会按设计的方式工作. 实例:消除魔术字符串 魔术字符串指的是,在代码之中多次出现,与代码形成强耦合的某一个具体的字符串或者数值.风格良好的代码,应该尽量消除魔术字符串,该由含义清晰的变量代替. function getArea(shape, options) { var area = 0 switch (shape) { case 'Triangle': // 魔术字符串 area = .5 * options.width * options.height; break /* ... more code ... */ } return area } getArea('Triangle', { width: 100, height: 100 }) // 魔术字符串 5000 上面代码中字符串“Triangle”就是一个魔术字符串.它多次出现,与代码形成\"强耦合\",不利于将来的修改和维护. 常用的消除魔术字符串的方法,就是把它写成一个变量. var shapeType = { triangle: 'Triangle' } function getArea(shape, options) { var area = 0 switch (shape) { case shapeType.triangle: area = .5 * options.width * options.height break } return area } getArea(shapeType.triangle, { width: 100, height: 100 }) 5000 上面代码中我们把“Triangle”写成shapeType对象的triangle属性,这样就消除了强耦合. 如果仔细分析可以发现shapeType.triangle等于哪个值并不重要,只要确保不会跟其他shapeType属性的值冲突即可.因此这里就很适合改用Symbol值. const shapeType_ = { triangle: Symbol() } function getArea(shape, options) { var area = 0 switch (shape) { case shapeType_.triangle: area = .5 * options.width * options.height break } return area } getArea(shapeType_.triangle, { width: 100, height: 100 }) 5000 Symbol.for()和Symbol.keyFor() 有时我们希望重新使用同一个Symbol值,Symbol.for方法可以做到这一点.它接受一个字符串作为参数,然后搜索有没有以该参数作为名称的Symbol值.如果有就返回这个Symbol值;否则就新建并返回一个以该字符串为名称的Symbol值. var s1_ = Symbol.for('foo'); var s2_ = Symbol.for('foo'); s1_ === s2_ true 上面代码中,s1和s2都是Symbol值,但是它们都是同样参数的Symbol.for方法生成的,所以实际上是同一个值. Symbol.for()与Symbol()这两种写法,都会生成新的Symbol.它们的区别是前者会被登记在全局环境中供搜索而后者不会.Symbol.for()不会每次调用就返回一个新的Symbol类型的值,而是会先检查给定的key是否已经存在,如果不存在才会新建一个值.比如如果你调用Symbol.for(\"cat\")30次,每次都会返回同一个Symbol值,但是调用Symbol(\"cat\")30次,会返回30个不同的Symbol值. Symbol.for(\"bar\") === Symbol.for(\"bar\") true Symbol(\"bar\") === Symbol(\"bar\") false 上面代码中由于Symbol()写法没有登记机制,所以每次调用都会返回一个不同的值. Symbol.keyFor方法返回一个已登记的Symbol类型值的key. 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的,可以在不同的iframe或service worker中取到同一个值, iframe = document.createElement('iframe'); iframe.src = String(window.location); document.body.appendChild(iframe); iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo') // true 上面代码中,iframe窗口生成的Symbol值,可以在主页面得到. 判断值的陷阱 在python中我们知道None,0,{},[],\"\"这些都相当于False,而要确认是不是None或者False,我们可以使用关键字is 但js中判断值得问题一直很迷,这大致有如下几个问题: null和undefined的区别 哪些会判断为false 如何真正判断两个东西一致 null和undefined的区别 从字面意思上看null表示空,undefine表示未定义,那有什么区别呢? null一个对象,这个对象表示空,即这个对象表示没有内容,没有内容并不代表不存在,相反它是存在的; undefined则表示未定义,什么意思呢?就是说不存在,或者说在之前的认知以外,它是一个单独的类型,且这个类型只有这么一个实例. typeof(null) 'object' typeof(undefined) 'undefined' 因此可以确定这两个对象的使用范围: null 为申明的变量赋初值 作为返回值表示返回为空 作为参数的默认值表示可以不传入这个位置. undefined 不该被主动使用,只该用于判断 判断实例有没有某个字段 判断函数是否有返回值 判断形参是否有被调用时传入 对比在python中的情况我们可以看到这两种语言设计时的根本差距. python中我们有None,但没有undefined对应的某个对象,实际上undefined在python中是被作为异常处理的: python中函数默认的返回值是None,renturn只是将返回值由None替换成我们想返回的值而已. python中函数调用形参无法不传入,除非在定义函数时使用关键字参数并赋予默认值. python中访问不存在的字段会抛出AttributeError 因此可以说python对于未定义内容比js严格的多,在python的语义下没有所谓未定义,python只能要么规定好默认值并确定好默认值行为,要么就抛出异常. 扩展到语言的设计哲学中可以认为python认为一切都是可知的,未知是异常,而js认为有不可知的东西,他们都是未定义. class A: pass a=A() a.a --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) in () 3 4 a=A() ----> 5 a.a AttributeError: 'A' object has no attribute 'a' 哪些会判断为false js中只有false,null,0,\"\",undefined,NaN会判断为false,其他都是true,这点和python中是有区别的--容器即便里面是空的也是true. assert({}) 如何真正判断两个东西一致 python中可以使用关键字is来判断两个对象是否是一个对象;js中要严格判断两个对象是否一致应该使用Object.is(x,y) 使用Object.is(x,y)如果下列任何一项成立,则两个值相同: 两个值都是undefined 两个值都是null 两个值都是true 两个值都是false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且都是正零+0 两个值都是数字并且都是负零-0 两个值都是数字并且都是NaN 两个值都是数字并且都是除零和NaN外的其它同一个数字 需要注意的是0值,0是+0的简写,js中-0和+0等值但不是一个对象,也就是说使用Object.is可以区分+0和-0,但使用===这两者是true 0===-0 true 0 === +0 true Object.is(0,+0) true Object.is(-0,+0) false 这又是和python中不同的地方,python认为0和-0不光值一样,也是同一个东西. 0 is -0 True 0==-0 True Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/从运算符到函数.html":{"url":"基础语法/从运算符到函数.html","title":"从运算符到函数","keywords":"","body":"从表达式到函数 编程编的是什么呢?编的是执行操作的过程,而表达式是编程语言中执行过程的最小单位. 表达式是由数字、算符、数字分组符号(括号)、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合.约束变量在表达式中已被指定数值,而自由变量则可以在表达式之外另行指定数值. 而对表达式进行组合描述更加复杂的操作过程就是控制流,迭代语法和错误处理.这些语句可以用于描述表达式间的关联,从而在不同的情况下执行不同的表达式,再进一步就是函数.函数将一段由表达式描述的操作过程封装到一起,从而实现复用. 函数作为现代编程语言中最基础的工具之一,在不同的语言中其地位是不同的,js中的函数也是一等对象,但相比python的可以说更加好用一些, 主要体现在它的匿名函数定义更加方便. 表达式 表达式是一组代码的集合,它会返回一个值,通常表达式由若干运算符和数据对象组合而成. 运算符 运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算,从操作数据的个数来看通常有一元运算符,二元运算符,三元运算符三种. js中运算符按功能来看包括如下几种: 赋值运算符(Assignment operators) 凡是让运算符左边的变量获得右边代码运算结果操作就是赋值运算,js中支持的赋值运算符包括 名字 简写的操作符 含义 赋值(Assignment) `x = y`` x = y` 加法赋值(Addition assignment) x += y x = x + y 减法赋值(Subtraction assignment) x -= y x = x - y 乘法赋值(Multiplication assignment) x *= y x = x * y 除法赋值(Division assignment) x /= y x = x / y 求余赋值(Remainder assignment) x %= y x = x % y 求幂赋值(Exponentiation assignment) x **= y x = x ** y 左移位赋值(Left shift assignment) x x = x 右移位赋值(Right shift assignment) x >>= y x = x >> y 无符号右移位赋值(Unsigned right shift assignment) x >>>= y x = x >>> y 按位与赋值(Bitwise AND assignment) x &= y x = x & y 按位异或赋值(Bitwise XOR assignment) x ^= y x = x ^ y 按位或赋值(Bitwise OR assignment) xI=y `x = x y` 另一个特殊的赋值操作是解构赋值,这个可以看基本容器中的介绍. 比较运算符(Comparison operators) 比较运算符比较它的操作数并返回一个基于表达式是否为真的逻辑值。操作数可以是数字，字符串，逻辑，对象值。字符串比较是基于标准的字典顺序，使用Unicode值。在多数情况下，如果两个操作数不是相同的类型， JavaScript 会尝试转换它们为恰当的类型来比较。这种行为通常发生在数字作为操作数的比较。类型转换的例外是使用 === 和 !== 操作符，它们会执行严格的相等和不相等比较。这些运算符不会在检查相等之前转换操作数的类型。下面的表格描述了该示例代码中的各比较运算符 名字 运算符 描述 等于Equal == 二元运算符,如果两边操作数相等时返回true 不等于Not equal != 二元运算符,如果两边操作数不相等时返回true 全等Strict equal === 二元运算符,两边操作数相等且类型相同时返回true 不全等 Strict not equal !== 二元运算符,两边操作数不相等或类型不同时返回true 大于 Greater than > 二元运算符,左边的操作数大于右边的操作数返回true 大于等于 Greater than or equal >= 二元运算符,左边的操作数大于或等于右边的操作数返回true 小于 Less than 二元运算符,左边的操作数小于右边的操作数返回true 小于等于 Less than or equal 二元运算符,左边的操作数小于或等于右边的操作数返回true 算数运算符(Arithmetic operators) 算术运算符使用数值(字面量或者变量)作为操作数并返回一个数值.标准的算术运算符就是加减乘除(+ - * /)。当操作数是浮点数时，这些运算符表现得跟它们在大多数编程语言中一样.特殊要注意的是，除零会产生Infinity 名字 运算符 描述 自增 ++ 一元运算符. 将操作数的值加一. 如果放在操作数前面 (++x), 则返回加一后的值; 如果放在操作数后面 (x++), 则返回操作数原值,然后再将操作数加一. 自减 -- 一元运算符. 将操作数的值减一. 前后缀两种用法的返回值类似自增运算符. 一元负值符 - 一元运算符,返回操作数的负值. 一元正值符 + 一元运算符,如果操作数在之前不是number，试图将其转换为number 求和 + 二元运算符,返回相加后的结果 求和 - 二元运算符,返回相减后的结果 求和 * 二元运算符,返回相乘后的结果 求和 / 二元运算符,返回相除后的结果 求余 % 二元运算符. 返回相除之后的余数. 指数运算符 ** 计算 base(底数) 的 exponent(指数)次方, 表示为baseexponent 位运算符(Bitwise operators) 位运算符将它的操作数视为32位元的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值 名字 运算符 描述 按位非 NOT ~ 一元运算符,反转被操作数的位 按位与 AND & 二元运算符,每一个对应的位都为1则返回1， 否则返回0. 按位或 OR I 二元运算符,每一个对应的位，只要有一个为1则返回1， 否则返回0. 按位异或 XOR ^ 二元运算符,每一个对应的位，两个不相同则返回1，相同则返回0. 左移 shift a 二元运算符,将a的二进制串向左移动b位,右边移入0. 算术右移 a>>b 二元运算符,把a的二进制表示向右移动b位，丢弃被移出的所有位.(注:算术右移左边空出的位是根据最高位是0和1来进行填充的) 无符号右移(左边空出位用0填充) a>>>b 把a的二进制表示向右移动b位，丢弃被移出的所有位，并把左边空出的位都填充为0 逻辑运算符(Logical operators) 逻辑运算符常用于布尔（逻辑）值之间:当操作数都是布尔值时,返回值也是布尔值. 不过实际上&&和||返回的是一个特定的操作数的值,所以当它用于非布尔值的时候,返回值就可能是非布尔值.逻辑运算符的描述如下 名字 运算符 描述 逻辑与 && expr1 && expr2如果expr1能被转换为false，那么返回expr1；否则，返回expr2。因此，&&用于布尔值时，当操作数都为true时返回true；否则返回false. 逻辑或 II expr1 II expr2 如果expr1能被转换为true，那么返回expr1；否则，返回expr2。因此，II用于布尔值时，当任何一个操作数为true则返回true；如果操作数都是false则返回false 逻辑非 ! !expr如果操作数能够转换为true则返回false；否则返回true 作为逻辑表达式进行求值是从左到右，它们是为可能的“短路”的出现而使用以下规则进行测试： false && anything // 被短路求值为false true II anything // 被短路求值为true 逻辑的规则,保证这些评估是总是正确的.请注意上述表达式的anything部分不会被求值,所以这样做不会产生任何副作用. 字符串运算符(String operators) 比较运算符可以直接用于字符串的比较,另一个字符串可以使用的运算符是求和运算符,在字符串运算符中,其意思是字符串的连接 条件（三元）运算符(Conditional operator) 条件运算符是JavaScript中唯一需要三个操作数的运算符,运算的结果根据给定条件在两个值中取其一.语法为： 条件 ? 值1 : 值2 如果条件为真,则结果取值1;否则为值2.你能够在任何允许使用标准运算符的地方使用条件运算符 逗号运算符(Comma operator) 逗号操作符对两个操作数进行求值并返回最终操作数的值.它常常用在 for 循环中,在每次循环时对多个变量进行更新. 例如假如 a 是一个二维数组,每个维度各有10个元素，以下代码利用逗号操作符来同时改变两个变量的值.这段代码的功能是打印出该二维数组的对角线元素的值: const x = [0,1,2,3,4,5,6,7,8,9] const a = [x, x, x, x, x] for (let i = 0, j = 9;i a[0][9]= 9 a[1][8]= 8 a[2][7]= 7 a[3][6]= 6 a[4][5]= 5 一元运算符(Unary operators) 除了自增自减外,还有一些js自定义的一元运算符用于操作数据.这些运算符的使用方式是 运算符 数据 有如下这些 名字 运算符 描述 删除 delete 删除一个对象或一个对象的属性或者一个数组中某一个键值 类型反射 typeof typeof 操作符返回一个表示 operand 类型的字符串值。operand 可为字符串,变量,关键词或对象,其类型将被返回.operand 两侧的括号为可选 空返回 void 表明一个运算没有返回值,这通常在浏览器环境用 关系运算符(Relational operator) 关系运算符用于判断两个对象间的关系,包含两种: 名字 运算符 描述 包含 in 运算符前的对象包含于后一对象 是实例 instanceof objectName instanceof objectType 运算符优先级 运算符可以连立,因此运算符是有优先级的,顺序可以查看这张表 表达式类型 JavaScript有以下表达式类型： 算数: 得出一个数字, 例如 3.14159. (通常使用 arithmetic operators.) 字符串: 得出一个字符串, 例如, \"Fred\" 或 \"234\". (通常使用 string operators.) 逻辑值: 得出true或者false. (经常涉及到 logical operators.) 基本表达式: javascript中基本的关键字和一般表达式,这包括this和()操作 左值表达式: 分配给左值,包括new和扩展语句操作 谓词 所有返回bool值的表达式称做谓词,谓词是过程的基础,没有谓词也就没有控制流. Function对象 函数是对象,因此它也有属性和方法 属性 说明 this 指使用时所在的对象(注意) arguments 函数的参数存放处,一个类数组对象 length 希望接收参数的个数 prototype 保存实例方法的对象 name 函数的名字 方法 说明 toString() 返回字面量 valueOf() 返回functin的值 function f1(x,y){ return x+y } (()=>{return 1}).name '' 定义一个函数 像python中一样,fucntion是对象,定义一个function可以有4种方式: 使用function关键字 这种方式类似python中的define function f2(...args){ return true } 最标准的fucntion写法,没啥花头~ 通过new关键字开辟一个新的Function对象 var func =new Function(\"param1\",\"param2\",...\"function body\") let aa = new Function(\"x\",\"y\",\"var a = 10 ;return a+x+y\") aa(1,2) 13 这个就有花头了,function既然是一个对象,那当然可以用new关键字构建了,但不建议这样写,因为你也看到了,代码段成了字符串不好维护,而且显而易见的一定会有二次解析影响性能 匿名函数 function不定义函数名就是匿名函数了 let n = function(x,y){ return x+y } n(1,2) 3 箭头函数 let s = (x,y)=>{ return x+y } let s = (x,y)=>{ return x+y } s(1,2) 3 箭头函数是ES6中新增的方式,主要好处在于简化函数的使用,不过需要注意的是: （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 函数的参数 js函数的参数全部都是位置参数,没有关键字参数,这也就意味着我们调用函数时不能像python中一样全部使用关键字来避免出错 arguments 定义function后,Js实际上会默认将所有参数传入一个内部变量arguments,它类似一个array,因此即便你定义的参数数目和实际使用给的参数数目不同也没关系,用arguments就可以了,有点类似python中的*args. function sum() { var args = Array.prototype.slice.apply(arguments) var sum = args.reduce(function(x,y){ return x+y }) return sum } sum(1,2,3) 6 使用arguments也可以实现参数默认值的设定 function defaultArgs(){ var a = arguments[0] ? arguments[0] : 1//设置参数a的默认值为1 var b = arguments[1] ? arguments[1] : 9//设置参数b的默认值为9 return [a,b,Array.prototype.slice.apply(arguments)] } defaultArgs(1,2,3) [ 1, 2, [ 1, 2, 3 ] ] 变长参数 我们可以使用扩展运算符来实现边长参数的使用,这个就真的有点像python中的*args了 function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } 'use strict' foo(1,2,3,3,4,5) a = 1 b = 2 [ 3, 3, 4, 5 ] 默认参数 需要注意的是js中的默认参数依然是位置参数而非关键字参数 function bar(a = 1,b = 2){ return a+b } bar() 3 闭包 js支持高阶函数,当然也就支持闭包了 所谓闭包就是返回值是一个函数 例 一个自加器 let counter = () => { let flag = 0 let count = () =>{ flag += 1 return flag } return count } let c1 = counter() console.log(c1()) console.log(c1()) console.log(c1()) console.log(c1()) 1 2 3 4 装饰器(babel默认未实现) 在python中装饰器是一种元编程的方式(一种闭包的语法糖).在js中我们也可以使用装饰器.本质上,它还是一个闭包的语法糖,只是写法不一样,而且限定只有类,方法,属性,参数可以使用.需要主义的是和python中不同,由于js中存在函数提升,因此js中的装饰器不可以应用于函数. 类装饰器 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义. 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。 注意:如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中 不会为你做这些。 @sealed class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } 方法装饰器 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 如果方法装饰器返回一个值，它会被用作方法的属性描述符。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @enumerable(false) greet() { return \"Hello, \" + this.greeting; } } 访问器装饰器 类似python中的@property访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义 TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。 访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 属性装饰器 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 如果属性装饰器返回一个值，它会被用作方法的属性描述符 class Greeter { @format(\"Hello, %s\") greeting: string; constructor(message: string) { this.greeting = message; } greet() { let formatString = getFormat(this, \"greeting\"); return formatString.replace(\"%s\", this.greeting); } } 参数装饰器 参数装饰器应用于类构造函数或方法声明 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 参数在函数参数列表中的索引。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @validate greet(@required name: string) { return \"Hello \" + name + \", \" + this.greeting; } } 已经实现的装饰器 core-decorators.js提供了很多实用的装饰器,我们可以直接拿来使用 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/迭代器与生成器.html":{"url":"基础语法/迭代器与生成器.html","title":"迭代器与生成器","keywords":"","body":"迭代器与生成器 迭代器和生成器是es6定义的两个最关键的接口,这两个概念在python中也有. 迭代器(Iterator) 这个是python中也有的概念,迭代器可以处理容器的迭代行为,支持的包括: Array Map Set String, ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费. Iterator的遍历过程是这样的。 创建一个指针对象，指向当前数据结构的起始位置.也就是说遍历器对象本质上就是一个指针对象. 第一次调用指针对象的next方法,可以将指针指向数据结构的第一个成员 第二次调用指针对象的next方法,指针就指向数据结构的第二个成员 不断调用指针对象的next方法,直到它指向数据结构的结束位置 每一次调用next方法都会返回数据结构的当前成员的信息.具体来说，就是返回一个包含value和done两个属性的对象.其中,value属性是当前成员的值,done属性是一个布尔值,表示遍历是否结束. 上面这些概念和python中是一样的. let a = [1,2,3,4] let iter = a[Symbol.iterator]() iter.next() { value: 1, done: false } ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性,或者说一个数据结构只要具有Symbol.iterator属性就可以认为是\"可遍历的\"(iterable).调用Symbol.iterator方法就会得到当前数据结构默认的遍历器生成函数.Symbol.iterator本身是一个表达式,返回Symbol对象的iterator属性,这是一个预定义好的,类型为Symbol的特殊值.所以要放在方括号内. 自定义对象的Iterator 一个对象如果要有可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法 Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。 例:为一个对象部署Iterator接口 let iterable = { 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (let item of iterable) { console.log(item) // 'a', 'b', 'c' } a b c 普通对象部署数组的Symbol.iterator方法，并无效果。必须有以从0开始的数字下标作为字段,并且有length字段作为长度的才可以用 自定义一类迭代器 更常见的方法是像python中一样创建一个类来生成某一类行为的迭代器.比如python中的range 例: 用iterator实现的range函数 class RangeIterator { constructor(start, stop,step=1) { this.value = start this.stop = stop this.step = step } [Symbol.iterator]() { return this; } next() { let value = this.value if (value function range(start, stop) { return new RangeIterator(start, stop) } for (var value of range(0, 3)) { console.log(value); } 0 1 2 调用Iterator的场合 解构赋值 所谓结构赋值就是把一个容器中的内容单独的赋值到对应的变量中 对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。 let set = new Set().add('a').add('b').add('c') let [x,y] = set console.log(x) console.log(y) let [first, ...rest] = set console.log(first) console.log(rest) a b a [ 'b', 'c' ] 扩展运算符 扩展运算符我们在前面见过了,也就是 ...符号,通过这种方式可以将iterator对象方便的转换成数组,之前的map和set转化为array其实也是用了这一特性 let arr = ['b', 'c'] 'use strict' ['a', ...arr, 'd'] [ 'a', 'b', 'c', 'd' ] 迭代器器与其他遍历手段的比较 与其他遍历语法的比较 以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。 for (var index = 0; index 这种写法比较麻烦，因此数组提供内置的forEach方法。 myArray.forEach(function (value) { console.log(value) }) 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for...in循环可以遍历数组的键名。 for (var index in myArray) { console.log(myArray[index]) } for...in循环有几个缺点。 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。 for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for...in循环会以任意顺序遍历键名。 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。 for...of循环相比上面几种做法，有一些显著的优点。 for (let value of myArray) { console.log(value) } 有着同for...in一样的简洁语法，但是没有for...in那些缺点。 不同用于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 下面是一个使用break语句，跳出for...of循环的例子。 for (var n of fibonacci) { if (n > 1000) break console.log(n) } 上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for...of循环。 生成器 和python中类似,实现了迭代器外还额外实现throw和return方法的对象就是生成器了.生成器常用于构造流,它同样可以使用for of语法消耗.同时比起一般迭代器,它还可以和函数体外进行交互,转让执行权,这些特点和python中是一样的. 生成器函数 一个简单的方式创建生成器就是使用生成器函数,只要定义函数时在function后加*,注意箭头函数不能也不该用于构造生成器 例:斐波那契数的生成器 function* fib(N){ let n = 0 let first =0 let second = 1 let temp while (n for (let i of fib(5)) { console.log(i) } 1 1 2 3 5 yield语句 与python中一样,生成器中的yield其实起到一个暂停断点的作用,它的逻辑如下: 遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。 如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是yield语句后面的表达式只有当调用next方法、内部指针指向该语句时才会执行，和python一样,这是js的惰性求值（Lazy Evaluation）的主要实现。 function* gen() { yield 123 + 456 } 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 可以从上面的规则看出,js的生成器可以不带yield,这也是和python中不同的地方 Generator不带yield语句，这时就变成了一个单纯的暂缓执行函数. function* f() { console.log('执行了！') } let generator = f() setTimeout(function () { generator.next() }, 2000) Timeout { _called: false, _idleTimeout: 2000, _idlePrev: TimersList { _idleNext: [Circular], _idlePrev: [Circular], _unrefed: false, msecs: 2000, _timer: Timer { _list: [Circular] } }, _idleNext: TimersList { _idleNext: [Circular], _idlePrev: [Circular], _unrefed: false, msecs: 2000, _timer: Timer { _list: [Circular] } }, _idleStart: 8935, _onTimeout: [Function], _timerArgs: undefined, _repeat: null, _destroyed: false, [Symbol(unrefed)]: false, [Symbol(asyncId)]: 98, [Symbol(triggerId)]: 95 } 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。 另外需要注意，yield语句不能用在普通函数中，否则会报错。 下面是另外一个例子。 let arr1 = [1, [[2, 3], 4], [5, 6]] let flat = function* (a) { let length = a.length for (let i = 0; i 1 2 3 4 5 6 另外，yield语句如果用在一个表达式之中，必须放在圆括号里面. yield语句用作函数参数或赋值表达式的右边,可以不加括号. yield* 如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的. function* foo() { yield 'a' yield 'b' } function* bar() { yield 'x' foo() yield 'y' } for (let v of bar()){ console.log(v) } x y 面代码中，foo和bar都是Generator函数,在bar里面调用foo，是不会有效果的. 这个就需要用到yield*语句,用来在一个Generator函数里面执行另一个Generator函数. function* bar() { yield 'x' yield* foo() yield 'y' } for (let v of bar()){ console.log(v) } x a b y 没错,就是python中的yield from 例:使用yield*语句遍历完全二叉树。 // 下面是二叉树的构造函数， // 三个参数分别是左树、当前节点和右树 function Tree(left, label, right) { this.left = left this.label = label this.right = right } // 下面是中序（inorder）遍历函数。 // 由于返回的是一个遍历器，所以要用generator函数。 // 函数体内采用递归算法，所以左树和右树要用yield*遍历 function* inorder(t) { if (t) { yield* inorder(t.left) yield t.label yield* inorder(t.right) } } // 下面生成二叉树 function make(array) { // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2])); } let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]); // 遍历二叉树 let result = [] for (let node of inorder(tree)) { result.push(node) } result [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ] 生成器函数的this 生成器函数总是返回一个迭代器，ES6规定这个迭代器是生成器函数的实例,也继承了生成器函数的prototype对象上的方法. function* g() {} g.prototype.hello = function () { return 'hi!'; }; let obj = g(); console.log(obj instanceof g) // true console.log(obj.hello()) // 'hi!' true hi! 执行了！ 上面代码表明生成器函数g返回的迭代器obj是g的实例;而且继承了g.prototype.但是如果把g当作普通的构造函数并不会生效.因为g返回的总是迭代器对象,而不是this对象. function* g() { this.a = 11 } let obj_ = g() obj_.a // undefined 上面代码中,生成器函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性. function* F(){ yield this.x = 2 yield this.y = 3 } 上面代码中，函数F是一个构造函数，又是一个生成器函数.这时使用new命令就无法生成F的实例了,因为F返回的是一个内部指针. 如果要把生成器函数当作正常的构造函数使用,可以采用下面的变通方法. 首先生成一个空对象,使用bind方法绑定生成器函数内部的this.这样构造函数调用以后,这个空对象就是生成器函数的实例对象了. function* F1(){ yield this.x = 2 yield this.y = 3 } let obj1 = {} let f = F1.bind(obj1)() console.log(f.next()) // Object {value: 2, done: false} console.log(f.next()) // Object {value: 3, done: false} console.log(f.next()) // Object {value: undefined, done: true} obj // { x: 2, y: 3 } { value: 2, done: false } { value: 3, done: false } { value: undefined, done: true } Object [Generator] {} 上面代码中，首先是F1内部的this对象绑定obj1对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj1对象上了，因此obj1对象也就成了F的实例 生成器对象 无论是定义生成器类,还是使用生成器函数构造生成器对象,其都应该有3个标准方法: throw方法可以在函数体外抛出错误,然后在Generator函数体内捕获 let g2 = function* () { try { yield } catch (e) { console.log('内部捕获', e); } } let i = g2() i.next() try { i.throw('a') i.throw('b') } catch (e) { console.log('外部捕获', e) } 内部捕获 a 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被生成器函数体内的catch语句捕获,i第二次抛出错误，由于生成器函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。 注意，不要混淆迭代器对象的throw方法和全局的throw命令。上面代码的错误，是用迭代器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获. return可以返回给定的值，并且终结遍历. function* gen() { yield 1; yield 2; yield 3; } let g1 = gen(); console.log(g1.next()) // { value: 1, done: false } console.log(g1.return(\"foo\")) // { value: \"foo\", done: true } console.log(g1.next()) // { value: undefined, done: true } { value: 1, done: false } { value: 'foo', done: true } { value: undefined, done: true } 带参数的next方法next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值,这与在python中也是一致的 function* f2() { for(var i=0; true; i++) { let reset = yield i; if(reset) { i = -1; } } } let g4 = f2(); console.log(g4.next()) // { value: 0, done: false } console.log(g4.next()) // { value: 1, done: false } console.log(g4.next(true)) // { value: 0, done: false } { value: 0, done: false } { value: 1, done: false } { value: 0, done: false } 上面代码先定义了一个可以无限运行的生成器函数f，如果next方法没有参数，每次运行到yield语句,变量reset的值总是undefined.当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 于是,协程语法就呼之欲出了 function* foo1(x) { let y = 2 * (yield (x + 1)); let z = yield (y / 3); return (x + y + z); } let a1 = foo1(5); console.log(a1.next()) // Object{value:6, done:false} console.log(a1.next()) // Object{value:NaN, done:false} console.log(a1.next()) // Object{value:NaN, done:true} let b1 = foo1(5); console.log(b1.next()) // { value:6, done:false } console.log(b1.next(12)) // { value:8, done:false } console.log(b1.next(13)) // { value:42, done:true } { value: 6, done: false } { value: NaN, done: false } { value: NaN, done: true } { value: 6, done: false } { value: 8, done: false } { value: 42, done: true } 上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。 function wrapper(generatorFunction) { return function (...args) { let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; }; } const wrapped = wrapper(function* () { console.log(`First input: ${yield}`); return 'DONE'; }); wrapped().next('hello!') First input: hello! { value: 'DONE', done: true } 上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。 function* dataConsumer() { console.log('Started'); console.log(`1. ${yield}`); console.log(`2. ${yield}`); return 'result'; } let genObj = dataConsumer(); genObj.next(); // Started genObj.next('a') // 1. a genObj.next('b') // 2. b Started 1. a 2. b { value: 'result', done: true } 上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/基本容器.html":{"url":"基础语法/基本容器.html","title":"基本容器","keywords":"","body":"基本容器 Javascript自带的数据结构其实并不好使,他们都是通用的Object,你是无法使用typeOf直接反射出来类型的.而Object本身也是一种容器. 自带的数据结构有: Array 数组,异构有序序列,支持迭代器 Set 集合,异构非重复无序序列,支持迭代器 Map 映射,hashmap.支持迭代器,key可以是任意类型 Object 对象,hashmap.不支持迭代器,key是字符串或Symbol Array 说是数组,其实只是数组的样子,本质上和python的list一样,不要指望效率 数组对象的方法 indexOf(str)|搜索指定元素出现位置(从左到右第一次出现) lastIndexOf(str)|索指定元素出现位置(从右到左第一次出现) slice(Numbers)|返回指定索引区的子串(切片),和python相同的规则 length|返回长度 pop()/push(elements)|出栈/入栈操作,即在数组末位做添加删除操作,相当于python的pop/append unshift(elements)/shift()|在数组首位做添加删除操作,和push/pop类似 sort()|排序 reverse()|转向,即把元素全部颠倒顺序 splice(start,number,replace)|从start位开始向后number位,先删除,再插入replace的内容 concat(otherArray)|数组连接 join(str)|类似python中的join,用某个字符串作为连接符把数组变成字符串 toString()|转换为字符串 copyWithin(target[, start = 0, end = this.length])|copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 fill(object)|使用给定值，填充一个数组 遍历器 遍历器 效果 keys() 返回一个键名的遍历器 values() 返回一个键值的遍历器 entries() 返回一个键值对的遍历器 forEach(func) 和scala中的一样,就是每个都进行操作 独有高阶函数方法 filter(func)|返回值是true的元素 map(func)|返回每次运行后的结果构成的数组 every(func)|如果每一项都返回true则返回true some(func)|有一个返回true就返回true reduce(func)|从起始位置开始遍历的缩小 reduceRight(func)|从末尾开始遍历缩小 find(func)|用于找出第一个符合条件的数组成员.它的参数是一个回调函数,所有数组成员依次执行该回调函数.直到找出第一个返回值为true的成员,然后返回该成员.如果没有符合条件的成员,则返回undefined. findIndex(func)|与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 Array对象的方法 from(array-like/iterable)|方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 of(...args)|将一组值，转换为数组 数组中的空值 神奇的是js是允许数字中有空值的 let array1 = [1,2,,4] array1 [ 1, 2, , 4 ] array1[2] 如你所见,空值内容不是null而是undefined,这点需要注意 扩展运算符 我们可以通过扩展运算符...将数组中的内容拆解出来,一个常见的应用就是利用原有数组构造新数组,这也是最简单的数组复制写法. let arr_o = [1,2,3,4] let arr_e = [0,...arr_o,5,6] arr_e [ 0, 1, 2, 3, 4, 5, 6 ] 数组解构 我们可以通过数组结构为复数的变量赋值. let arrex = [1,2] arrex [ 1, 2 ] let [x,y]=arrex x 1 y 2 另一个用法是和扩展运算符结合解构出特定位置的元素,需要注意扩展运算符的元素必须在最后一位 let [first, ...rest]=arr_e first 0 rest [ 1, 2, 3, 4, 5, 6 ] Set 和python中的set一样,set就是集合,也就是只能存储唯一值的无序数据结构 注意:在set里面,NaN是相同的值,而两个空对象却是不相等的 属性和方法 属性 说明 size 成员数量 方法 说明 add(value) 添加值 delete(value) 删除某个值 has(value) 返回一个布尔值，表示该值是否为Set的成员。 clear() 清除所有成员，没有返回值。 遍历器 说明 keys() 返回一个键名的遍历器 values() 返回一个键值的遍历器 entries() 返回一个键值对的遍历器 forEach() 使用回调函数遍历每个成员 filter(func) 返回值是true的元素 map(func) 返回每次运行后的结果构成的数组 let set1 = new Set() set1.add(1) Set { 1 } set1.add(\"1\") Set { 1, '1' } set1.size 2 WeakSet WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 首先，WeakSet的成员只能是对象，而不能是其他类型的值。 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。 let ws = new WeakSet() 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。 let a = [[1,2], [3,4]] let ws = new WeakSet(a) 上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。 注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。 let b = [3, 4]; let ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…) 上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。 WeakSet结构有以下三个方法。 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。 Map 类似python中的dictionary,字典结构,主要是用于描述键值对结构,Map是Set的扩展,只是唯一值可以带上一个映射值而已 let map1 = new Map([[\"name\",\"牛顿\"],[\"age\",18]]) map1 Map { 'name' => '牛顿', 'age' => 18 } 属性和方法 属性 说明 size 成员数量 方法 说明 set(key,value) 添加键值对 get(key) 获取键对应的值 delete(key) 删除某个键对应的键值对 has(key) 返回一个布尔值，表示该键是否为Map的成员。 clear() 清除所有成员，没有返回值。 遍历器 说明 keys() 返回一个键名的遍历器 values() 返回一个键值的遍历器 entries() 返回一个键值对的遍历器 forEach() 使用回调函数遍历每个成员 WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 相互转化 Map转数组: let maptoarray = [...map1] maptoarray [ [ 'name', '牛顿' ], [ 'age', 18 ] ] 数组转map let arraytomap = new Map([[true, 7], [{foo: 3}, ['abc']]]) 'use strict' arraytomap Map { true => 7, { foo: 3 } => [ 'abc' ] } set转array let settoarray = [...set1] settoarray [ 1, '1' ] array转set let arraytoset = new Set([1,2,3,4,5]) arraytoset Set { 1, 2, 3, 4, 5 } 特殊容器Object js中最特殊的就是Object,它既是所有对象的原型,又是一种数据格式,其实现就是hashmap,可以直接定义方法.然而他并没有默认的迭代器. let hao = { name:\"郝老师\", age:18, eat(){ console.log(this.name+\"在吃cuscus\") } } hao.eat() 郝老师在吃cuscus Object的字段 ES6与其他语言相比不同之处在于对象的字段可以是: 字符串,这种方式是最常规的,为了方便用可以做这样一个简写:比如一个对象字段名为a,我们要将a变量的值放入对象字段a,就可以简写成{a} Symbol,需要注意Symbol需要使用[]表示 表达式,使用[]表示 let name = \"郝老师\" let type = Symbol() let 郝老师 = { name, [\"type\"]:\"human\", [type === \"human\"?\"age\":\"year\"]:18, eat(){ console.log(this.name+\"在吃cuscus\") } } 郝老师 { name: '郝老师', type: 'human', year: 18, eat: [Function: eat] } 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象. let obj = { foo: 123 } Object.getOwnPropertyDescriptor(obj, 'foo') { value: 123, writable: true, enumerable: true, configurable: true } enumerable就是他的可枚举性,如果该属性为false，就表示某些操作会忽略当前属性。其中有: for...in 循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 Object.assign()：只拷贝对象自身的可枚举的属性 Reflect.enumerate()：返回所有for...in循环会遍历的属性 扩展运算符 在ES2018中我们可以通过扩展运算符...将对象中的内容拆解出来,一个常见的应用就是利用原有对象构造新对象,这也是最简单的复制写法. Object对象的方法: Object.is(x,y) 该方法用来代替==和===,来判断两个对象严格相等,其中主要与===不同之处在于: +0不等于-o NaN等于NaN Object.assign(target,...source) Object.assign方法用于对象的合并,将源对象(source)的所有可枚举属性复制到目标对象(target).如果目标对象与源对象有同名属性或多个源对象有同名属性,则后面的属性会覆盖前面的属性.Object.assign只拷贝自身属性,不可枚举的属性(enumerable为false)和继承的属性不会被拷贝.Object.assign方法实行的是浅拷贝而不是深拷贝.也就是说如果source对象某个属性的值是对象,那么目标对象拷贝得到的是这个对象的引用.我们基本上可以把它当成python中dict的update方法. 用处: 为对象添加属性和方法 克隆对象 合并多个对象 为属性指定默认值 对象属性遍历 有6种方式可以用来遍历对象的属性: 方法 是否遍历父原型 是否遍历symbol 是否遍历不可枚举 for...in 是 否 否 Object.keys(obj) 否 否 否 Object.getOwnPropertyNames(obj) 否 否 是 Object.getOwnPropertySymbols(obj) 否 是 否 Reflect.ownKeys(obj) 否 是 是 Reflect.enumerate(obj) 是 否 否 定义 getters 与 setters js支持在对象定义时指名其属性的可访问性,这有点类似python中的装饰器@property 一个getter 是一个获取某个特定属性的值的方法,一个 setter 是一个设定某个属性的值的方法.你可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性.定义 getter 和 setter 的语法采用对象字面量语法. 需要注意的是为 let o = { a: 7, get b() { return this.a + 1; }, set c(x) { this.a = x / 2 } } console.log(o.a); // 7 console.log(o.b); // 8 o.c = 50; console.log(o.a); // 25 7 8 25 o.b = 6 6 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/异步编程.html":{"url":"基础语法/异步编程.html","title":"异步编程","keywords":"","body":"异步编程 python是默认的全同步实现,它的异步都是通过框架实现的,比如gevent,tornad,在3.4之后python加入了async标准包实现了语言级别的异步,但貌似买帐的人不多,也算是历史遗留问题了. 所谓\"异步\"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 Js没有这些包袱,所以在异步方案方便确实做得比python好,js中异步处理并发主要手段是: 回调函数与Event对象 Promise对象 协程 回调函数与Event对象 这是最原始也是最好理解的手段,所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是\"重新调用\"。python中的tornado就是异步回调实现的服务器 在js中这是非常常见的技术,比如读取一个文件: let fs = require(\"fs\") fs.readFile('./README.md', 'utf-8',function (err, data) { if (err) throw err console.log(data.slice(0,20)) }) # Javascript基础语法 ES 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了./README.md这个文件以后，回调函数才会执行。 一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。 Event对象 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与回调函数结合使用,这与tkinter中类似 这边我们只讲html中的标准Eventapi 事件句柄　(Event Handlers) HTML事件触发浏览器中的行为，比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，可将之插入 HTML 标签以定义事件的行为。 属性 |此事件发生在何时 ---|--- onabort |图像的加载被中断。 onblur |元素失去焦点。 onchange |域的内容被改变。 onclick |当用户点击某个对象时调用的事件句柄。 ondblclick |当用户双击某个对象时调用的事件句柄。 onerror |在加载文档或图像时发生错误。 onfocus| 元素获得焦点。 onkeydown |某个键盘按键被按下。 onkeypress |某个键盘按键被按下并松开。 onkeyup |某个键盘按键被松开。 onload |一张页面或一幅图像完成加载。 onmousedown| 鼠标按钮被按下。 onmousemove| 鼠标被移动。 onmouseout| 鼠标从某元素移开。 onmouseover| 鼠标移到某元素之上。 onmouseup |鼠标按键被松开。 onreset |重置按钮被点击。 onresize |窗口或框架被重新调整大小。 onselect |文本被选中。 onsubmit |确认按钮被点击。 onunload |用户退出页面。 鼠标 / 键盘属性 属性 描述 altKey 返回当事件被触发时，\"ALT\" 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，\"CTRL\" 键是否被按下。 metaKey 返回当事件被触发时，\"meta\" 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，\"SHIFT\" 键是否被按下。 标准 Event 属性 下面列出了 2 级 DOM 事件标准定义的属性。 属性 描述 bubbles 返回布尔值，指示事件是否是起泡事件类型。 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 标准 Event 方法 下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法： 方法 描述 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件。 回调的缺点 回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下 fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... }) }) 如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为\"回调函数噩梦\"（callback hell） Promise promise翻译成中文就是保证,是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点: 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用stream模式(生成器)是比部署Promise更好的选择。 基本用法 Promise对象是一个构造函数，参数是一个函数对象,用来生成Promise实例 let promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value) } else { reject(error) } }) Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。 resolve函数 将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去 reject函数 将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 promise.then(function(value) { // success }, function(value) { // failure }); then方法可以接受两个回调函数作为参数。 第一个回调函数是Promise对象的状态变为Resolved时调用 第二个回调函数是Promise对象的状态变为Reject时调用。 其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 一个简单的例子 function timeout(ms) { return new Promise((resolve, reject) => { setTimeout(resolve, ms, 'done') }) } timeout(100).then((value) => { console.log(value) }) done 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise新建后就会立即执行。 异步实现 let promise = new Promise(function(resolve, reject) { console.log('1') resolve() }) promise.then(function() { console.log('2.') }) console.log('3') 1 3 2. 可以看到实际上异步主要就是在then上实现了 ajax操作 let getJSON = function(url) { let promise = new Promise(function(resolve, reject){ let client = new XMLHttpRequest() client.open(\"GET\", url) client.onreadystatechange = handler client.responseType = \"json\" client.setRequestHeader(\"Accept\", \"application/json\") client.send() function handler() { if ( this.readyState !== 4 ) { return } if (this.status === 200) { resolve(this.response) } else { reject(new Error(this.statusText)) } } }) return promise } getJSON(\"/posts.json\").then(function(json) { console.log('Contents: ' + json) }, function(error) { console.error('出错了', error) }) getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误 resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作 let p1 = new Promise(function (resolve, reject) { setTimeout(() => { reject(new Error('fail')) }, 3000) }) let p2 = new Promise(function (resolve, reject) { setTimeout(() => { resolve(p1) }, 1000) }) p2.then(result => console.log(result)) p2.catch(error => console.log(error)) Error: fail at Timeout.setTimeout (evalmachine.:5:12) at ontimeout (timers.js:424:11) at tryOnTimeout (timers.js:288:5) at listOnTimeout (timers.js:251:5) at Timer.processTimers (timers.js:211:10) 上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态由p1决定，1秒之后，p2调用resolve方法，但是此时p1的状态还没有改变，因此p2的状态也不会变。又过了2秒，p1变为rejected，p2也跟着变为rejected。 实例方法then() Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(\"/posts.json\").then(function(json) { return json.post }).then(function(post) { // ... }) 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 getJSON(\"/post/1.json\").then(function(post) { return getJSON(post.commentURL) }).then(function funcA(comments) { console.log(\"Resolved: \", comments) }, function funcB(err){ console.log(\"Rejected: \", err) }) 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 getJSON(\"/post/1.json\").then( post => getJSON(post.commentURL) ).then( comments => console.log(\"Resolved: \", comments), err => console.log(\"Rejected: \", err) ) Promise对象的catch() catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(\"/posts.json\").then(function(posts) { // ... }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error) }) 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 p.then((val) => console.log(\"fulfilled:\", val)) .catch((err) => console.log(\"rejected:\", err)); // 等同于 p.then((val) => console.log(fulfilled:\", val)) .then(null, (err) => console.log(\"rejected:\", err)) 下面是一个例子。 let promise1 = new Promise(function(resolve, reject) { throw new Error('test') }) promise1.catch(error => { console.log(error) }) (node:10335) UnhandledPromiseRejectionWarning: Error: fail at Timeout.setTimeout (evalmachine.:5:12) at ontimeout (timers.js:424:11) at tryOnTimeout (timers.js:288:5) at listOnTimeout (timers.js:251:5) at Timer.processTimers (timers.js:211:10) (node:10335) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1) (node:10335) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. Error: test at evalmachine.:4:9 at new Promise () at evalmachine.:3:16 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) at emit (internal/child_process.js:812:12) 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 let promise2 = new Promise(function(resolve, reject) { try { throw new Error('test') } catch(e) { reject(e) } }) promise2.catch(function(error) { console.log(error) }) Error: test at evalmachine.:5:11 at new Promise () at evalmachine.:3:16 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) at emit (internal/child_process.js:812:12) let promise3 = new Promise(function(resolve, reject) { reject(new Error('test')) }) promise3.catch(function(error) { console.log(error) }) Error: test at evalmachine.:4:10 at new Promise () at evalmachine.:3:16 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) at emit (internal/child_process.js:812:12) 比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果Promise状态已经变成Resolved，再抛出错误是无效的。 let promise4 = new Promise(function(resolve, reject) { resolve('ok') throw new Error('test') }) promise4.then(value => { console.log(value) }) .catch(error => { console.log(error) }) ok 上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。 Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 getJSON(\"/post/1.json\").then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }) 上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。这种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 let someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2) }) } someAsyncThing().then(function() { console.log('everything is great') }) ReferenceError: x is not defined at evalmachine.:6:13 at new Promise () at someAsyncThing (evalmachine.:4:10) at evalmachine.:10:1 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) 上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。 let promise5 = new Promise(function(resolve, reject) { resolve(\"ok\") setTimeout(function() { throw new Error('test') }, 0) }) promise5.then(function(value) { console.log(value) }) ok Error: test at Timeout._onTimeout (evalmachine.:4:11) at ontimeout (timers.js:424:11) at tryOnTimeout (timers.js:288:5) at listOnTimeout (timers.js:251:5) at Timer.processTimers (timers.js:211:10) 上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try...catch语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。 Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。 let someAsyncThing1 = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2) }) } someAsyncThing1() .catch(function(error) { console.log('oh no', error) }) .then(function() { console.log('carry on') }); oh no ReferenceError: x is not defined at evalmachine.:6:13 at new Promise () at someAsyncThing1 (evalmachine.:4:10) at evalmachine.:10:1 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 Promise.resolve() .catch(function(error) { console.log('oh no', error); }) .then(function() { console.log('carry on'); }) carry on 上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。 let someAsyncThing2 = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2) }) } someAsyncThing2().then(function() { return someOtherAsyncThing() }).catch(function(error) { console.log('oh no', error) // 下面一行会报错，因为y没有声明 y + 2; }).then(function() { console.log('carry on') }) oh no ReferenceError: x is not defined at evalmachine.:6:13 at new Promise () at someAsyncThing2 (evalmachine.:4:10) at evalmachine.:10:1 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) ReferenceError: y is not defined at evalmachine.:15:3 at process._tickCallback (internal/process/next_tick.js:68:7) 上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 someAsyncThing2().then(function() { return someOtherAsyncThing(); }).catch(function(error) { console.log('oh no', error); // 下面一行会报错，因为y没有声明 y + 2; }).catch(function(error) { console.log('carry on', error); }); oh no ReferenceError: x is not defined at evalmachine.:6:13 at new Promise () at someAsyncThing2 (evalmachine.:4:10) at evalmachine.:3:1 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) carry on ReferenceError: y is not defined at evalmachine.:8:3 at process._tickCallback (internal/process/next_tick.js:68:7) 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。 Promise.all() Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 var p = Promise.all([p1, p2, p3]) 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。） p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 let promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(\"/post/\" + id + \".json\") }) Promise.all(promises).then(function (posts) { // ... }).catch(function(reason){ // ... }) 上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子。 const databasePromise = connectDatabase() const booksPromise = databaseProimse .then(findAllBooks) const userPromise = databasePromise .then(getCurrentUser) Promise.all([ booksPromise, userPromise ]) .then(([books, user]) => pickTopRecommentations(books, user)) 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 Promise.race() Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 var p = Promise.race([p1,p2,p3]) 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 let p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) { setTimeout(() => reject(new Error('request timeout')), 5000) }) ]) p.then(response => console.log(response)) p.catch(error => console.log(error)) 上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve() 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 var jsPromise = Promise.resolve($.ajax('/whatever.json')) 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve等价于下面的写法。 Promise.resolve('foo') // 等价于 new Promise(resolve => resolve('foo')) Promise.resolve方法的参数分成四种情况。 参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 let thenable = { then: function(resolve, reject) { resolve(42) } } Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 let thenable = { then: function(resolve, reject) { resolve(42) } } let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value) // 42 }) 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。 参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 let p = Promise.resolve('Hello'); p.then(function (s){ console.log(s) }) Hello // Hello 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 4.不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。 所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。 let p = Promise.resolve() p.then(function () { // ... }) 上面代码的变量p就是一个Promise对象。 Promise.reject() Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。 let p = Promise.reject('出错了'); // 等同于 let p = new Promise((resolve, reject) => reject('出错了')) p.then(null, function (s){ console.log(s) }); // 出错了 上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。 两个有用的附加方法 ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。 done() Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 asyncFunc() .then(f1) .catch(r1) .then(f2) .done() 它的实现代码相当简单。 Promise.prototype.done = function (onFulfilled, onRejected) { this.then(onFulfilled, onRejected) .catch(function (reason) { // 抛出一个全局错误 setTimeout(() => { throw reason }, 0) }) } 从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。 finally() finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。 server.listen(0) .then(function () { // run test }) .finally(server.stop) 它的实现也很简单。 Promise.prototype.finally = function (callback) { let P = this.constructor return this.then( value => P.resolve(callback()).then(() => value), reason => P.resolve(callback()).then(() => { throw reason }) ) } 上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。 如何理解Promise Promise其实可以理解为规划,如果说回调是面向对象的,那Promise就是面向全局的,它把每种可能都描述在一起,而不是分开来给不同的地方 协程 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做\"协程\"（coroutine），意思是多个程序互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 像python中协程就是从生成器中衍生出来的,js也不例外. 举例来说，读取文件的协程写法如下。 function *asnycJob() { // ...其他代码 let f = yield readFile(fileA); // ...其他代码 } 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。 function* gen(x){ let y = yield x + 2; return y; } var g = gen(1); g.next() // { value: 3, done: false } g.next() // { value: undefined, done: true } 上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。 换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。 生成器函数的数据交换和错误处理 生成器函数可以暂停执行和恢复执行,这是它能封装异步任务的根本原因.除此之外,它还有两个特性,使它可以作为异步编程的完整解决方案:函数体内外的数据交换和错误处理机制 next方法返回值的value属性,是生成器函数向外输出数据;next方法还可以接受参数,这是向生成器函数体内输入数据 function* gen(x){ let y = yield x + 2; return y; } let g = gen(1); console.log(g.next()) // { value: 3, done: false } console.log(g.next(2)) // { value: 2, done: true } { value: 3, done: false } { value: 2, done: true } 上面代码中,第一个next方法的value属性,返回表达式x + 2的值.第二个next方法带有参数2,这个参数可以传入生成器函数,作为上个阶段异步任务的返回结果,被函数体内的变量y接收.因此这一步的 value 属性,返回的就是2（变量y的值）. 生成器函数内部还可以部署错误处理代码,捕获函数体外抛出的错误 function* gen(x){ try { let y = yield x + 2; } catch (e){ console.log(e); } return y; } let g = gen(1); g.next(); g.throw('出错了'); // 出错了 出错了 evalmachine.:9 return y; ^ ReferenceError: y is not defined at gen (evalmachine.:9:3) at gen.throw () at evalmachine.:14:8 at Script.runInThisContext (vm.js:91:20) at Object.runInThisContext (vm.js:298:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:182:13) at emit (internal/child_process.js:812:12) 上面代码的最后一行,生成器函数体外,使用指针对象的throw方法抛出的错误,可以被函数体内的try ...catch代码块捕获.这意味着出错的代码与处理错误的代码,实现了时间和空间上的分离,这对于异步编程无疑是很重要的 异步任务的封装 下面看看如何使用生成器函数以执行一个真实的异步任务。 import fetch from 'node-fetch' function* gen(){ let url = 'https://api.github.com/users/github' let result = yield fetch(url) console.log(result.bio) } 'use strict' 执行 let g = gen() let result = g.next() result.value.then(function(data){ return data.json() }).then(function(data){ g.next(data) }) How people build software. 上面代码中，生成器函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 上面代码中，首先执行生成器函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 可以看到，虽然生成器函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 Thunk函数 参数的求值策略 Thunk函数早在上个世纪60年代就诞生了。 那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是\"求值策略\"，即函数的参数到底应该何时求值 一种意见是\"传值调用\"（call by value），即在进入函数体之前，就计算表达式的值，再将这个值传入函数f 。C语言就采用这种策略。 f(x + 5) // 传值调用时，等同于 f(6) 另一种意见是\"传名调用\"（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。 function f(x){return x*2} f(x + 5) // 传名调用时，等同于 (x + 5) * 2 传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。 function f(a, b){ return b; } f(3 * x * x - 2 * x - 1, x) 上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于\"传名调用\"，即只在执行时求值。 编译器的\"传名调用\"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。 function f(m){ return m * 2; } f(x + 5); // 等同于 let thunk = function () { return x + 5; }; function f(thunk){ return thunk() * 2; } 上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是Thunk函数的定义，它是\"传名调用\"的一种实现策略，用来替换某个表达式。 JavaScript语言的Thunk函数 JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。 // 正常版本的readFile（多参数版本） fs.readFile(fileName, callback) // Thunk版本的readFile（单参数版本） var readFileThunk = Thunk(fileName) readFileThunk(callback) var Thunk = function (fileName){ return function (callback){ return fs.readFile(fileName, callback) } } 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。 let Thunk = function(fn){ return function (){ let args = Array.prototype.slice.call(arguments) return function (callback){ args.push(callback) return fn.apply(this, args) } } } 使用上面的转换器，生成fs.readFile的Thunk函数。 let readFileThunk = Thunk(fs.readFile) readFileThunk(fileA)(callback) Thunkify模块 生产环境的转换器，建议使用Thunkify模块。 首先是安装。 npm install thunkify 使用方式如下。 let thunkify = require('thunkify'); let fs = require('fs'); let read = thunkify(fs.readFile); read('package.json')(function(err, str){ // ... }) Thunkify的源码与上一节那个简单的转换器非常像。 function thunkify(fn){ return function(){ let args = new Array(arguments.length) let ctx = this for(let i = 0; i 它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的生成器函数相关。请看下面的例子。 function f(a, b, callback){ let sum = a + b; callback(sum); callback(sum); } let ft = thunkify(f); let print = console.log.bind(console); ft(1, 2)(print); // 3 上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。 生成器函数的流程管理 Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了生成器函数，Thunk函数现在可以用于生成器函数的自动流程管理。 以读取文件为例。下面的生成器函数封装了两个异步操作。 import * as fs from \"fs\" import thunkify from'thunkify' let readFile = thunkify(fs.readFile) let gen = function* (){ let r1 = yield readFile('./README.md',\"utf-8\") console.log(r1.toString()) let r2 = yield readFile('./package.json',\"utf-8\") console.log(r2.toString()) } 'use strict' 上面代码中，yield命令用于将程序的执行权移出生成器函数，那么就需要一种方法，将执行权再交还给生成器函数. 这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给生成器函数.为了便于理解，我们先看如何手动执行上面这个生成器函数 let g = gen() let r1 = g.next() r1.value(function(err, data){ if (err) throw err let r2 = g.next(data) r2.value(function(err, data){ if (err) throw err g.next(data) }) }) # Javascript基础语法 ES6已经在稍微现代点的浏览器和node.js中实装,本文所讲的语法内容基本以ES6为基准,包括: + 基本语法和代码结构 + 变量,值与运算 + 迭代器和生成器 + 基本容器 + 函数 + 异步操作 + 特殊对象RegExp和Date + 对象,类与面向对象编程 + 二进制数组 + 代理与反射 + 模块化编程 + 装饰器(ES7) { \"name\": \"quick_start\", \"version\": \"1.0.0\", \"description\": \"ES6快速入门\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"benchmark\":\"babel-node strconcat.benchmark.js\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"babel-cli\": \"^6.7.5\", \"babel-core\": \"^6.7.6\", \"babel-plugin-syntax-decorators\": \"^6.3.13\", \"babel-plugin-syntax-do-expressions\": \"^6.3.13\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.4\", \"babel-plugin-transform-runtime\": \"^6.7.5\", \"babel-polyfill\": \"^6.7.4\", \"babel-preset-es2015\": \"^6.6.0\", \"babel-preset-stage-0\": \"^6.5.0\", \"babel-preset-stage-1\": \"^6.5.0\", \"babel-preset-stage-2\": \"^6.5.0\", \"babel-preset-stage-3\": \"^6.5.0\", \"babel-register\": \"^6.7.2\", \"benchmark\": \"^2.1.0\", \"co\": \"^4.6.0\", \"eslint\": \"^2.7.0\", \"jake\": \"^8.0.12\", \"node-fetch\": \"^1.5.1\", \"thunkify\": \"^2.1.2\" }, \"babel\": { \"presets\": [ \"es2015\", \"stage-0\" ], \"plugins\": [ \"syntax-decorators\", \"transform-runtime\" ] }, \"dependencies\": { \"babel-runtime\": \"^6.6.1\" } } 上面代码中，变量g是生成器函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。 仔细查看上面的代码，可以发现生成器函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。 Thunk函数的自动流程管理 Thunk函数真正的威力，在于可以自动执行生成器函数。下面就是一个基于Thunk函数的生成器执行器。 import * as fs from \"fs\" import thunkify from'thunkify' let readFile = thunkify(fs.readFile) let gen = function* (){ let r1 = yield readFile('./README.md',\"utf-8\") console.log(r1.toString()) let r2 = yield readFile('./package.json',\"utf-8\") console.log(r2.toString()) } function run(fn) { let gen = fn() function next(err, data) { let result = gen.next(data) if (result.done) return result.value(next) } next() } run(gen) # Javascript基础语法 ES6已经在稍微现代点的浏览器和node.js中实装,本文所讲的语法内容基本以ES6为基准,包括: + 基本语法和代码结构 + 变量,值与运算 + 迭代器和生成器 + 基本容器 + 函数 + 异步操作 + 特殊对象RegExp和Date + 对象,类与面向对象编程 + 二进制数组 + 代理与反射 + 模块化编程 + 装饰器(ES7) { \"name\": \"quick_start\", \"version\": \"1.0.0\", \"description\": \"ES6快速入门\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"benchmark\":\"babel-node strconcat.benchmark.js\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"babel-cli\": \"^6.7.5\", \"babel-core\": \"^6.7.6\", \"babel-plugin-syntax-decorators\": \"^6.3.13\", \"babel-plugin-syntax-do-expressions\": \"^6.3.13\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.4\", \"babel-plugin-transform-runtime\": \"^6.7.5\", \"babel-polyfill\": \"^6.7.4\", \"babel-preset-es2015\": \"^6.6.0\", \"babel-preset-stage-0\": \"^6.5.0\", \"babel-preset-stage-1\": \"^6.5.0\", \"babel-preset-stage-2\": \"^6.5.0\", \"babel-preset-stage-3\": \"^6.5.0\", \"babel-register\": \"^6.7.2\", \"benchmark\": \"^2.1.0\", \"co\": \"^4.6.0\", \"eslint\": \"^2.7.0\", \"jake\": \"^8.0.12\", \"node-fetch\": \"^1.5.1\", \"thunkify\": \"^2.1.2\" }, \"babel\": { \"presets\": [ \"es2015\", \"stage-0\" ], \"plugins\": [ \"syntax-decorators\", \"transform-runtime\" ] }, \"dependencies\": { \"babel-runtime\": \"^6.6.1\" } } 上面代码的run函数，就是一个生成器函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到生成器函数的下一步（gen.next方法），然后判断生成器函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。 有了这个执行器，执行生成器函数方便多了。不管有多少个异步操作，直接传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。 let gen1 = function* (){ let f1 = yield readFile('./README.md') let f2 = yield readFile('./package.json') } run(gen1) 上面代码中，函数gen1封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。 Thunk函数并不是生成器函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制生成器函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。 co模块 co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于生成器函数的自动执行。 比如，有一个生成器函数，用于依次读取两个文件。 let gen = function* (){ let f1 = yield readFile('/etc/fstab') let f2 = yield readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString()) }; co模块可以让你不用编写生成器函数的执行器。 let co = require('co') co(gen) 上面代码中，生成器函数只要传入co函数，就会自动执行。 co函数返回一个Promise对象，因此可以用then方法添加回调函数。 co(gen).then(function (){ console.log('Generator 函数执行完成'); }) 上面代码中，等到生成器函数执行结束，就会输出一行提示。 co模块的原理 为什么co可以自动执行生成器函数？ 前面说过，生成器就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点: 回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。 co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，生成器函数的yield命令后面，只能是Thunk函数或Promise对象。 上面已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。 基于Promise对象的自动执行 还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。 let readFile1 = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) reject(error) resolve(data) }) }) } let gen2 = function* (){ let f1 = yield readFile1('./README.md') let f2 = yield readFile1('./package.json') console.log(f1.toString()) console.log(f2.toString()) } 'use strict' 然后，手动执行上面的生成器函数。 let g = gen2(); g.next().value.then(function(data){ g.next(data).value.then(function(data){ g.next(data) }) }) # Javascript基础语法 ES6已经在稍微现代点的浏览器和node.js中实装,本文所讲的语法内容基本以ES6为基准,包括: + 基本语法和代码结构 + 变量,值与运算 + 迭代器和生成器 + 基本容器 + 函数 + 异步操作 + 特殊对象RegExp和Date + 对象,类与面向对象编程 + 二进制数组 + 代理与反射 + 模块化编程 + 装饰器(ES7) { \"name\": \"quick_start\", \"version\": \"1.0.0\", \"description\": \"ES6快速入门\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"benchmark\":\"babel-node strconcat.benchmark.js\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"babel-cli\": \"^6.7.5\", \"babel-core\": \"^6.7.6\", \"babel-plugin-syntax-decorators\": \"^6.3.13\", \"babel-plugin-syntax-do-expressions\": \"^6.3.13\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.4\", \"babel-plugin-transform-runtime\": \"^6.7.5\", \"babel-polyfill\": \"^6.7.4\", \"babel-preset-es2015\": \"^6.6.0\", \"babel-preset-stage-0\": \"^6.5.0\", \"babel-preset-stage-1\": \"^6.5.0\", \"babel-preset-stage-2\": \"^6.5.0\", \"babel-preset-stage-3\": \"^6.5.0\", \"babel-register\": \"^6.7.2\", \"benchmark\": \"^2.1.0\", \"co\": \"^4.6.0\", \"eslint\": \"^2.7.0\", \"jake\": \"^8.0.12\", \"node-fetch\": \"^1.5.1\", \"thunkify\": \"^2.1.2\" }, \"babel\": { \"presets\": [ \"es2015\", \"stage-0\" ], \"plugins\": [ \"syntax-decorators\", \"transform-runtime\" ] }, \"dependencies\": { \"babel-runtime\": \"^6.6.1\" } } 手动执行其实就是用then方法，层层添加回调函数. function co(gen) { let ctx = this return new Promise(function(resolve, reject) { }) } 在返回的Promise对象里面，co先检查参数gen是否为生成器函数.如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。 function co(gen) { let ctx = this return new Promise(function(resolve, reject) { if (typeof gen === 'function') gen = gen.call(ctx) if (!gen || typeof gen.next !== 'function') return resolve(gen) }) } 'use strict' 接着，co将生成器函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。 function co(gen) { let ctx = this return new Promise(function(resolve, reject) { if (typeof gen === 'function') gen = gen.call(ctx) if (!gen || typeof gen.next !== 'function') return resolve(gen) onFulfilled() function onFulfilled(res) { let ret try { ret = gen.next(res) } catch (e) { return reject(e) } next(ret) } }) } 'use strict' 最后，就是关键的next函数，它会反复调用自身。 function next(ret) { if (ret.done) return resolve(ret.value) let value = toPromise.call(ctx, ret.value) if (value && isPromise(value)) return value.then(onFulfilled, onRejected) return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"')) } 'use strict' 上面代码中，next 函数的内部代码，一共只有四行命令。 第一行，检查当前是否为生成器函数的最后一步，如果是就返回。 第二行，确保每一步的返回值，是 Promise 对象。 第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。 处理并发的异步操作 co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。 // 数组的写法 co(function* () { let res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res); }).catch(onerror); // 对象的写法 co(function* () { let res = yield { 1: Promise.resolve(1), 2: Promise.resolve(2), }; console.log(res); }).catch(onerror); //下面是另一个例子。 co(function* () { let values = [n1, n2, n3]; yield values.map(somethingAsync); }); function* somethingAsync(x) { // do something async return y } 上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。 异步协程语法async...await Promise相当于python中的future,而async...await则是同样的语义.不过js的协程语法不用配合显式的声明事件循环.js的事件循环是隐式的.以异步访问为例: let bluebird = require('bluebird') let requestAsync = bluebird.promisify(require('request')) async function testAsync(){ try{ return await requestAsync('http://www.baidu.com') }catch(e){ console.log('error', e) } } let b = testAsync() b.then(function(r){ console.log('then') console.log(r.body) }) console.log('done') done then 百度一下，你就知道 #content{height:480px\\9}#m{top:260px\\9} #u1 a.mnav,#u1 a.mnav:visited{font-family:simsun} var hashMatch = document.location.href.match(/#+(.*wd=[^&].+)/);if (hashMatch && hashMatch[0] && hashMatch[1]) {document.location.replace(\"http://\"+location.host+\"/s?\"+hashMatch[1]);}var ns_c = function(){}; function h(obj){obj.style.behavior='url(#default#homepage)';var a = obj.setHomePage('//www.baidu.com/');} window._ASYNC_START=new Date().getTime(); 搜索设置|百度首页|登录注册新闻&#12288;网页&#12288;贴吧&#12288;知道&#12288;音乐&#12288;图片&#12288;视频&#12288;地图&#12288;文库&#12288;更多»输入法手写拼音关闭推荐&nbsp;:&nbsp;百度浏览器，打开网页快2秒！新闻hao123地图视频贴吧登录设置更多产品新&nbsp;闻　网&nbsp;页　贴&nbsp;吧　知&nbsp;道　音&nbsp;乐　图&nbsp;片　视&nbsp;频　地&nbsp;图输入法手写拼音关闭百科　文库　hao123&nbsp;|&nbsp;更多&gt;&gt;把百度设为主页把百度设为主页关于百度About Baidu&copy;2018&nbsp;Baidu&nbsp;使用百度前必读&nbsp;京ICP证030173号&nbsp; window.__async_strategy=2; var bds={se:{},su:{urdata:[],urSendClick:function(){}},util:{},use:{},comm : {domain:\"http://www.baidu.com\",ubsurl : \"http://sclick.baidu.com/w.gif\",tn:\"baidu\",queryEnc:\"\",queryId:\"\",inter:\"\",templateName:\"baidu\",sugHost : \"http://suggestion.baidu.com/su\",query : \"\",qid : \"\",cid : \"\",sid : \"\",indexSid : \"\",stoken : \"\",serverTime : \"\",user : \"\",username : \"\",loginAction : [],useFavo : \"\",pinyin : \"\",favoOn : \"\",curResultNum:\"\",rightResultExist:false,protectNum:0,zxlNum:0,pageNum:1,pageSize:10,newindex:0,async:1,maxPreloadThread:5,maxPreloadTimes:10,preloadMouseMoveDistance:5,switchAddMask:false,isDebug:false,ishome : 1},_base64:{domain : \"http://b1.bdstatic.com/\",b64Exp : -1,pdc : 0}};var name,navigate,al_arr=[];var selfOpen = window.open;eval(\"var open = selfOpen;\");var isIE=navigator.userAgent.indexOf(\"MSIE\")!=-1&&!window.opera;var E = bds.ecom= {};bds.se.mon = {'loadedItems':[],'load':function(){},'srvt':-1};try {bds.se.mon.srvt = parseInt(document.cookie.match(new RegExp(\"(^| )BDSVRTM=([^;]*)(;|$)\"))[2]);document.cookie=\"BDSVRTM=;expires=Sat, 01 Jan 2000 00:00:00 GMT\"; }catch(e){} if(!location.hash.match(/[^a-zA-Z0-9]wd=/)){document.getElementById(\"ftCon\").style.display='block';document.getElementById(\"u1\").style.display='block';document.getElementById(\"content\").style.display='block';document.getElementById(\"wrapper\").style.display='block';setTimeout(function(){try{document.getElementById(\"kw1\").focus();document.getElementById(\"kw1\").parentNode.className += ' iptfocus';}catch(e){}},0);} (function(){var index_content = $('#content');var index_foot= $('#ftCon');var index_css= $('head [index]');var index_u= $('#u1');var result_u= $('#u');var wrapper=$(\"#wrapper\");window.index_on=function(){index_css.insertAfter(\"meta:eq(0)\");result_common_css.remove();result_aladdin_css.remove();result_sug_css.remove();index_content.show();index_foot.show();index_u.show();result_u.hide();wrapper.show();if(bds.su&&bds.su.U&&bds.su.U.homeInit){bds.su.U.homeInit();}setTimeout(function(){try{$('#kw1').get(0).focus();window.sugIndex.start();}catch(e){}},0);if(typeof initIndex=='function'){initIndex();}};window.index_off=function(){index_css.remove();index_content.hide();index_foot.hide();index_u.hide();result_u.show();result_aladdin_css.insertAfter(\"meta:eq(0)\");result_common_css.insertAfter(\"meta:eq(0)\");result_sug_css.insertAfter(\"meta:eq(0)\");wrapper.show();};})(); window.__switch_add_mask=1; initPreload();$(\"#u,#u1\").delegate(\"#lb\",'click',function(){try{bds.se.login.open();}catch(e){}});if(navigator.cookieEnabled){document.cookie=\"NOJS=;expires=Sat, 01 Jan 2000 00:00:00 GMT\";} $(function(){for(i=0;i=5){$s.addClass('bdsugbg');}else{$s.removeClass('bdsugbg');}});}if(btnwr && btn){btnwr.on('mouseover',function(){btn.addClass('btnhover');}).on('mouseout',function(){btn.removeClass('btnhover');});}}}); (function(){var _init=false;window.initIndex=function(){if(_init){return;}_init=true;var w=window,d=document,n=navigator,k=d.f1.wd,a=d.getElementById(\"nv\").getElementsByTagName(\"a\"),isIE=n.userAgent.indexOf(\"MSIE\")!=-1&&!window.opera;(function(){if(/q=([^&]+)/.test(location.search)){k.value=decodeURIComponent(RegExp[\"\\x241\"])}})();(function(){var u = G(\"u1\").getElementsByTagName(\"a\"), nv = G(\"nv\").getElementsByTagName(\"a\"), lk = G(\"lk\").getElementsByTagName(\"a\"), un = \"\";var tj_nv = [\"news\",\"tieba\",\"zhidao\",\"mp3\",\"img\",\"video\",\"map\"];var tj_lk = [\"baike\",\"wenku\",\"hao123\",\"more\"];un = bds.comm.user == \"\" ? \"\" : bds.comm.user;function _addTJ(obj){addEV(obj, \"mousedown\", function(e){var e = e || window.event;var target = e.target || e.srcElement;if(target.name){ns_c({'fm':'behs','tab':target.name,'un':encodeURIComponent(un)});}});}for(var i = 0; i 0) {var wd = items[0], url = items[1],url = url + ( name === 'tj_map' ? encodeURIComponent('&' + wd + '=' + key) : ( ( url.indexOf('?') > 0 ? '&' : '?' ) + wd + '=' + encodeURIComponent(key) ) );target.href = url;} else {target.href = target.href.match(new RegExp('^http:\\/\\/.+\\.baidu\\.com'))[0];}}name && ns_c({'fm': 'behs','tab': name,'query': encodeURIComponent(key),'un': encodeURIComponent(bds.comm.user || '') });};}})();};if(window.pageState==0){initIndex();}})();document.cookie = 'IS_STATIC=1;expires=' + new Date(new Date().getTime() + 10*60*1000).toGMTString(); 使用util.promisify将同步接口改为异步 js虽然io都是非阻塞的,但它依然是同步的写法,要将接口改为协程函数,可以使用node标准库的util.promisify工具. import util from 'util' import fs from 'fs' const stat = util.promisify(fs.stat); stat('.').then((stats) => { // Do something with `stats` }).catch((error) => { // Handle the error. }); 常用的支持promise的第三方异步库 http客户端https://github.com/axios/axios http服务端https://github.com/koajs/koa 文件系统https://www.npmjs.com/package/fs-extra ormhttps://github.com/sequelize/sequelize Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/面向对象编程.html":{"url":"基础语法/面向对象编程.html","title":"面向对象编程","keywords":"","body":"面向对象编程 js与java不同,它是真正的面向对象编程(java是面向类型编程). 其实正经说js的叫做原型编程模型 js的设计者认为对象之间的相似性可以让面向对象的继承得到简化,通过直接复制一个与自己类似的对象,稍作修改就可以实现自己的对象了,真是朴素哇 我们要创建一个新的商品叫莎士比亚全集,那我们直接拿书做原型就行了 如我们前面说了那么多的特殊对象,他们就是原型,使用他们的时候本质上就是用new关键字做一份原型的拷贝对象. 在容器部分我们已经介绍过对象,这边我们从类开始介绍js的面向对象编程. 类的语法 从ES6开始关键字class可以用于定义类. class Vector { constructor(...attributes) { this._attributes = attributes } static FromArray(attributes_arr){ return new Vector(...attributes_arr) } get morn(){ return this._attributes.map((e)=>e**2).reduce((e_f,e_b)=>e_f+e_b) } get dimension(){ return this._attributes.length } copy(){ new new Vector(...this._attributes) } add(that){ if (that instanceof Vector){ if (this.dimension === that.dimension){ let input = this._attributes.map((e,i)=>e+that._attributes[i]) return new Vector(...input) }else{ throw \"two Vector must have the same morn\" } }else{ throw \"a Vector can only add a Vector\" } } } typeof Vector 'function' Object.is(Vector,Vector.prototype.constructor) true 通过类创建实例需要用new关键字 let v1= new Vector(1,2) v1 Vector { _attributes: [ 1, 2 ] } v1.dimension 2 Object.is(v1.constructor,Vector.prototype.constructor) true Object.is(v1.toString,Vector.prototype.toString) true Object.is(v1.add,Vector.prototype.add) true 上面代码定义了一个\"类\".可以看到里面有一个constructor方法,这就是构造方法,而this关键字则代表实例对象。 Point类除了构造方法,还定义了一个toString方法.注意,定义\"类\"的方法的时候,前面不需要加上function这个保留字,直接把函数定义放进去了就可以了.另外,方法之间不需要逗号分隔,加了会报错. 类的数据类型就是函数,类本身就指向构造函数. 构造函数的prototype属性在ES6的\"类\"上面继续存在.事实上类的所有方法都定义在类的prototype属性上面. 在类的实例上面调用方法,其实就是调用原型上的方法. 在类结构中的实例方法(除constructor以外) 都使用Object.defineProperty(obj, prop, descriptor)定义在prototype对象上面.而静态方法则是直接使用Object.defineProperty(obj, prop, descriptor)将方法直接绑定到构造函数.因此才可以使用get,set关键字定义取值函数和存值函数,从而固定一个字段的可访问情况. 所以类的新方法可以添加在prototype对象上面.Object.assign方法可以很方便地一次向类添加多个方法. 类的内部所有定义的方法,都是不可枚举的(enumerable). 实例的属性除非显式定义在其本身(即定义在this对象上),否则都是定义在原型上(即定义在class上).类的所有实例共享一个原型对象. Class表达式 与函数一样，Class也可以使用表达式的形式定义。 const MyClass = class { getClassName() { return cls.name } } MyClass.name 'MyClass' let inst = new MyClass() inst instanceof MyClass true 上面代码使用表达式定义了一个类.需要注意的是,这个类的名字是MyClass而不是cls,cls只在Class的内部代码可用,指代当前类. let inst = new MyClass() inst.getClassName() // Me cls.name // Referen evalmachine.:1 let inst = new MyClass(); ^ SyntaxError: Identifier 'inst' has already been declared at evalmachine.:1:1 at Script.runInThisContext (vm.js:123:20) at Object.runInThisContext (vm.js:312:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:188:13) at emit (internal/child_process.js:828:12) at process.internalTickCallback (internal/process/next_tick.js:72:19) inst.name 如果Class内部没用到的话可以省略. let person = new class { constructor(name) { this.name = name } sayName() { console.log(this.name) } }(\"张三\") person.sayName() // \"张三\" 张三 上面代码中,person是一个立即执行的Class的实例. 封装 ES6允许使用Class的取值函数(getter)和存值函数(setter)对某个属性设置存值函数和取值函数,拦截该属性的存取行为.这其实是Object.defineProperty(obj, prop, descriptor)的语法糖. class MyClass1 { constructor() { // ... } get prop() { return 'getter' } set prop(value) { console.log('setter: '+value) } } 'use strict' let inst1 = new MyClass1() inst1.prop = 123 setter: 123 123 inst1.prop 'getter' 存值函数和取值函数是设置在属性的descriptor对象上的. 静态方法 类相当于实例的原型,所有在类中定义的方法,都会被实例继承.如果在一个方法前加上static关键字就表示该方法不会被实例继承,而是直接通过类来调用.这就称为\"静态方法\".与python中一样,静态方法无法被实例使用 class Foo { static classMethod() { console.log('hello') } } Foo.classMethod() // 'hello' var foo = new Foo(); //foo.classMethod() hello 继承 ES6中的继承采用extend关键字实现 class B extends A { } extends关键字后面可以跟多种类型的值。只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性，因此A可以是任意函数 super()方法 和python一样,js也有super()方法来构造父类实例(相当于python中的super().__init__(self,*args)), ES6的继承机制是这样: 先创造父类的实例对象this（所以必须先调用super方法） 然后再用子类的构造函数修改this 获取父类 Object.getPrototypeOf方法可以用来从子类上获取父类.也可以在实例上获取其原型 Object.getPrototypeOf(foo) Foo {} Object.getPrototypeOf(Foo) [Function] this指针 js中有一个特殊的指针this,由于其语义存在歧义它是面向对象编程中的一个难点. this是使用Function对象中prototype的call方法调用函数时传递的第一个参数,它可以在函数调用时修改,在函数没有调用的时候,this的值是无法确定.我们前面已经说过js语境下类其实就是构造函数,或者说类其实就是函数.因此this指针是面相对象编程写法中绕不过去的一环.但因为在不同情况下this的含义不同,所以比价恶心. 具体点有这些情况: 场景 call的写法 this指代的对象 纯粹的函数调用 func.call(undefined,...args) 全局global,前端项目中为Window 对象中的方法 obj.method.call(obj,...args) 所在对象obj 构造函数 --- 每个构造函数在new之后都会返回一个对象，这个对象就是this,也就是说构造函数中的this指代其使用new构造出的实例 箭头函数 --- 外层this,也就是说箭头函数中没有自己的this,如果有闭包环境,那在其中的this实际是闭包命名空间的,如果没有那就指代全局global 无继承class中constructor方法 --- 指代类new操作创建的对象 有继承class中constructor方法 --- 指代类new操作创建的对象,需要注意要自定义的话this需要由super()创建.同时父类中的this会被指向子类创建的实例 let obj1 = { a: function() { console.log(this) }, b: { c: () => {console.log(this)} }, d:{ e:function(){ (()=>{console.log(this)})() } } } obj1.a() //没有使用箭头函数打出的是obj { a: [Function: a], b: { c: [Function: c] }, d: { e: [Function: e] } } obj1.b.c() //打出的是window对象！！ undefined obj1.d.e() //被闭包捕获 { e: [Function: e] } function getPrototypeChain(instance){ let protoChain = [] while (instance = Object.getPrototypeOf(instance)) { protoChain.push(instance) } protoChain.push(null) return protoChain } class F{ constructor(){ console.log(getPrototypeChain(this)) } } let f1 = new F() [ F {}, {}, null ] console.log(getPrototypeChain(f1)) [ F {}, {}, null ] class C extends F{ constructor(){ super() console.log(getPrototypeChain(this)) } } let c1 = new C() [ C {}, F {}, {}, null ] [ C {}, F {}, {}, null ] console.log(getPrototypeChain(c1)) [ C {}, F {}, {}, null ] 原型链机制 在语法部分结束之后这边来讲讲js语言机制中的最核心--原型机制. 大家肯定已经发现了js没有真正的类,其面相对象的实现靠的是原型机制,那这个原型机制是个什么呢?它又是怎么来的呢? 奇葩历史造就奇葩机制 js的的语言设计在早期可以说相当的让人无语,这也为诞生出原型链这种机制创造了条件. 在最开始的时候js被规划为一种脚本语言,只要能让浏览器可以与网页互动就行,按现在的软件工程理论来说,他们还挺先进的,做了个mvp,这个mvp就是早期的js.早期的js真的是能省就省.尤其在关键的地方也一点不含糊--js想要面相对象,但又觉得它太复杂,于是它省掉了类... 我们知道类是实例对象的模板,没有类怎么创建实例呢? js另辟蹊径,用所谓的原型来代替类的功能,为创建实例提供模板.什么意思呢?比如有个对象A,我们希望对象B有和对象A一样的字段,那怎么办? 使用类就是,我在A,B的基础上做一个模板T,这个T做的事情只是确定使用的它对象有什么字段,默认值时什么,然后A和B就通过同样的构造函数来由T创建. 使用原型就是:我们拿对象A做模板,复制一个B出来然后通过构造函数改B 额...简单理解可以认为A充当了模板,在某种意义上来说原型机制就是把继承链上的最后一个父对象当做了类的实现.因此严格意义上来说js只有继承没有类. 函数即构造函数 在早期为了省事儿,js把函数和构造函数直接混淆了: 直接调用函数就是调用函数 使用关键字new调用函数就是调用构造函数创建实例. 然后为了区分类和函数,js则口头的规定函数名大写的是构造函数,小写的是类... function A_constructor(x,y){ this.x=x this.y=y this.calcul_add = function(){ return this.a+this.b } return x+y } A_constructor(1,2) 3 let a = new A_constructor(1,2) a A_constructor { x: 1, y: 2, calcul_add: [Function] } let b = new A_constructor(3,4) b A_constructor { x: 3, y: 4, calcul_add: [Function] } a instanceof A_constructor true 我们可以看到a是类型A_constructor的实例,这意味着什么呢,js设计成了构造函数的名字就是类名,或者干脆说构造函数就是类了.真是够偷懒的... 使用原型模拟用类构造实例 使用构造函数创建下只有字段保存值得结构还行,绑定函数成为方法就蛋疼了,因为每次new都会创建一个内容一样的函数,这会消耗大量资源. 同时一些比如类属性就没办法实现了 Object.is(A_constructor,A_constructor) true Object.is(a.calcul_add,b.calcul_add) false 有什么办法可以解决这个问题呢?js就规定可以在构造函数上加一个字段prototype,即原型,我们就可以修改构造函数的这个字段,为由它构造的实例对象添加公有方法和共享属性.所有的实例对象也会有一个特殊字段__proto__用于保存这个构造函数上加的prototype对应的对象的引用. 访问对象字段时,在对象本身没找到对应字段时会去对象的__proto__找有没有对应的字段.都找不到才会返回undefined A_constructor.prototype A_constructor {} let A = { z:\"share\", calcul_mul:function(){ return this.x*this.y } } A_constructor.prototype = A { z: 'share', calcul_mul: [Function: calcul_mul] } let c = new A_constructor(10,11) let d = new A_constructor(11,12) c.z 'share' c.calcul_mul() 110 d.z 'share' d.calcul_mul() 132 c.z = \"test\" 'test' c.z 'test' d.z 'share' c.__proto__ { z: 'share', calcul_mul: [Function: calcul_mul] } Object.is(c.calcul_mul,d.calcul_mul) true 本地字段和原型字段 弄清了上面的过程,我们就知道该如何构造共享属性和共享方法,这其实就像python中的实例方法和类方法,我们可以定义好构造函数的原型,这个原型本身是共享的 如果要对所有这个类的实例(由这个构造函数构造的实例)操作变化就修改instance.__proto__.attr 如果要屏蔽掉对这个共享字段的引用就使用本地字段覆盖掉它instance.z = undefined 类似的如果字段是方法,那其实也是一样,不过需要注意的是this指代的是实例本身而非原型对象因此其字段的访问原理也是一致的. c.__proto__.z = \"testtest\" 'testtest' d.z 'testtest' c.z 'test' c.z = undefined c.z 需要注意,new方法生成的对象,它的原型是复制过来的而非引用,因此使用先前定义A而未给构造函数的prototype赋值,创建出来的实例a,b并不会有后添加的共享属性 a.z a.__proto__ A_constructor {} 使用构造函数这种方式构造实例对象有明显缺陷: 没有继承语法 this指针污染global环境,这个后面细聊. 使用原型规定类间的继承关系 js在早期设计的时候就没想过要让类之间可以有继承,毕竟对于一个文件解决的脚本语言来说继承太复杂了,结果后来就真香了.(js这么语言无处不体现着设计时的短视,现在竟然能火了也是不容易) 为了实现类间的继承关系,js使用了两条继承链. js中每一个对象都有__proto__属性,指向对应的构造函数的prototype属性.Class作为构造函数的语法糖,同时有prototype属性和proto属性. 子类的__proto__属性,表示构造函数的继承,总是指向父类. 子类prototype属性的__proto__属性,表示方法的继承,总是指向父类的prototype属性. 他们之间的关系可以看这张图: 也正是使用这一机制,js记录了继承链.让他有了面相对象编程中基本的继承.不得不说这种设计很精巧,但不按套路出牌. 构建继承链 Object.create(obj[,propertiesObject]可以由对象直接创建对象实例并将原对象放入__proto__,可以在propertiesObject的位置放入要添加到新创建对象的可枚举属性(即其本地枚举属性字段,而不是其原型链上的枚举属性),这种方式常用在继承上. 这种方式构造的对象一般也是用于为构造函数的prototype赋值的. 另一种方式为对象构造继承链的方式是使用Object.setPrototypeOf(obj, prototype),这个方法可以直接为一个对象指定原型 下面是一个构造继承的典型例子: function Animal(name,type){ this.name = name this.type = type } Animal.prototype = { move(){ console.log(`${this.name} is moving`) } } function Dog(name){ this.name = name Animal.call(this,this.name,\"Dog\") } Dog.prototype = Object.create(Animal.prototype) {} let d1 = new Dog(\"旺财\") d1.name '旺财' d1.move() 旺财 is moving d1 instanceof Dog true d1 instanceof Animal true 至此js关于原型链的部分就结束了,可以看出这个出发点是简化模型的设计并没有真的简化模型,这套设计的不直观对学习者带来的心智负担一点不比使用其他语言类似的类申明语法轻,其实现也相当晦涩. 下面的部分就是一些使用技巧了 构造callable的类 既然我们可以继承函数的构造函数即Function类,那我们当然可以针对这个搞点事情,比如像python中定义__call__一样的定义实例被调用时的行为. class Callable extends Function { constructor () { //继承 Function,让函数体为`return this.__call__(...args)`即调用实例的`__call__`方法 super('...args', 'return this.__call__(...args)') //将这个函数的this绑定到实例上,生成一个新的函数实例. let instance = this.bind(this) // 定义实例的属性 //将这个构造出来的实例作为绑定this的函数的原型 Object.setPrototypeOf(instance,this) //返回绑定this的函数对象 return instance } // 定义实例的`__call__`方法 __call__(...args){ return 20**2 } } 'use strict' let ca = new Callable() ca() 400 ca instanceof Callable true ca instanceof Function true 我们继承这个类看看如何: class Smth extends Callable{ constructor (x){ super() this.x = x //注意关键在将this绑定到`this.__proto__`这一步,否则`callable`的实例无法获取到smth实例中的this指针 let instance = this.__proto__.bind(this) Object.setPrototypeOf(instance,this) return instance } __call__(...args){ return this.x **2 } } let sm = new Smth(10) sm [Smth: bound anonymous] sm.x 10 sm() 100 sm instanceof Smth true sm instanceof Callable true sm instanceof Function true Mixin模式的实现 Mixin模式指的是将多个类的接口\"混入\"(mix in)另一个类,在python中我们可以使用多继承实现,但js没有多继承,那该如何实现呢? 只能往原型链中安顺序一个一个添加了,那如何 const ToArrayMixin = Sup=>class extends Sup { // 需要设置name属性,这个属性返回这个mixin的名字 static get name() { return \"ToArrayMixin\" } // 主要用于判断依赖的属性 constructor(...args){ super(...args) if(Object.is(this._attributes,undefined)){ throw new ReferenceError(\"Please define _attributes to the Class!\") } } // 用于定义方法 toArray(){ return Array.from(this._attributes) } } const ToStringMixin = Sup=>class extends Sup { static get name() { return \"ToStringMixin\" } constructor(...args){ super(...args) if(Object.is(this._attributes,undefined)){ throw new ReferenceError(\"Please define _attributes to the Class!\") } } toString() { let content_str = this._attributes.map((x)=>x.toString()).join(\",\\n\") return `${this.dimension}D-Vector:\\n[${content_str}]` } } class Vec extends ToStringMixin(ToArrayMixin(Vector)) { } let va = new Vec(1,2,3) va Vec { _attributes: [ 1, 2, 3 ] } va.dimension 3 va.toArray() [ 1, 2, 3 ] va.toString() '3D-Vector:\\n[1,\\n2,\\n3]' va instanceof Vector true va instanceof Vec true va instanceof ToArrayMixin evalmachine.:1 va instanceof ToArrayMixin; ^ TypeError: Function has non-object prototype 'undefined' in instanceof check at Function.[Symbol.hasInstance] () at evalmachine.:1:4 at Script.runInThisContext (vm.js:123:20) at Object.runInThisContext (vm.js:312:38) at run ([eval]:1002:15) at onRunRequest ([eval]:829:18) at onMessage ([eval]:789:13) at process.emit (events.js:188:13) at emit (internal/child_process.js:828:12) at process.internalTickCallback (internal/process/next_tick.js:72:19) 这种写法可以将方法混入进类,但使用instanceof无法检测到除了基类外用了哪些混入,算是遗憾,但我们可以用一个函数还专门用于判断是否使用了某个Mixin let Mixin = { getPrototypeChain: function(instance){ let protoChain = [] while (instance = Object.getPrototypeOf(instance)) { protoChain.push(instance) } protoChain.push(null) return protoChain }, getPrototypeChainName: function(instance){ let protoChain = this.getPrototypeChain(instance) return protoChain.map(x=>{ let result = null try{ result = x.constructor.name }catch (err){ result = x } return result }) }, hasMixin: function(instance,mixin_name){ return this.getPrototypeChainName(instance).filter(x=>x===mixin_name).length !==0 } } Mixin.getPrototypeChain(va) [ Vec {}, ToStringMixin {}, ToArrayMixin {}, Vector {}, {}, null ] Mixin.getPrototypeChainName(va) [ 'Vec', 'ToStringMixin', 'ToArrayMixin', 'Vector', 'Object', null ] Mixin.hasMixin(va,'ToStringMixin') true Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/模块化编程.html":{"url":"基础语法/模块化编程.html","title":"模块化编程","keywords":"","body":"模块化编程 ES6的模块功能并没有被node.js原生支持,因此我们会讲两种模块化的方式 一种是ES6的import/export方式 这种方式只能依靠babel转码实现 一种是node.js原生支持的commonjs方式 node.js原生支持的方式,在浏览器中需要使用使用babel转码y也可以用webpack来实现 import/export方式 ES6模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口 import命令用于输入其他模块提供的功能。 ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。 ES6采用的是编译时加载,即可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。 由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 从本质来讲,ES6模块加载的机制其实是--模块输出值的引用。 ES6模块的实现 规范是规范,js社区非常碎片化,目前ES6模块也还没在各个平台上完全支持,目前原生支持ES6模块的平台包括: 浏览器: Safari 10.1.+ Chrome 61.+ Firefox 54 + Edge 16.+ 这些浏览器只要在script标签中声明type=\"module\"字段就可以 import {addTextToBody} from './utils.js'; addTextToBody('Modules are pretty cool.'); 注意默认情况下是defer模式加载,我们可以手动给他改成async import {addTextToBody} from './utils.js'; addTextToBody('Modules are pretty cool.'); node: node13.2+ 其他平台在不改变源码的情况下就不得不借助第三方模块了.最常见的是babel的.如果觉得babel太重,只希望可以用ES6的模块语法,可以安装模块esm.使用的时候加上-r esm即可,比如node -r esm index.js export 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。 // profile.js export var firstName = 'Michael' export var lastName = 'Jackson' export var year = 1958 上面代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量。 export的写法，除了像上面这样，还有另外一种。 // profile.js var firstName = 'Michael'; var lastName = 'Jackson'; var year = 1958; export {firstName, lastName, year}; 个人更加喜欢第一种,并且比较推荐把要export的内容写在最后需要的写在前面 export命令除了输出变量，还可以输出函数或类(class),简单说对象都可以作为输出 export function multiply (x, y) { return x * y; }; 另外export输出的值是动态绑定的,即通过该接口，可以取到模块内部实时的值。 export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 export default 从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 export default function () { console.log('foo'); } 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 有了export default命令，输入模块时就非常直观了，以输入jQuery模块为例。 import $ from 'jquery' import import命令 使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。 import {firstName, lastName, year} from './profile'; 模块的整体加载 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 // circle.js export function area(radius) { return Math.PI * radius * radius; } export function circumference(radius) { return 2 * Math.PI * radius; } 现在，加载这个模块。 逐一加载 import { area, circumference } from './circle'; 整体加载 import * as circle from './circle'; as关键字 和python一样,js允许在模块输入或者输出时使用as关键字修改名字 输入: import * as circle from './circle' 输出: function add(x, y) { return x * y; }; export {add as plus}; 处理循环引用 循环引用意味着强耦合 python中循环引用模块是不允许的,除非在local作用域中引用.而事实上一些复杂的问题循环引用不可避免,否则会多出大量的结构代码. ES6模块是动态引用(lazy)，遇到模块加载命令import时，不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 因此,用好这个特性是可以循环引用的,但是当然,最好还是别循环引用 CommonJs方式 因为ES6标准太新,多数情况下可能还是要使用CommonJs的方式来完成团队协作 定义一个模块 在Node.js中,定义一个模块十分方便。我们以计算圆的面积和周长两个方法为例,来表现Node.js中模块的定义方式。 code/c15/circle.js \"use strict\" exports.area = (r)=>{ return Math.PI*Math.pow(r,2) } exports.circumference = (r) => { return 2 * Math.PI * r } exports.createpoint = function(x,y){ let point = function(x,y){ this.x = x this.y = y this.add = function(that){ let x = this.x+that.x let y = this.y+that.y return new point(x,y) } } //protopye中定义类方法和重载一些方法 point.prototype.toString=function(){ return '(' + this.x + ', ' + this.y + ')' } return new point(x,y) } 使用一个模块 const circle = require('./code/c15/circle.js') console.log( 'The area of a circle of radius 4 is'+ circle.area(4)) The area of a circle of radius 4 is50.26548245743669 undefined const circle = require('./code/c15/circle.js') let a = circle.createpoint(1,2) 'use strict' a { x: 1, y: 2, add: [Function] } r() TypeError: r is not a function at evalmachine.:3:1 at Object.exports.runInThisContext (vm.js:54:17) at run ([eval]:192:19) at onMessage ([eval]:63:41) at emitTwo (events.js:87:13) at process.emit (events.js:172:7) at handleMessage (internal/child_process.js:695:10) at Pipe.channel.onread (internal/child_process.js:440:11) 注意,定义模块的时候\"类\"是无法被定义的,所以必须使用在面向对象那节讲的ES6之前的那种写法,将类包在方法中 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"基础语法/特殊对象和特殊接口.html":{"url":"基础语法/特殊对象和特殊接口.html","title":"特殊对象和特殊接口","keywords":"","body":"特殊对象和特殊接口 这部分是对js接口的补充,js中规定了几个特殊的对象和全局方法,他们有点类似python中的标准库的意思,是js语言外的补充,包括 正则表达式对象RegExp 时间日期对象Date 定时接口setInterval和setTimeout 二进制数组对象ArrayBuffer RegExp对象 正则表达式,python中也有这个概念,只是它是字符串的一种,而且要用标准库re处理而已 正则表达式的语法就不多讲了,这边只说如何创建和与python的不同之处 创建 RegExp 对象的语法： let re = new RegExp(pattern, attributes) 或者: let re = / pattern / 这两种都可以,第二种写起来简单些 字符串的正则方法 match() replace() search() split() unicode支持 ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。 /^\\uD83D/.test('\\uD83D\\uDC2A') true 点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。 ES6新增了使用大括号表示Unicode字符 这种表示法在正则表达式中必须加上u修饰符，才能识别。 量词 使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。 /𠮷{2}/u.test('𠮷𠮷') true 预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。 /^\\S$/u.test('𠮷') true i修饰符 有些Unicode字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 /[a-z]/iu.test('\\u212A') true Date Date 对象用于处理日期和时间。 创建 Date 对象的语法： let myDate=new Date() Date对象方法: 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 定时操作 setTimeout(func,time)方法是定时程序,也就是在什么时间以后干什么,干完了就结束. setInterval(func,time)方法则是周期性执行程序,也就是过一定时间后执行什么,执行完后再过一样的时间再执行一直执行下去 需要注意的是time都是毫秒为单位 setTimeout(()=>{ console.log(\"延迟\") },2000) Timeout { _called: false, _idleTimeout: 2000, _idlePrev: TimersList { _idleNext: [Circular], _idlePrev: [Circular], _timer: Timer { '0': [Function: listOnTimeout], _list: [Circular] }, _unrefed: false, msecs: 2000, nextTick: false }, _idleNext: TimersList { _idleNext: [Circular], _idlePrev: [Circular], _timer: Timer { '0': [Function: listOnTimeout], _list: [Circular] }, _unrefed: false, msecs: 2000, nextTick: false }, _idleStart: 5881, _onTimeout: [Function], _timerArgs: undefined, _repeat: null, _destroyed: false, [Symbol(asyncId)]: 16, [Symbol(triggerAsyncId)]: 13 } 延迟 setInterval(()=>{ console.log(\"人类本质\") },2000) Timeout { _called: false, _idleTimeout: 2000, _idlePrev: TimersList { _idleNext: [Circular], _idlePrev: [Circular], _timer: Timer { '0': [Function: listOnTimeout], _list: [Circular] }, _unrefed: false, msecs: 2000, nextTick: false }, _idleNext: TimersList { _idleNext: [Circular], _idlePrev: [Circular], _timer: Timer { '0': [Function: listOnTimeout], _list: [Circular] }, _unrefed: false, msecs: 2000, nextTick: false }, _idleStart: 15559, _onTimeout: [Function], _timerArgs: undefined, _repeat: 2000, _destroyed: false, [Symbol(asyncId)]: 28, [Symbol(triggerAsyncId)]: 25 } 人类本质 人类本质 人类本质 ArrayBuffer 二进制数组(ArrayBuffer对象、TypedArray视图和DataView视图)这个接口的作用有点类似python中的bytes,array等是JavaScript操作二进制数据的一个接口.这些对象早就存在,属于独立的规格(2011年2月发布),ES6将它们纳入了ECMAScript规格，并且增加了新的方法. 这个接口的原始设计目的与WebGL项目有关.所谓WebGL就是指浏览器与显卡之间的通信接口,为了满足JavaScript与显卡之间大量的实时的数据交换,它们之间的数据通信必须是二进制的,而不能是传统的文本格式.文本格式传递一个32位整数,两端的JavaScript脚本与显卡都要进行格式转化,将非常耗时.这时要是存在一种机制,可以像C语言那样,直接操作字节,将4个字节的32位整数,以二进制形式原封不动地送入显卡,脚本的性能就会大幅提升. 二进制数组就是在这种背景下诞生的.它很像C语言的数组，允许开发者以数组下标的形式,直接操作内存,大大增强了JavaScript处理二进制数据的能力,使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信. 二进制数组由三类对象组成. arrayBuffer对象:代表内存之中的一段二进制数据,可以通过\"视图\"进行操作.\"视图\"部署了数组接口,这意味着可以用数组的方法操作内存. TypedArray视图:共包括9种类型的视图,比如Uint8Array(无符号8位整数)数组视图,Int16Array(16位整数)数组视图,Float32Array(32位浮点数)数组视图等等 DataView视图:可以自定义复合格式的视图,比如第一个字节是Uint8(无符号8位整数),第二/三个字节是Int16(16位整数),第四个字节开始是Float32(32位浮点数)等等,此外还可以自定义字节序. 简单说,ArrayBuffer对象代表原始的二进制数据,TypedArray视图用来读写简单类型的二进制数据,DataView视图用来读写复杂类型的二进制数据. TypedArray视图支持的数据类型一共有9种(DataView视图支持除Uint8C以外的其他8种) 数据类型 字节长度 含义 对应的C语言类型 Int8 1 8位带符号整数 signed char Uint8 1 8位不带符号整数 unsigned char Uint8C 1 8位不带符号整数(自动过滤溢出) unsigned char Int16 2 16位带符号整数 short Uint16 2 16位不带符号整数 unsigned short Int32 4 32位带符号整数 int Uint32 4 32位不带符号的整数 unsigned int Float32 4 32位浮点数 float Float64 8 64位浮点数 double 注意，二进制数组并不是真正的数组，而是类似数组的对象。 很多浏览器操作的API，用到了二进制数组操作二进制数据，下面是其中的几个。 File API XMLHttpRequest Fetch API Canvas WebSockets ArrayBuffer对象 ArrayBuffer对象代表储存二进制数据的一段内存,它不能直接读写,只能通过视图(TypedArray视图和DataView视图)来读写,视图的作用是以指定格式解读二进制数据 ArrayBuffer也是一个构造函数,可以分配一段可以存放数据的连续内存区域. let buf = new ArrayBuffer(32) buf ArrayBuffer { byteLength: 32 } 上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。 为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。 let dataView = new DataView(buf); dataView.getUint8(0) 0 上面代码对一段32字节的内存,建立DataView视图,然后以不带符号的8位整数格式,读取第一个元素,结果得到0.因为原始内存的ArrayBuffer对象,默认所有位都是0. 另一种TypedArray视图,与DataView视图的一个区别是它不是一个而是一组构造函数,代表不同的数据格式. let buffer = new ArrayBuffer(12) let x1 = new Int32Array(buffer) x1[0] = 1 let x2 = new Uint8Array(buffer) x2[0] = 2 x1[0] 2 上面代码对同一段内存，分别建立两种视图:32位带符号整数(Int32Array构造函数)和8位不带符号整数(Uint8Array构造函数).由于两个视图对应的是同一段内存,一个视图修改底层内存,会影响到另一个视图. TypedArray视图的构造函数,除了接受ArrayBuffer实例作为参数,还可以接受普通数组作为参数,直接分配内存生成底层的ArrayBuffer实例,并同时完成对这段内存的赋值 let typedArray = new Uint8Array([0,1,2]) typedArray.length 3 typedArray[0] = 5 typedArray Uint8Array [ 5, 1, 2 ] 上面代码使用TypedArray视图的Uint8Array构造函数,新建一个不带符号的8位整数视图.可以看到Uint8Array直接使用普通数组作为参数对底层内存的赋值同时完成. ArrayBuffer实例的属性方法 字段 说明 byteLength byteLength属性,返回所分配的内存区域的字节长度 slice(start,stop) slice方法,允许将内存区域的一部分,拷贝生成一个新的ArrayBuffer对象 ArrayBuffer对象的属性方法 isView(view) 返回一个布尔值,表示参数是否为ArrayBuffer的视图实例.这个方法大致相当于判断参数,是否为TypedArray实例或DataView实例 TypedArray视图| ArrayBuffer对象作为内存区域,可以存放多种类型的数据.同一段内存,不同数据有不同的解读方式,这就叫做\"view\"视图.ArrayBuffer有两种视图,一种是TypedArray视图,另一种是DataView视图.前者的数组成员都是同一个数据类型,后者的数组成员可以是不同的数据类型. ps:普通数组的操作方法和属性,对TypedArray数组完全适用 目前TypedArray视图一共包括9种类型,每一种视图都是一种构造函数.我们前面也见识过了 Int8Array：8位有符号整数，长度1个字节。 Uint8Array：8位无符号整数，长度1个字节。 Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。 Int16Array：16位有符号整数，长度2个字节。 Uint16Array：16位无符号整数，长度2个字节。 Int32Array：32位有符号整数，长度4个字节。 Uint32Array：32位无符号整数，长度4个字节。 Float32Array：32位浮点数，长度4个字节。 Float64Array：64位浮点数，长度8个字节。 这9个构造函数生成的数组,统称为TypedArray视图.它们很像普通数组都有length属性,都能用方括号运算符([])获取单个元素,所有数组的方法,在它们上面都能使用.普通数组与TypedArray数组的差异主要在以下方面 TypedArray数组的所有成员,都是同一种类型. TypedArray数组的成员是连续的,不会有空位. TypedArray数组成员的默认值为0.比如new Array(10)返回一个普通数组,里面没有任何成员,只是10个空位;new Uint8Array(10)返回一个TypedArray数组,里面10个成员都是0. TypedArray数组只是一层视图,本身不储存数据,它的数据都储存在底层的ArrayBuffer对象之中,要获取底层对象必须使用buffer属性. 构造TypedArray数组 TypedArray(buffer, byteOffset=0, length?) 同一个ArrayBuffer对象之上,可以根据不同的数据类型，建立多个视图. 视图的构造函数可以接受三个参数: 第一个参数(必需):视图对应的底层ArrayBuffer对象 第二个参数(可选):视图开始的字节序号,默认从0开始 第三个参数(可选):视图包含的数据个数,默认直到本段内存区域结束 // 创建一个8字节的ArrayBuffer let b = new ArrayBuffer(8) // 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾 let v1 = new Int32Array(b) // 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾 let v2 = new Uint8Array(b, 2) // 创建一个指向b的Int16视图，开始于字节2，长度为2 let v3 = new Int16Array(b, 2, 2) v1 Int32Array [ 0, 0 ] v2 Uint8Array [ 0, 0, 0, 0, 0, 0 ] v3 Int16Array [ 0, 0 ] 上面代码在一段长度为8个字节的内存(b)之上,生成了三个视图:v1、v2和v3.因此，v1、v2和v3是重叠的: v1[0]是一个32位整数,指向字节0～字节3; v2[0]是一个8位无符号整数,指向字节; v3[0]是一个16位整数,指向字节2～字节3 只要任何一个视图对内存有所修改,就会在另外两个视图上反应出来 注意,byteOffset必须与所要建立的数据类型一致,否则会报错 TypedArray(length) 视图还可以不通过ArrayBuffer对象,直接分配内存而生成 let f64a = new Float64Array(8) f64a[0] = 10 f64a[1] = 20 f64a[2] = f64a[0] + f64a[1] f64a Float64Array [ 10, 20, 30, 0, 0, 0, 0, 0 ] 上面代码生成一个8个成员的Float64Array数组(共64字节),然后依次对每个成员赋值.这时,视图构造函数的参数就是成员的个数.可以看到,视图数组的赋值操作与普通数组的操作毫无两样. TypedArray(typedArray) TypedArray数组的构造函数可以接受另一个TypedArray实例作为参数 let typedArray1 = new Int8Array(new Uint8Array(4)); 此时生成的新数组只是复制了参数数组的值,对应的底层内存是不一样的.新数组会开辟一段新的内存储存数据不会在原数组的内存之上建立视图. 如果想基于同一段内存构造不同的视图,可以采用下面的写法 let x = new Int8Array([1, 1]) let y = new Int8Array(x.buffer) TypedArray(arrayLikeObject) 构造函数的参数也可以是一个普通数组,然后直接生成TypedArray实例 let typedArray2 = new Uint8Array([1, 2, 3, 4]) 注意这时TypedArray视图会重新开辟内存,不会在原数组的内存上建立视图. 上面代码从一个普通的数组,生成一个8位无符号整数的TypedArray实例. TypedArray数组也可以转换回普通数组. let normalArray = Array.prototype.slice.call(typedArray2) 合并操作 TypedArray数组没有concat方法,如果想要合并多个TypedArray数组可以用下面这个函数 function concatenate(resultConstructor, ...arrays) { let totalLength = 0; for (let arr of arrays) { totalLength += arr.length } let result = new resultConstructor(totalLength) let offset = 0 for (let arr of arrays) { result.set(arr, offset) offset += arr.length } return result } concatenate(Uint8Array, Uint8Array.of(1, 2), Uint8Array.of(3, 4)) Uint8Array [ 1, 2, 3, 4 ] 字节序 字节序指的是数值在内存中的表示方式. let buffer = new ArrayBuffer(16) let int32View = new Int32Array(buffer) for (let i = 0; i 上面代码生成一个16字节的ArrayBuffer对象,然后在它的基础上建立了一个32位整数的视图.由于每个32位整数占据4个字节,所以一共可以写入4个整数,依次为0,2,4,6 如果在这段数据上接着建立一个16位整数的视图,则可以读出完全不一样的结果 let int16View = new Int16Array(buffer) for (let i = 0; i 由于每个16位整数占据2个字节,所以整个ArrayBuffer对象现在分成8段.然后由于x86体系的计算机都采用小端字节序(little endian),相对重要的字节排在后面的内存地址,相对不重要字节排在前面的内存地址,所以就得到了上面的结果. 比如一个占据四个字节的16进制数0x12345678,决定其大小的最重要的字节是12,最不重要的是78.小端字节序将最不重要的字节排在前面,储存顺序就是78563412大端字节序则完全相反,将最重要的字节排在前面,储存顺序就是12345678.目前，所有个人电脑几乎都是小端字节序,所以TypedArray数组内部也采用小端字节序读写数据,或者更准确的说按照本机操作系统设定的字节序读写数据. 这并不意味大端字节序不重要.事实上很多网络设备和特定的操作系统采用的是大端字节序.这就带来一个严重的问题--如果一段数据是大端字节序,TypedArray数组将无法正确解析,因为它只能处理小端字节序!为了解决这个问题JavaScript引入DataView对象,可以设定字节序. 下面是另一个例子。 // 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07] let buffer = new ArrayBuffer(4) let v1 = new Uint8Array(buffer) v1[0] = 2 v1[1] = 1 v1[2] = 3 v1[3] = 7 let uInt16View = new Uint16Array(buffer) // 计算机采用小端字节序 // 所以头两个字节等于258 if (uInt16View[0] === 258) { console.log('OK') // \"OK\" } // 赋值运算 uInt16View[0] = 255 // 字节变为[0xFF, 0x00, 0x03, 0x07] uInt16View[0] = 0xff05// 字节变为[0x05, 0xFF, 0x03, 0x07] uInt16View[1] = 0x0210// 字节变为[0x05, 0xFF, 0x10, 0x02] 下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。 const BIG_ENDIAN = Symbol('BIG_ENDIAN') const LITTLE_ENDIAN = Symbol('LITTLE_ENDIAN') function getPlatformEndianness() { let arr32 = Uint32Array.of(0x12345678) let arr8 = new Uint8Array(arr32.buffer) switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) { case 0x12345678: return BIG_ENDIAN case 0x78563412: return LITTLE_ENDIAN default: throw new Error('Unknown endianness') } } 总之与普通数组相比,TypedArray数组的最大优点就是可以直接操作内存,不需要数据类型转换.所以速度快得多. BYTES_PER_ELEMENT属性 每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。 Int8Array.BYTES_PER_ELEMENT // 1 Uint8Array.BYTES_PER_ELEMENT // 1 Int16Array.BYTES_PER_ELEMENT // 2 Uint16Array.BYTES_PER_ELEMENT // 2 Int32Array.BYTES_PER_ELEMENT // 4 Uint32Array.BYTES_PER_ELEMENT // 4 Float32Array.BYTES_PER_ELEMENT // 4 Float64Array.BYTES_PER_ELEMENT // 8 这个属性在TypedArray实例上也能获取，即有TypedArray.prototype.BYTES_PER_ELEMENT。 ArrayBuffer与字符串的互相转换 ArrayBuffer转为字符串,或者字符串转为ArrayBuffer,有一个前提即字符串的编码方法是确定的.假定字符串采用UTF-16编码(JavaScript的内部编码方式),可以自己编写转换函数. // ArrayBuffer转为字符串，参数为ArrayBuffer对象 function ab2str(buf) { return String.fromCharCode.apply(null, new Uint16Array(buf)) } // 字符串转为ArrayBuffer对象，参数为字符串 function str2ab(str) { let buf = new ArrayBuffer(str.length * 2)// 每个字符占用2个字节 let bufView = new Uint16Array(buf) for (let i = 0, strLen = str.length; i 溢出 不同的视图类型所能容纳的数值范围是确定的,超出这个范围就会出现溢出.比如8位视图只能容纳一个8位的二进制值,如果放入一个9位的值就会溢出. TypedArray数组的溢出处理规则,简单来说就是抛弃溢出的位,然后按照视图类型进行解释. let uint8 = new Uint8Array(1) uint8[0] = 256 uint8[0] // 0 uint8[0] = -1 uint8[0] // 255 上面代码中uint8是一个8位视图而256的二进制形式是一个9位的值100000000,这时就会发生溢出.根据规则只会保留后8位即00000000.uint8视图的解释规则是无符号的8位整数所以00000000就是0. 负数在计算机内部采用\"2的补码\"表示,也就是说将对应的正数值进行否运算,然后加1.比如-1对应的正值是1.进行否运算以后得到11111110,再加上1就是补码形式11111111.uint8按照无符号的8位整数解释11111111,返回结果就是255. 一个简单转换规则可以这样表示. 正向溢出(overflow):当输入值大于当前数据类型的最大值,结果等于当前数据类型的最小值加上余值,再减去1. 负向溢出(underflow):当输入值小于当前数据类型的最小值,结果等于当前数据类型的最大值减去余值,再加上1. 请看下面的例子。 let int8 = new Int8Array(1) int8[0] = 128 int8[0] // -128 int8[0] = -129 int8[0] // 127 上面例子中int8是一个带符号的8位整数视图,它的最大值是127,最小值是-128.输入值为128时,相当于正向溢出1.根据\"最小值加上余值,再减去1\"的规则就会返回-128;输入值为-129时相当于负向溢出1,根据\"最大值减去余值,再加上1\"的规则就会返回127. Uint8ClampedArray视图的溢出规则与上面的规则不同.它规定凡是发生正向溢出该值一律等于当前数据类型的最大值即255;如果发生负向溢出,该值一律等于当前数据类型的最小值即0. let uint8c = new Uint8ClampedArray(1) uint8c[0] = 256 uint8c[0] // 255 uint8c[0] = -1 uint8c[0] // 0 上面例子中uint8C是一个Uint8ClampedArray视图,正向溢出时都返回255,负向溢出都返回0. TypedArray.prototype.buffer TypedArray实例的buffer属性,返回整段内存区域对应的ArrayBuffer对象.该属性为只读属性. let a = new Float32Array(64) let b = new Uint8Array(a.buffer) 上面代码的a视图对象和b视图对象,对应同一个ArrayBuffer对象,即同一段内存. TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset byteLength属性返回TypedArray数组占据的内存长度,单位为字节.byteOffset属性返回TypedArray数组从底层ArrayBuffer对象的哪个字节开始.这两个属性都是只读属性 let b = new ArrayBuffer(8) let v1 = new Int32Array(b) let v2 = new Uint8Array(b, 2) let v3 = new Int16Array(b, 2, 2) v1.byteLength // 8 v2.byteLength // 6 v3.byteLength // 4 v1.byteOffset // 0 v2.byteOffset // 2 v3.byteOffset // 2 TypedArray.prototype.length length属性表示TypedArray数组含有多少个成员.注意将byteLength属性和length属性区分--前者是字节长度;后者是成员长度. let a = new Int16Array(8) a.length // 8 a.byteLength // 16 TypedArray.prototype.set() TypedArray数组的set方法用于复制数组(普通数组或TypedArray数组),也就是将一段内容完全复制到另一段内存. let a = new Uint8Array(8) let b = new Uint8Array(8) b.set(a); 上面代码复制a数组的内容到b数组,它是整段内存的复制,比一个个拷贝成员的那种复制快得多. set方法还可以接受第二个参数,表示从b对象的哪一个成员开始复制a对象. let a = new Uint16Array(8) let b = new Uint16Array(10) b.set(a, 2) 上面代码的b数组比a数组多两个成员,所以从b[2]开始复制 TypedArray.prototype.subarray() subarray方法是对于TypedArray数组的一部分,再建立一个新的视图. let a = new Uint16Array(8) let b = a.subarray(2,3) a.byteLength // 16 b.byteLength // 2 subarray方法的第一个参数是起始的成员序号,第二个参数是结束的成员序号(不含该成员),如果省略则包含剩余的全部成员.所以上面代码的a.subarray(2,3)意味着b只包含a[2]一个成员,字节长度为2 TypedArray.prototype.slice() TypeArray实例的slice方法,可以返回一个指定位置的新的TypedArray实例. let ui8 = Uint8Array.of(0, 1, 2) ui8.slice(-1) // Uint8Array [ 2 ] 上面代码中ui8是8位无符号整数数组视图的一个实例.它的slice方法可以从当前视图之中,返回一个新的视图实例. slice方法的参数,表示原数组的具体位置,开始生成新数组.负值表示逆向的位置即-1为倒数第一个位置,-2表示倒数第二个位置,以此类推. TypedArray.of() TypedArray数组的所有构造函数都有一个静态方法of用于将参数转为一个TypedArray实例. Float32Array.of(0.151, -8, 3.7) // Float32Array [ 0.151, -8, 3.7 ] 下面三种方法都会生成同样一个TypedArray数组 // 方法一 let tarr = new Uint8Array([1,2,3]) // 方法二 let tarr = Uint8Array.of(1,2,3) // 方法三 let tarr = new Uint8Array(3) tarr[0] = 0 tarr[1] = 1 tarr[2] = 2 TypedArray.from() 静态方法from接受一个可遍历的数据结构(比如数组)作为参数,返回一个基于这个结构的TypedArray实例. Uint16Array.from([0, 1, 2]) // Uint16Array [ 0, 1, 2 ] 这个方法还可以将一种TypedArray实例转为另一种 let ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2)) ui16 instanceof Uint16Array // true from方法还可以接受一个函数作为第二个参数,用来对每个元素进行遍历,功能类似map方法 Int8Array.of(127, 126, 125).map(x => 2 * x) // Int8Array [ -2, -4, -6 ] Int16Array.from(Int8Array.of(127, 126, 125), x => 2 * x) // Int16Array [ 254, 252, 250 ] 上面的例子中from方法没有发生溢出,这说明遍历是针对新生成的16位整数数组,而不是针对原来的8位整数数组.也就是说from会将第一个参数指定的TypedArray数组拷贝到另一段内存之中(占用内存从3字节变为6字节)然后再进行处理. 复合视图 由于视图的构造函数可以指定起始位置和长度,所以在同一段内存之中可以依次存放不同类型的数据,这叫做\"复合视图\" let buffer = new ArrayBuffer(24) let idView = new Uint32Array(buffer, 0, 1) let usernameView = new Uint8Array(buffer, 4, 16) let amountDueView = new Float32Array(buffer, 20, 1) 上面代码将一个24字节长度的ArrayBuffer对象，分成三个部分： 字节0到字节3：1个32位无符号整数 字节4到字节19：16个8位整数 字节20到字节23：1个32位浮点数 这种数据结构可以用如下的C语言描述： struct someStruct { unsigned long id; char username[16]; float amountDue; }; DataView视图 如果一段数据包括多种类型(比如服务器传来的HTTP数据),这时除了建立ArrayBuffer对象的复合视图以外还可以通过DataView视图进行操作. DataView视图提供更多操作选项,而且支持设定字节序.本来在设计目的上,ArrayBuffer对象的各种TypedArray视图是用来向网卡,声卡之类的本机设备传送数据的,所以使用本机的字节序就可以了;而DataView视图的设计目的是用来处理网络设备传来的数据,所以大端字节序或小端字节序是可以自行设定的. DataView视图本身也是构造函数,接受一个ArrayBuffer对象作为参数生成视图 DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]); 下面是一个例子。 let buffer = new ArrayBuffer(24); let dv = new DataView(buffer); DataView实例有以下属性,含义与TypedArray实例的同名方法相同. DataView.prototype.buffer:返回对应的ArrayBuffer对象 DataView.prototype.byteLength:返回占据的内存字节长度 DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始 DataView实例提供8个方法读取内存. getInt8:读取1个字节,返回一个8位整数. getUint8:读取1个字节,返回一个无符号的8位整数. getInt16:读取2个字节,返回一个16位整数. getUint16:读取2个字节,返回一个无符号的16位整数. getInt32:读取4个字节,返回一个32位整数. getUint32:读取4个字节,返回一个无符号的32位整数. getFloat32:读取4个字节,返回一个32位浮点数. getFloat64:读取8个字节,返回一个64位浮点数. 这一系列get方法的参数都是一个字节序号(不能是负数否则会报错),表示从哪个字节开始读取. let buffer = new ArrayBuffer(24) let dv = new DataView(buffer) // 从第1个字节读取一个8位无符号整数 let v1 = dv.getUint8(0) // 从第2个字节读取一个16位无符号整数 let v2 = dv.getUint16(1) // 从第4个字节读取一个16位无符号整数 let v3 = dv.getUint16(3) 上面代码读取了ArrayBuffer对象的前5个字节,其中有一个8位整数和两个十六位整数 如果一次读取两个或两个以上字节,就必须明确数据的存储方式,到底是小端字节序还是大端字节序.默认情况下DataView的get方法使用大端字节序解读数据,如果需要使用小端字节序解读,必须在get方法的第二个参数指定true. // 小端字节序 let v1 = dv.getUint16(1, true) // 大端字节序 let v2 = dv.getUint16(3, false) // 大端字节序 let v3 = dv.getUint16(3) DataView视图提供8个方法写入内存 setInt8:写入1个字节的8位整数 setUint8:写入1个字节的8位无符号整数 setInt16:写入2个字节的16位整数 setUint16:写入2个字节的16位无符号整数 setInt32:写入4个字节的32位整数 setUint32:写入4个字节的32位无符号整数 setFloat32:写入4个字节的32位浮点数 setFloat64:写入8个字节的64位浮点数 这一系列set方法接受两个参数:第一个参数是字节序号,表示从哪个字节开始写入;第二个参数为写入的数据.对于那些写入两个或两个以上字节的方法,需要指定第三个参数,false或者undefined表示使用大端字节序写入,true表示使用小端字节序写入. // 在第1个字节，以大端字节序写入值为25的32位整数 dv.setInt32(0, 25, false) // 在第5个字节，以大端字节序写入值为25的32位整数 dv.setInt32(4, 25) // 在第9个字节，以小端字节序写入值为2.5的32位浮点数 dv.setFloat32(8, 2.5, true) 如果不确定正在使用的计算机的字节序,可以采用下面的判断方式. let littleEndian = (function() { let buffer = new ArrayBuffer(2) new DataView(buffer).setInt16(0, 256, true) return new Int16Array(buffer)[0] === 256 })() 如果返回true就是小端字节序;如果返回false就是大端字节序. 二进制数组的应用 大量的Web API用到了ArrayBuffer对象和它的视图对象 AJAX 传统上服务器通过AJAX操作只能返回文本数据,即responseType属性默认为text.XMLHttpRequest第二版XHR2允许服务器返回二进制数据.这时分成两种情况: 如果明确知道返回的二进制数据类型,可以把返回类型(responseType)设为arraybuffer 如果不知道，就设为blob let xhr = new XMLHttpRequest() xhr.open('GET', someUrl) xhr.responseType = 'arraybuffer' xhr.onload = function () { let arrayBuffer = xhr.response // ··· } xhr.send() 如果知道传回来的是32位整数,可以像下面这样处理: xhr.onreadystatechange = function () { if (req.readyState === 4 ) { let arrayResponse = xhr.response let dataView = new DataView(arrayResponse) let ints = new Uint32Array(dataView.byteLength / 4) xhrDiv.style.backgroundColor = \"#00FF00\" xhrDiv.innerText = \"Array is \" + ints.length + \"uints long\" } } Canvas 网页Canvas元素输出的二进制像素数据,就是TypedArray数组 let canvas = document.getElementById('myCanvas') let ctx = canvas.getContext('2d') let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height) let uint8ClampedArray = imageData.data 需要注意的是上面代码的typedArray虽然是一个TypedArray数组,但是它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray.这个视图类型的特点就是专门针对颜色把每个字节解读为无符号的8位整数,即只能取值0～255,而且发生运算的时候自动过滤高位溢出.这为图像处理带来了巨大的方便. 举例来说如果把像素的颜色值设为Uint8Array类型,那么乘以一个gamma值的时候就必须这样计算: u8[i] = Math.min(255, Math.max(0, u8[i] * gamma)) 因为Uint8Array类型对于大于255的运算结果(比如0xFF+1)会自动变为0x00,所以图像处理必须要像上面这样算.这样做很麻烦而且影响性能.如果将颜色值设为Uint8ClampedArray类型计算就简化许多. pixels[i] *= gamma Uint8ClampedArray类型确保将小于0的值设为0,将大于255的值设为255.注意IE 10不支持该类型. WebSocket WebSocket可以通过ArrayBuffer发送或接收二进制数据. let socket = new WebSocket('ws://127.0.0.1:8081') socket.binaryType = 'arraybuffer' // Wait until socket is open socket.addEventListener('open', function (event) { // Send binary data let typedArray = new Uint8Array(4) socket.send(typedArray.buffer) }) // Receive binary data socket.addEventListener('message', function (event) { let arrayBuffer = event.data // ··· }) Fetch API Fetch API取回的数据就是ArrayBuffer对象. fetch(url) .then(function(request){ return request.arrayBuffer() }) .then(function(arrayBuffer){ // ... }) File API 如果知道一个文件的二进制数据类型,也可以将这个文件读取为ArrayBuffer对象. let fileInput = document.getElementById('fileInput') let file = fileInput.files[0] let reader = new FileReader() reader.readAsArrayBuffer(file) reader.onload = function () { let arrayBuffer = reader.result // ··· } 下面以处理bmp文件为例.假定file变量是一个指向bmp文件的文件对象,首先读取文件. let reader = new FileReader() reader.addEventListener(\"load\", processimage, false) reader.readAsArrayBuffer(file) 然后定义处理图像的回调函数:先在二进制数据之上建立一个DataView视图,再建立一个bitmap对象,用于存放处理后的数据,最后将图像展示在canvas元素之中. function processimage(e) { var buffer = e.target.result var datav = new DataView(buffer) var bitmap = {} // 具体的处理步骤 } 具体处理图像数据时,先处理bmp的文件头.具体每个文件头的格式和定义,请参阅有关资料. bitmap.fileheader = {} bitmap.fileheader.bfType = datav.getUint16(0, true) bitmap.fileheader.bfSize = datav.getUint32(2, true) bitmap.fileheader.bfReserved1 = datav.getUint16(6, true) bitmap.fileheader.bfReserved2 = datav.getUint16(8, true) bitmap.fileheader.bfOffBits = datav.getUint32(10, true) 接着处理图像元信息部分. bitmap.infoheader = {}; bitmap.infoheader.biSize = datav.getUint32(14, true) bitmap.infoheader.biWidth = datav.getUint32(18, true) bitmap.infoheader.biHeight = datav.getUint32(22, true) bitmap.infoheader.biPlanes = datav.getUint16(26, true) bitmap.infoheader.biBitCount = datav.getUint16(28, true) bitmap.infoheader.biCompression = datav.getUint32(30, true) bitmap.infoheader.biSizeImage = datav.getUint32(34, true) bitmap.infoheader.biXPelsPerMeter = datav.getUint32(38, true) bitmap.infoheader.biYPelsPerMeter = datav.getUint32(42, true) bitmap.infoheader.biClrUsed = datav.getUint32(46, true) bitmap.infoheader.biClrImportant = datav.getUint32(50, true) 最后处理图像本身的像素信息。 let start = bitmap.fileheader.bfOffBits bitmap.pixels = new Uint8Array(buffer, start) 至此图像文件的数据全部处理完成.下一步可以根据需要进行图像变形或者转换格式或者展示在Canvas网页元素之中. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/":{"url":"web前端技术/","title":"web前端技术","keywords":"","body":"web前端技术 web前端技术是指的让基于http协议的网页浏览器正确渲染网页的技术,通常分为如下几个部分: html,用于传输数据的超文本传输协议.网页的主体部分由他作为数据源 css,用于定义html中元素的样式 js,用于操作html中的元素用于渲染动态页面 js在前面已经介绍了,本部分则是介绍其他的方面,主要包括浏览器提供的DOM接口,css,前端项目的预编译技术,以及react Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/":{"url":"web前端技术/前端概览/","title":"前端概览","keywords":"","body":"前端概览 我们知道网络服务常见的有两种: C/S模式即客户端服务器模式 B/S模式即浏览器服务器模式 前端技术实际上特指B/S模式中用于定义与服务器交互方式和展示样式的技术. 本章的代码在项目TutorialForJavascript/frontend-basic中 本节的代码在C0中 B/S模式的结构 首先我们先明确B/S模式的主体和各自的功能边界,B/S模式只有两个主体: 服务器 提供供浏览器渲染的前端资源 接收与用户交互时用户通过浏览器中渲染的页面提交的请求数据 向浏览器发送业务需要的数据 浏览器 通过域名(hostname)找到对应的服务器ip并确定连接的路径 渲染通过http协议访问服务器获取到的前端资源 提供相应的事件和接口让前端资源渲染出来的页面可以满足交互需求. 可以看出B/S模式中前端资源是服务器和浏览器之间的媒介,服务器需要使用前端资源告诉浏览器要如何处理渲染,浏览器则负责将前端资源渲染成服务器指定的样子以供用户使用. 因此浏览器和服务器间必须建立一套规范来规定浏览器对前端资源的渲染行为和边界,以避免相互无法兼容. 最终各界统一使用html作为浏览器解析服务器端的标记语言,用css作为浏览器对html中构造的dom元素的样式渲染声明语言,用js作为浏览器可以执行的脚本语言.并使用html来规范浏览器支持渲染的行为和边界. 虽然到现在各个厂商的浏览器还不是接口,行为完全一致,但总体上讲已经相当一致了. HTML5 html5是目前最新的html规范,已经好几年了,但目前还没有做到所有浏览器平台都完整支持.前端社区这种现象很常见.但好在最常用的chrome和firefox比较激进,对HTML5的支持比较好,即便是一些废弃的提案也支持的不错.本文将基于html5展开. 前端项目的hello world! 前端项目提供展示和交互,无非不过可以分为: 使用html展示内容,并配合js监听操作以提供交互. 使用js配合与服务端的通信规范或获取本地资源接口获取用户需要的资源内容. 将获取到的资源内容在本地处理,之后在DOM中渲染出来展示. 本文的例子是一个前端项目的最简单样板(C0),实现了抓取github最新注册的用户的用户名,并展示出来的功能.有兴趣的可以看下. 本例子使用html中的fetch接口获取github公开restful api中需要的数据. 本部分内容 本部分介绍的规范包括: 前端应用页面规范 前端应用调用本地资源 前端应用与服务端的通信 前端应用使用ajax技术和fetch技术与服务端通信 应用缓存 服务端推送提醒给前端应用 前端应用使用websocket与服务端通信 前端应用使用grpc-web技术与服务端通信 前端应用间使用WebRTC进行端对端通信 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用页面规范/":{"url":"web前端技术/前端概览/前端应用页面规范/","title":"前端应用页面规范","keywords":"","body":"前端应用页面规范 本部分介绍浏览器用于展示和交互的接口边界. 网页浏览器恐怕是现在最成熟的客户端技术了,因此诞生了不少基于前端技术的客户端实现如electron. 这个部分熟练的话完全可以在这些客户端上复用这部分的技术. 前端页面使用html文件作为创建页面的资源,使用这些资源构造文档对象即DOM用于展示和提供交互. HTML和DOM html即超文本标记语言是web技术中相当重要的一个部分,是前端技术的基础,他的语法接近xml,其作用就是让所有浏览器可以以统一的方法解析网站请求得来的网页数据.另一方面也可以说它规定了http服务中功能的范围. html协议也定义了浏览器中处理html文本的统一方法,通过使用javascript调用相应的方法接口,可以对特定类型的元素渲染过程进行动态定义. HTML语法基本是XML的子集,它本身就是一个描述树状结构的纯文本,而这个被描述的树状结构就是DOM(Document Object Model),树的每个分支的终点都是一个节点(node),每个节点都包含着对象(objects).这个树状结构中的任意一个分叉(包括根)可以被称作元素(element).节点是元素但元素不一定是节点. 元素由3部分组成: 标签 用于表示元素开始位置和结束位置的符号,形如...,标签有两种,一种用于申明,通常没有结束符,它也不构成元素.另一种带结束符,总是成对出现 属性 在起始标签中定义的东西,通常是描述这个元素的一些基础信息用,形如... 内容 被标签包裹的部分被称为内容,内容可以是注释,文本,或者子元素 同时不同标签元素在html规范中都规定好了其合法的属性,子元素和可以用js调用的方法.这部分知识可以查看mozilla上的html文档和DOM及API文档查看. html的基本结构 html在语法上接近xml(是xml的子集),一个常见的html文本如下: 测试 我的第一个标题 我的第一个段落。 一个典型的html文件有如下部分: 最开始使用标签申明文件为html格式 html标签作为所有内容的根 head标签中定义这个DOM的元信息,包括使用什么编码,DOM标题是什么,使用的css,js文件位置等 body标签中定义这个DOM的主体 注意,有的地方会认为script应该放在body元素的末尾,这在html5中不是必须的,只要申明script属性为async=\"async\"效果就是一样.个人倾向于将其放在head中,因为脚本文件位置本来就是元信息. 本文没有考虑一些过时浏览器的支持问题,在我看来也没有必要考虑,因为过时的东西就该淘汰.如果一直迁就向下兼容,用户是没有动力更新的.这不利于技术的发展. 本文也只使用了mac下的chrome 71.0.3578.98版本进行代码测试.并不保证所有浏览器都效果一致 全局元素属性 全局属性可用于任何HTML元素(有些有适用范围),下表是到html5为止所有的全局属性 属性 描述 语法 限制 说明 id 规定元素的唯一id 同一个DOM中id必须唯一 常见的用法是通过css或者js定位到指定id的元素后进行进一步的处理 class 规定元素的一个或多个类名(引用样式表中的类). 在base,head,html,meta,param,script,style以及title中无效;同一元素可以有多个class;class值不能以数字开头 常见的用法是css或者js通过过滤器定位到相同的class后进行统一处理 title 规定有关元素的额外信息,这些信息通常会在鼠标移到元素上时显示一段工具提示文本 --- title属性常与form以及a元素一同使用,以提供关于输入格式和链接目标的信息.同时它也是abbr和 acronym元素的必需属性 dir 规定元素中内容的文本方向 ` rtl\">` 在base, br, frame, frameset, hr, iframe, param 以及script中无效 ltr为默认值,即从左向右的文本方向;rtl为从右向左的文本方向 data-* 用于存储页面或应用程序的私有定制数据 --- *可以使是用户自己定义的任何内容,常用于让js获取后创建动态效果 style 规定元素的行内CSS样式 --- 不建议使用这种方式定义样式,样式还是用css文件定义(外部样式)更加靠谱 hidden 规定元素仍未或不再相关 --- hidden属性是布尔属性,如果设置该属性,则有这个属性的元素不会被渲染出来 tabindex 规定元素的tab键次序 safari浏览器不支持该属性,同时只有a,area,button,input,object,select以及textarea支持tabindex属性 这个属性通常用于导航栏 accesskey 规定激活元素的快捷键 Opera浏览器不支持该属性,同时只有a,area,button,input,label,legend和textarea lang 规定元素内容的语言 在base,br,frame,frameset,hr,iframe,param以及script中无效 这个标签并没有什么特殊效果,只是利于seo. translate 规定是否应该翻译元素内容 ` no\">` 目前没有浏览器支持 --- spellcheck 规定是否对元素进行拼写和语法检查 ` false\">` 支持的该功能的元素包括:input元素中的文本值(非密码);textarea元素中的文本,有contenteditable属性的元素中的文本 --- contenteditable 规定元素内容是否可编辑 ` false\">` --- 如果元素未设置contenteditable属性,那么元素会从其父元素继承该属性 contextmenu 规定元素的上下文菜单.上下文菜单在用户点击元素时显示 目前只有firefox支持 --- draggable 规定元素是否可拖动. ` false auto\">` --- 链接和图像默认是可拖动的,draggable属性常用在拖放操作中,值为auto意味使用浏览器默认行为 dropzone 规定在拖动被拖动数据时是否进行复制,移动或链接. ` false auto\">` --- 可以看w3c上的例子 元素样式与css 虽然浏览器会给每个元素一个默认的样式,但显然默认样式并不能满足我们的需求,我们需要告诉浏览器如何渲染我们前端项目中的各个元素,这就是css的作用了. 目前支持的css属性可以在mozilla上找到我们并不需要记这些,会查表找到要用的即可. 样式引入 css有3种样式引入方式: 在html中在要渲染的元素的style属性中定义(内联样式 Inline Style) 在html中在style元素中定义(内部样式 Internal style sheet) 在css文件中定义,使用link元素引入该css文件.(外部样式 External style sheet) 样式加载顺序 css的加载顺序如下: (外部样式)External style sheet 有种特殊情况,就是如果外部样式放在内部样式的后面,则外部样式将覆盖内部样式. 选择器优先级 选择器可以使用id,标签,或者类来进行选择,因此也会出现一个元素被多个选择器选中的情况,那么浏览器会以什么顺序来加载css呢? 浏览器中的渲染优先级通常是这样: 内联样式表的权值>ID 选择器的权值>Class 类选择器的权值> HTML 标签选择器的权值 另外可以在属性最后添加!important，申明最大优先级 css基本语法 css是声明式语法,其的基本语法结构如下: selector { declaration1; declaration2; ... declarationN } 可以看到其基本组成是选择器和声明语句,一个选择器下的申明语句使用大括号包裹,各自使用;分隔 选择器 选择器可以有如下几种: 特定标签的元素,使用标签名直接选择,如p 特定属性的元素,如果希望找到特定标签有特定属性的元素,可以使用标签名+[+属性名+]的形式,如p[title],如果不关心标签是什么,可以使用通配符*代替标签名或者直接不写通配符,如[title];除了可以查找属性,还可以查找带特定值得属性,如[title=hello]表示查找title属性为hello的元素,具体的语法如下: 选择器 描述 attribute 用于选取带有指定属性的元素 attribute=value 用于选取带有指定属性和值的元素。 attribute~=value 用于选取属性值中包含指定词汇的元素。 attribute I= value 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 attribute^=value 匹配属性值以指定值开头的每个元素。 attribute$=value 匹配属性值以指定值结尾的每个元素。 attribute*=value 匹配属性值中包含指定值的每个元素。 特定id的元素,使用#+id的值直接选择,如#id1 特定class属性的元素,使用.+class的值直接选择,如.class1,如果要选择特定标签下相同的类,可以使用标签名.class值的形式,如p.class1;类选择可以串联,我们知道一个元素可以有多个类,如果要筛选满足特定类组合的元素,可以如.class1.class2 伪类伪元素,使用:这是固定的几种特殊类或者元素,属于特殊用法,可以看w3c上的伪类和伪元素介绍 除了这种特定的选择器外,还可以指定子元素,相邻元素,后代元素用于筛选,其语法是: 相邻元素指--紧接在另一元素后的元素,且二者有相同父元素.使用+号,如h1 + p 子元素指--指在父元素下一级的元素,使用>号,如h1 > strong 后代元素指--父元素下任意一级的元素,使用空格`,如h1 em` 这些选择器的规则可以自由组合,比如h1 .class1 同时选择器可以分组以合并重复的申明,比如 h1 {color:blue;} h2 {color:blue;} h3 {color:blue;} h4 {color:blue;} h5 {color:blue;} h6 {color:blue;} 可以写作 h1, h2, h3, h4, h5, h6 {color:blue;} 在选择器组中不同的选择器使用,隔开 声明语句 每条声明由一个属性和一个值组成 属性(property)是我们希望设置的样式属性(style attribute),每个属性有一个值.属性和值被冒号分开. selector {property: value} 使用javascript操作dom元素 前文说过js是浏览器端通用的脚本语言,用于浏览器的js和node.js中的虽然语法是一致的,但环境并不一致,js要操作的是DOM对象,因此需要调用浏览器提供的相关接口,明显这在node中是不存在的.全部的接口可以在这里看到.一个更通用的版本是w3c的文档也可以作为参考 比较常用的是如下4个全局对象: Window 一个包含DOM文档的窗口,其document属性指向窗口中载入的DOM文档.使用document.defaultView或者Window.window属性可以获取指定文档所在窗口. 全局变量window为当前文档所在窗口,这个对象通常包含着一些浏览器操作,比如计时这些. Document 表示任何在浏览器中已经加载好的网页,并作为一个入口去操作网页内容(也就是DOM tree).DOM tree包括像body,table这样的还有其他的元素.它提供了全局操作document的功能,像获取网页的URL和在document里创建一个新的元素. 全局变量document则表示当前的网页DOM,它通常用于构造/改造当前的DOM结构或者元素属性.常见的操作包括: 方法接口 说明 createElement() 创建元素节点。 createTextNode() 创建文本节点。 document.importNode(node:Node object, deep:bool) 在dom中克隆一个外部元素进去 appendChild() 把新的子节点添加到指定节点。 insertBefore(newItem,existingItem) 在指定的子节点前面插入新的子节点。 getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 removeChild() 删除子节点。 replaceChild() 替换子节点。 createAttribute() 创建属性。 getAttribute() 返回指定的属性值。 setAttribute() 把指定属性设置或修改为指定的值 常见的属性包括: 属性 说明 innerHTML 节点（元素）的html文本值 parentNode 节点（元素）的父节点 childNodes 节点（元素）的子节点 attributes 节点（元素）的属性节点 textContent 节点的 (元素)的文本内容 除了方法接口和属性,还有就是元素的事件,常见的有: 事件 说明 onchange 域的内容被改变。 onclick 当用户点击某个对象时调用的事件句柄。 ondblclick 当用户双击某个对象时调用的事件句柄。 onerror 在加载文档或图像时发生错误。 onfocus 元素获得焦点。 onkeydown 某个键盘按键被按下。 onkeypress 某个键盘按键被按下并松开。 onkeyup 某个键盘按键被松开。 onload 一张页面或一幅图像完成加载。 onmousedown 鼠标按钮被按下。 onmousemove 鼠标被移动。 onmouseout 鼠标从某元素移开。 onmouseover 鼠标移到某元素之上。 onmouseup 鼠标按键被松开。 onselect 文本被选中。 onsubmit 确认按钮被点击。 onunload 用户退出页面。 其余的事件可以在w3c的相关文档中找到 本部分包括: 元数据获取 语义化标签与页面布局 模板标签 交互事件 作图接口 浏览器history --> Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用页面规范/元数据获取.html":{"url":"web前端技术/前端概览/前端应用页面规范/元数据获取.html","title":"元数据获取","keywords":"","body":"元数据获取 浏览器除了提供了DOM操作,也提供了窗口,浏览器本身的操作接口,这些接口可能在网页开发中用处不大,但在基于web技术的客户端项目中非常有价值. 本节的代码在C1-S1中 Navigator对象 Navigator对象包含有关浏览器的信息,主要包括: 属性 描述 appCodeName 返回浏览器的代码名。 appMinorVersion 返回浏览器的次级版本。 appName 返回浏览器的名称。 appVersion 返回浏览器的平台和版本信息。 browserLanguage 返回当前浏览器的语言。 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass 返回浏览器系统的 CPU 等级。 onLine 返回指明系统是否处于脱机模式的布尔值。 platform 返回运行浏览器的操作系统平台。 systemLanguage 返回 OS 使用的默认语言。 userAgent 返回由客户机发送服务器的 user-agent 头部的值。 userLanguage 返回 OS 的自然语言设置。 navigator.geolocation获取地理位置 这个接口是html5中新增的,可以获取当前浏览器的所在地理位置坐标 通常光有经纬度没有意义,需要搭配地图接口,遗憾的是目前似乎已经没有免费的对应接口了 Screen 对象 Screen 对象包含有关客户端显示屏幕的信息,每个Window对象的screen属性都引用一个Screen对象.Screen对象中存放着有关显示浏览器屏幕的信息.这些信息可以用于做自适应页面.主要包括: 属性 描述 availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)。 availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 bufferDepth 设置或返回调色板的比特深度。 colorDepth 返回目标设备或缓冲器上的调色板的比特深度。 deviceXDPI 返回显示屏幕的每英寸水平点数。 deviceYDPI 返回显示屏幕的每英寸垂直点数。 fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑。 height 返回显示屏幕的高度。 logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数。 logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数。 pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）。 updateInterval 设置或返回屏幕的刷新率。 width 返回显示器屏幕的宽度。 Location 对象 Location 对象包含有关当前 URL的信息.表示那个窗口中当前显示的文档的 Web 地址.它的href属性存放的是文档的完整URL,其他属性则分别描述了 URL的各个部分. 除了设置location或location.href用完整的URL替换当前的URL之外,还可以修改部分URL,只需要给Location对象的其他属性赋值即可.这样做就会创建新的 URL,其中的一部分与原来的URL不同,浏览器会将它装载并显示出来.例如假设设置了Location对象的hash属性,那么浏览器就会转移到当前文档中的一个指定的位置.同样如果设置了search属性,那么浏览器就会重新装载附加了新的查询字符串的URL. 除了 URL 属性外，Location 对象的reload()方法可以重新装载当前文档,replace()可以装载一个新文档而无须为它创建一个新的历史记录,也就是说,在浏览器的历史列表中,新文档将替换当前文档. 属性 描述 hash 设置或返回从井号(#)开始的URL(锚) host 设置或返回主机名和当前 URL 的端口号 hostname 设置或返回当前 URL 的主机名 href 设置或返回完整的 URL pathname 设置或返回当前 URL 的路径部分 port 设置或返回当前 URL 的端口号 protocol 设置或返回当前 URL 的协议 search 设置或返回从问号(?)开始的URL(查询部分) 方法 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用页面规范/语义化标签与页面布局.html":{"url":"web前端技术/前端概览/前端应用页面规范/语义化标签与页面布局.html","title":"语义化标签与页面布局","keywords":"","body":"语义化标签与页面布局 在html5之前,html通常使用无意义的div标签构造结构,然后使用css对不同class的div标签做样式声明.而现在,html5更加强调语义化标签.加上css3的flex布局模式,前端项目可以更好的适应多平台. 本节的代码在C1-S2中 为什么要使用语义化标签 为了在没有CSS的情况下页面也能呈现出很好地内容结构,代码结构 提升用户体验,例如title、alt用于解释名词或解释图片信息,label标签的活用 有利于SEO,可以和搜索引擎建立良好沟通,有助于爬虫抓取更多的有效信息,爬虫依赖于标签来确定上下文和各个关键字的权重 方便其他设备解析(如屏幕阅读器,盲人阅读器,移动设备)以意义的方式来渲染网页 代码优雅便于团队开发和维护.语义化更具可读性,是下一步吧网页的重要动向,遵循W3C标准的团队都遵循这个标准,可以减少差异化 如何做到尽量语义化 尽可能少的使用无语义的标签div和span.在html5之前我们都是用div配合css来操作页面样式的,到了现在很多前端样式框架也是这个风格.我们应该尽量将其改为语义化标签. 在语义不明显时,即可以使用div或者p时,尽量用p,因为p在默认情况下有上下间距,对兼容特殊终端有利 不要使用纯样式标签,如:b,font,u等，改用css设置.需要强调的文本,可以包含在strong或者em标签中(浏览器预设样式,能用CSS指定就不用他们),strong默认样式是加粗(不要用b),em是斜体(不用i) 使用表格时,标题要用caption,表头用thead,主体部分用tbody包围，尾部用tfoot包围.表头和一般单元格要区分开,表头用th,单元格用td; 表单域要用fieldset标签包起来,并用legend标签说明表单的用途; 每个input标签对应的说明文本都需要使用label标签,并且通过为input设置id属性,在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 语义化布局的语义化标签 即便是有了语义化标签,布局依然是css的工作,但有了语义化标签,那么描述起来就会方便许多.我们可以使用css3中的Flex布局实现符合语义的布局. 下图是常见语义化标签的布局位置. 标签 说明 article 定义文章 aside 定义文章的侧边栏 figure 一组媒体对象以及文字 figcaption 定义 figure 的标题 footer 定义页脚 header 定义页眉 hgroup 定义对网页标题的组合 nav 定义导航 section 定义文档中的区段 time 定义日期和时间 dialog 定义一个对话框 header 定义文章顶部 css的盒子模型 在讲flex布局前我们先来了解下css的盒子模型. 所有HTML元素可以看作盒子,在CSS中,box model这一术语是用来设计和布局时使用. CSS盒模型本质上是一个盒子,封装周围的HTML元素,它包括:边距,边框,填充,和实际内容. 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素. 下面的图片说明了盒子模型(Box Model): Margin(外边距) 清除边框外的区域,外边距是透明的.使用的属性为margin,其形式语法: [ | | auto ]{1,4}它接受1~4个可选参数,每个参数用空格隔开. 当只有一个值时,这个值会被指定给全部的四个边. 当两个值时,第一个值被匹配给上和下,第二个值被匹配给左和右. 当三个值时,第一个值被匹配给上,第二个值被匹配给左和右, 第三个值被匹配给下. 当四个值时,会依次按上,右,下,左的顺序匹配(即顺时针顺序) 每个参数可以选择的值有3种: 指定一个固定的宽度,可以为负数.通常使用单位px即像素 相对于该元素的包含块的宽度(相对于该块的百分比).该值可以为负数. auto浏览器会自动选择一个合适的margin来应用.它可以用于将一个块居中. Border(边框) 围绕在内边距和内容外的边框.我们可以定义边框的颜色,形状,粗细,阴影,角的弧度,甚至使用渐变或者图片构造边框. 形状border-style 要使用边框必须要指定边框的样式,css支持的样式有: border-style等价于四个角的弧度定义的简写形式即:border-top-style,border-right-style,border-left-style,border-bottom-style. border-style其形式语法为: {1,4} where = none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset 即也是允许1到4个值,每个位置取值范围就在枚举none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset中 当只有一个值时,这个值会被指定给全部的四个边. 当两个值时,第一个值指定横线,第二个指定竖线. 当三个值时,第一个值为上,第二个值被匹配给左和右的边, 第三个值被匹配给下. 当四个值时,会依次按上,右,下,左的顺序匹配(即顺时针顺序) 粗细border-width 要使用边框必须要指定边框的粗细, border-width等价于四个角的弧度定义的简写形式即:border-top-width,border-right-width,border-left-width,border-bottom-width. border-width设定边框的粗细有三种指定方式: 固定粗细 这时候可以使用1至4个值来定义四边的粗细,每一位的值通常使用px即像素来作为单位: 当只有一个值时,这个值会被指定给全部的四个边. 当两个值时,第一个值指定横线,第二个指定竖线. 当三个值时,第一个值为上,第二个值被匹配给左和右的边, 第三个值被匹配给下. 当四个值时,会依次按上,右,下,左的顺序匹配(即顺时针顺序) 使用全局关键字 全局关键字不是所有浏览器都支持,不建议使用,在mozilla的教程中,全局关键字包括3个inherit(继承父元素的),initial(初始值),unset(不设置).此处不多介绍,不建议用. 使用预设粗细关键字 此时只可以有一个值,为thin | medium | thick中的一个. 值 含义 thin 细边线 medium 中等边线 thick 粗边线 角弧度border-radius border-radius允许你设置元素的外边框圆角.当使用一个半径时确定一个圆形,当使用两个半径时确定一个椭圆.这个(椭)圆与边框的交集形成圆角效果. border-radius等价于四个角的弧度定义的简写形式即:border-top-left-radius,border-top-right-radius,border-bottom-right-radius,border-bottom-left-radius. 我们当然可以单独定义各个角的弧度,但个人更喜欢直接使用border-radius定义全部. 其形式语法为: {1,4} [ / {1,4} ]? where = | 它可以有1至4个值: 当只有一个值时,表示边框四角的圆角半径 当两个值时,第一位表示左上和右下,第二位表示左下和右上 当三个值时,左上,右上和左下,右下 当四个值时,会依次按左上,右上,右下,左下的顺序匹配(即顺时针顺序) 每一位可以取两种值 指定一个固定的半径或用/分隔的两个值分别为半长轴和半短轴.不可以为负数.通常使用单位px即像素 使用百分比表示半径或半长轴半短轴的长度.水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度. 颜色border-color css中表示颜色的常见方式有3种: 使用16进制表示RGB色代码,形式为# 使用预定义的颜色枚举,如red,green,具体有哪些可以查看w3c上的表格 使用rgba颜色,其语法为rgba(red:int, green:int, blue:int, alpha:float),alpha参数是介于0.0(完全透明)与1.0(完全不透明)的数字 border-color等价于四个角的弧度定义的简写形式即:border-top-color,border-right-color,border-left-color,border-bottom-color. 使用border-color定义边框颜色有两种用法: 固定颜色 这时候可以使用1至4个值来定义四边的颜色: 当只有一个值时,这个值会被指定给全部的四个边. 当两个值时,第一个值指定横线,第二个指定竖线. 当三个值时,第一个值为上,第二个值被匹配给左和右的边, 第三个值被匹配给下. 当四个值时,会依次按上,右,下,左的顺序匹配(即顺时针顺序) 使用全局关键字 全局关键字不是所有浏览器都支持,不建议使用,颜色可以使用的全局关键字有inherit(继承父元素的) 阴影box-shadow和-webkit-box-shadow 该属性可以让几乎所有元素的边框产生阴影.如果元素同时设置了border-radius即角弧度,阴影也会有圆角效果. 其形式语法为: none | [inset? && [ ? ? ? ] ]# 他有两种用法: 固定的阴影形式 这时使用2至5个参数, 当只有两个值时,第一个为x偏移量,第二个为y偏移量 当三个值时,第一个为x偏移量,第二个为y偏移量,第三个值如果是颜色信息则是阴影颜色,如果是1px这样的长度数据,则表示阴影的模糊半径 当四个值时,第一个为x偏移量,第二个为y偏移量,第三个阴影的模糊半径,第四个值如果是颜色信息则是阴影颜色,如果是1px这样的长度数据,则表示阴影扩散半径 当五个值时,第一个为x偏移量,第二个为y偏移量,第三个阴影的模糊半径,第四个表示阴影扩散半径,第五个值表示阴影颜色 使用全局关键字 全局关键字不是所有浏览器都支持,不建议使用,在mozilla的教程中,全局关键字包括3个inherit(继承父元素的),initial(初始值),unset(不设置).此处不多介绍,不建议用. 使用图片构造边框border-image border-image属性允许在元素的边框上绘制图像.这使得绘制复杂的外观组件更加简单,也不用在某些情况下使用九宫格了. 使用border-image时,其将会替换掉border-style属性所设置的边框样式. border-image属性是如下子属性的简写. border-image-source边框图像资源,可以是 url(xxxx)表示图片源文件位置 repeating-linear-gradient(angle, side-or-corner, color-stop...)定义重读渐变 属性 描述 angle 定义渐变的角度方向.从0deg到360deg,默认为180deg. side-or-corner 指定线性渐变的起始位置.由两个关键字组成:第一个为指定水平位置(left或right),第二个为指定垂直位置(top或bottom).顺序是随意的,每个关键字都是可选的. color-stop1, color-stop2,... 指定渐变的起止颜色,由颜色值,停止位置(可选,使用百分比指定)组成.也或者使用transparent表示透明化 + `linear-gradient(direction, color-stop1, color-stop2, ...)`定义线性渐变 属性 描述 direction 定义渐变的角度方向,由两个关键字组成:第一个为指定水平位置(left或right),第二个为指定垂直位置(top或bottom) color-stop1, color-stop2,... 用于指定渐变的起止颜色 + `radial-gradient(shape size at position, start-color, ..., last-color)`定义径向渐变 属性: + `shape`确定圆的类型: + `ellipse`(默认):指定椭圆形的径向渐变; + `circle`:指定圆形的径向渐变 + `size`定义渐变的大小,可能值: + `farthest-corner`(默认):指定径向渐变的半径长度为从圆心到离圆心最远的角 + `closest-side`:指定径向渐变的半径长度为从圆心到离圆心最近的边 + `closest-corner`:指定径向渐变的半径长度为从圆心到离圆心最近的角 + `farthest-side`:指定径向渐变的半径长度为从圆心到离圆心最远的边 + `position`定义渐变的位置.可能值: + center(默认):设置中间为径向渐变圆心的纵坐标值 + top:设置顶部为径向渐变圆心的纵坐标值 + bottom:设置底部为径向渐变圆心的纵坐标值 + `start-color, ..., last-color`用于指定渐变的起止颜色. border-image-slice通过border-image-source引用边框图片后,border-image-slice属性会将图片使用四条切片线分割为9个区域: 四个角 四个边 中心区域 这条切线它们各自的侧面设置给定距离,控制区域的大小. 上图说明了每个区域的位置. 区域1-4为角区域(corner region).每一个都用一次来形成最终边界图像的角点. 区域5-8边区域(edge region).在最终的边框图像中重复,缩放或修改它们以匹配元素的尺寸. 区域9为中心区域(middle region).它在默认情况下会被丢弃,但如果设置了关键字fill,则会将其用作背景图像. 中间的区域9将不会被边框使用,但当设置有fill关键词时将会被作为background-image.这个关键词可以被设置在属性的任何一个位. border-image-slice可以取1到4个值,取值可以是百分比或者数字. 当只有一个值时,这个值会被指定给全部的四个切线. 当两个值时,第一个值指定垂直方向,第二个指定水平方向 当三个值时,第一个值为顶部,第二个值被匹配给垂直方向, 第三个值被匹配给底部. 当四个值时,会依次按上,右,下,左的顺序匹配(即顺时针顺序) border-image-width边框图像的宽度,可以是百分比或者长度. border-image-outset边框图像可超出边框盒的大小,取值可以是长度或者百分比 border-image-repeat用于定义边框图像的填充方式,取值范围为枚举: stretch拉伸图片以填充边框 repeat平铺图片以填充边框 round平铺图像.当不能整数次平铺时,根据情况放大或缩小图像. space平铺图像.当不能整数次平铺时,会用空白间隙填充在图像周围(不会放大或缩小图像) 中的一个, 定义border-image属性时其形式语法为: || [ / | / ? / ]? || 当然如果要使用图片作为边框的话定义还是比较复杂的,建议直接以border-image-source这样的子属性定义. 需要注意使用border-image必须要先定义border,即便其定义会被遮盖掉. Padding(内边距) 清除内容周围的区域,内边距是透明的. padding等价于四个边的的内边距的简写,即 padding-bottom padding-left padding-right padding-top padding其形式语法为: [ | ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto 即有两种用法: 固定长度 即允许1到4个值,每个位置取值可以是长度或者百分比或者使用auto. 当只有一个值时,这个值会被指定给全部的四个边. 当两个值时,第一个值指定横线,第二个指定竖线. 当三个值时,第一个值为上,第二个值被匹配给左和右的边, 第三个值被匹配给下. 当四个值时,会依次按上,右,下,左的顺序匹配(即顺时针顺序) 使用预设的关键字 此时只可以有一个值,为border-box|content-box|max-content|min-content|available|fit-content|auto中的一个. 值 含义 border-box 如出现,之前的值应用到元素的边框盒子. content-box 如出现,之前的值应用到元素的内容盒子. max-content 固有的首选宽度. min-content 固有的最小宽度. available 包含块的宽度减去水平margin,border和padding fit-content 以下两种情况下的较大值:固有的最小宽度;固有首选宽度(max-content)和可用宽度(available)的较小值 auto 浏览器将会为指定的元素计算并选择一个宽度 Content(内容) 盒子的内容,显示文本和图像. 主要的属性有: width定义宽度 max-width定义最大宽度,width不可以大于这个值 min-width定义最小宽度,width不可以小于这个值 height定义高度 max-height定义最大高度,height不可以大于这个值 min-height定义最小高度,height不可以小于这个值 background定义元素内背景 color定义元素内文本颜色 flex布局 既然有了盒子模型,那所谓的布局也就是如何摆箱子的问题了. flex(flexible box:弹性布局盒模型),是2009年w3c提出的一种可以简洁,快速弹性布局的属性.主要思想是给予容器控制内部元素高度和宽度的能力.其中在webkit内核的浏览器中使用时,必须加上-webkit-前缀. 使用flex布局的容器(flex container),它内部的元素自动成为flex项目(flex item).容器拥有两根隐形的轴--水平的主轴(main axis),和竖直的交叉轴(cross axis). 主轴开始的位置,即主轴与右边框的交点,称为main start;主轴结束的位置称为main end;交叉轴开始的位置称为cross start;交叉轴(侧轴)结束的位置称为cross end.item按主轴或交叉轴排列, item在主轴方向上占据的宽度称为main size,在交叉轴方向上占据的宽度称为cross size. 此外，需注意使用flex容器内元素,即flex item的float，clear、vertical-align属性将失效. 弹性容器(Flex container) 包含着弹性项目的父元素.通过设置display属性的值为flex或inline-flex来定义弹性容器. 在一个标签称为弹性容器后,我们可以为其设置一些元素来定义在这个弹性容器中的布局方式.比如排列方向,换行行为,对齐方式等. 一个典型的弹性容器这样定义: .flex-container{ display: flex; } 属性: display 可选的值有: flex使弹性容器成为块级元素 inline-flex使弹性容器成为单个不可分的行内级元素 -webkit-flexwebkit使用的flex,意义同flex -webkit-inline-flexwebkit使用的inline-flex,意义同inline-flex inline-flex和-webkit-inline-flex描述容器中的元素的排列方式 可选的值有: row从左向右横向排列(默认) row-reverse从右向左横向排列 column从上到下纵向排列 column-reverse从下向上纵向排列 flex-wrap和-webkit-flex-wrap描述当当在一条线上排不下后的换行行为,假设我们有12个元素,但一行只能放下10个了 可选的值有: nowrap 不换行(默认)1,2,3,4,5,6,7,8,9,10 wrap 换行,另起的行与原来行一致1,2,3,4,5,6,7,8,9,10 11,12 wrap-reverse换行,第一行在下方11,12 1,2,3,4,5,6,7,8,9,10 flex-flow flex-direction属性和flex-wrap属性的简写形式,格式为flex-flow: ;默认值为row nowrap justify-content项目在主轴上的对齐方式 可选的值有: flex-start左对齐(默认值) flex-end右对齐 center居中 space-between两端对齐,项目之间的间隔相等 space-around每个项目两侧的间隔相等.所以,项目之间的间隔比项目与边框的间隔大一倍 align-items项目在交叉轴上的对齐方式 可选的值有: flex-start 交叉轴的起点(顶部)对齐 flex-end 交叉轴的终点(底部)对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对齐 stretch 如果项目未设置高度属性或设为auto,将占满整个容器的高度(默认) align-content定义了多根轴线的对齐方式,如果项目只有一根轴线,该属性不起作用。 可选的值有: flex-start与主轴,交叉轴的起点对齐 flex-end与主轴的起点,交叉轴的终点对齐 center与主轴和交叉轴的中点对齐 space-between拉伸元素,与主轴和交叉轴两端对齐,轴线之间的间隔平均分布 space-around每根轴线两侧的间隔都相等.所以,轴线之间的间隔比轴线与边框的间隔大一倍. stretch轴线占满整个交叉轴(默认) 弹性项目(Flex item) 弹性容器的每个子元素都称为弹性项目.弹性容器直接包含的文本将被包覆成匿名弹性单元. 每个弹性项目可以有的属性有: order flex-grow定义弹性盒子项(flex item)的拉伸因子.其值是数值,默认值是0. 增加的宽度计算公式为: WIncreasei={{gi}/{∑gi}}×(Wcontainer−∑Wi)\r WIncrease_i = \\{\\{g_i\\} / \\{\\sum g_i\\}\\} \\times (W_container - \\sum W_i)\r WIncrease​i​​={{g​i​​}/{∑g​i​​}}×(W​c​​ontainer−∑W​i​​) 最终宽度计算公式为 WFinali=∑Wi/count(i)+WIncreasei\r WFinal_i = \\sum W_i /count(i) + WIncrease_i\r WFinal​i​​=∑W​i​​/count(i)+WIncrease​i​​ 例:如果为四个flex item分别设置flex-grow为0,1,3,1那么: flex container的宽度 WcontainerW_containerW​c​​ontainer 是600px,四个flex item的宽度和 ∑Wi\\sum W_i∑W​i​​ 是400px,所以还有200px的未占用空间. flex item 增加的宽度 最终宽度 A 0/(0+1+3+1) * 200px = 0px 100 + 0 = 100px B 1/(0+1+3+1) * 200px = 40px 100 + 40 = 140px C 3/(0+1+3+1) * 200px = 120px 100 + 120 = 220px D 1/(0+1+3+1) * 200px = 40px 100 + 40 = 140px flex-shrink定义了flex items的收缩规则.取值是数值,默认值是1,当flex items的宽度和大于flex container的宽度时,用此属性来收缩flex item的宽度. flex-basis取值是长度值,默认值是auto.指定了flex items在主轴方向上的初始大小.如果不使用box-sizing来改变盒模型的话,那么这个属性就决定了flex items的内容盒(content-box)的宽或者高(取决于主轴的方向)的尺寸大小. 前面介绍的flex-grow和flex-shrink都是基本flex item的宽度值(width)来计算的,如果flex item设置了flex-basis属性,那么会直接忽略flex item的宽度,来基于此属性设置的长度值计算. align-self控制flex items的分布行为.具体的: flex-direction的值 align-items的使用场景 row 当flex items的高度和小于flex container的高度时,控制flex items在cross axis上如何分布 column 当flex items的宽度和小于flex container的宽度时,控制flex items在cross axis上如何分布 可以取值为: + `stretch`(默认值)弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度. + `flex-start`元素向侧轴起点对齐 + `flex-end`元素向侧轴终点对齐 + `center`元素在侧轴居中.如果元素在侧轴上的高度高于其容器,那么在两个方向上溢出距离相同. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用页面规范/模板标签.html":{"url":"web前端技术/前端概览/前端应用页面规范/模板标签.html","title":"模板标签","keywords":"","body":"模板标签 HTML内容模板元素是一种用于保存客户端内容的机制,该内容在加载页面时不会呈现,但随后可以在运行时使用JavaScript实例化.我们可以将模板视为一个内容片段,存储在文档中供后续使用. 虽然解析器在加载页面时确实会处理template元素的内容,但这样做只是为了确保这些内容有效;但元素的内容不会被呈现. 模板通常只是固定好样式,而内容需要后续添加.我们来看例子了解其工作原理. 本文的代码在C1-S3 例:输入文本框,按按钮渲染模板 本例中我们的html内容如下: 点击使用模板生成样式 模板实例 Rendered @ 其中main部分是主要展示的部分,可以看到其内部只有一个表单构成,我们监听表单中的input标签,然后获取textarea中的value来作为模板的填充内容 而template部分则是一个简单的文章模板,有标题有段落.我们使用idcontent_placehold占位要填充的内容.而time标签则直接定位在每次渲染时记录当前时间. 具体的js带码如下: function _render_template() { let template = document.querySelector('#test_template') let content = document.querySelector('#content').value let placehold = template.content.querySelector(\"#content_placehold\") placehold.innerText = content let now = new Date().toString() template.content.querySelector(\"time\").innerText = now let rendered_content = document.importNode(template.content, true) return rendered_content } function _render_dom(rendered_content) { let root = document.querySelector('#root') let form = document.querySelector('#form') root.insertBefore(rendered_content, form) } function render() { if ('content' in document.createElement('template')) { let rendered_content = _render_template() _render_dom(rendered_content) } else { console.log(\"浏览器不支持模板\") } } let main = () => { let try_but = document.getElementById(\"try\") try_but.onclick = render } main() 注意因为老浏览器不支持template标签,所有才有 if ('content' in document.createElement('template')) { ... } else { console.log(\"浏览器不支持模板\") } 这个逻辑. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用页面规范/交互事件.html":{"url":"web前端技术/前端概览/前端应用页面规范/交互事件.html","title":"交互事件","keywords":"","body":"交互事件 前端项目除了展示,更多的作用是提供交互.服务器之所以叫服务器是为了可以向客户提供服务的,没有交互服务器甚至没法知道客户要什么. 一般的GUI中我们管提供交互的组件叫控件.html中自然没有这个概念,它只是提供了一些基本的标签用于标识不同的功能,并给不同的标签提供不同的监听事件或者特殊属性以实现交互. 本文只是介绍一些常见的监听事件的惯用方法.具体各个标签有哪些监听项还要看html文档和DOM事件句柄文档 本节的代码在C1-S4中 全局事件 html中的事件可以分为 Window事件属性(Window Event Attributes) 由window对象触发的事件,适用于body标签 属性 描述 onafterprint 在打印文档之后运行脚本 onbeforeprint 在文档打印之前运行脚本 onbeforeonload 在文档加载之前运行脚本 onblur 当窗口失去焦点时运行脚本 onerror 当错误发生时运行脚本 onfocus 当窗口获得焦点时运行脚本 onhaschange 当文档改变时运行脚本 onload 当文档加载时运行脚本 onmessage 当触发消息时运行脚本 onoffline 当文档离线时运行脚本 ononline 当文档上线时运行脚本 onpagehide 当窗口隐藏时运行脚本 onpageshow 当窗口可见时运行脚本 onpopstate 当窗口历史记录改变时运行脚本 onredo 当文档执行再执行操作(redo)时运行脚本 onresize 当调整窗口大小时运行脚本 onstorage 当文档加载加载时运行脚本 onundo 当Web Storage区域更新时(存储空间中的数据发生变化时) onunload 当用户离开文档时运行脚本 表单事件(Form Events) 由表单标签form及其中的子元素触发的事件 属性 描述 onblur 当元素失去焦点时运行脚本 onchange 当元素改变时运行脚本 oncontextmenu 当触发上下文菜单时运行脚本 onfocus 当元素获得焦点时运行脚本 onformchange 当表单改变时运行脚本 onforminput 当表单获得用户输入时运行脚本 oninput 当元素获得用户输入时运行脚本 oninvalid 当元素无效时运行脚本 onreset 当表单重置时运行脚本.HTML5不支持. onselect 当选取元素时运行脚本 onsubmit 当提交表单时运行脚本 键盘事件(Keybord Events) 由键盘操作触发的事件 属性 描述 onkeydown 当按下按键时运行脚本 onkeypress 当按下并松开按键时运行脚本 onkeyup 当松开按键时运行脚本 鼠标事件(Mouse Events) 由鼠标操作触发的事件 属性 描述 onclick 当单击鼠标时运行脚本 ondblclick 当双击鼠标时运行脚本 ondrag 当拖动元素时运行脚本 ondragend 当拖动操作结束时运行脚本 ondragenter 当元素被拖动至有效的拖放目标时运行脚本 ondragleave 当元素离开有效拖放目标时运行脚本 ondragover 当元素被拖动至有效拖放目标上方时运行脚本 ondragstart 当拖动操作开始时运行脚本 ondrop 当被拖动元素正在被拖放时运行脚本 onmousedown 当按下鼠标按钮时运行脚本 onmousemove 当鼠标指针移动时运行脚本 onmouseout 当鼠标指针移出元素时运行脚本 onmouseover 当鼠标指针移至元素之上时运行脚本 onmouseup 当松开鼠标按钮时运行脚本 onmousewheel 当转动鼠标滚轮时运行脚本 onscroll 当滚动元素滚动元素的滚动条时运行脚本 媒介事件(Media Events) 由视频,图像以及音频等媒介触发的事件,适用于所有HTML 5元素,不过在媒介元素(如audio,embed,img,object以及video)中最常用 属性 描述 onabort 当发生中止事件时运行脚本 oncanplay 当媒介能够开始播放但可能因缓冲而需要停止时运行脚本 oncanplaythrough 当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本 ondurationchange 当媒介长度改变时运行脚本 onemptied 当媒介资源元素突然为空时(网络错误、加载错误等)运行脚本 onended 当媒介已抵达结尾时运行脚本 onerror 当在元素加载期间发生错误时运行脚本 onloadeddata 当加载媒介数据时运行脚本 onloadedmetadata 当媒介元素的持续时间以及其他媒介数据已加载时运行脚本 onloadstart 当浏览器开始加载媒介数据时运行脚本 onpause 当媒介数据暂停时运行脚本 onplay 当媒介数据将要开始播放时运行脚本 onplaying 当媒介数据已开始播放时运行脚本 onprogress 当浏览器正在取媒介数据时运行脚本 onratechange 当媒介数据的播放速率改变时运行脚本 onreadystatechange 当就绪状态(ready-state)改变时运行脚本 onseeked 当媒介元素的定位属性不再为真且定位已结束时运行脚本 onseeking 当媒介元素的定位属性为真且定位已开始时运行脚本 onstalled 当取回媒介数据过程中（延迟）存在错误时运行脚本 onsuspend 当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本 ontimeupdate 当媒介改变其播放位置时运行脚本 onvolumechange 当媒介改变音量亦或当音量被设置为静音时运行脚本 onwaiting 当媒介已停止播放但打算继续播放时运行脚本 在设计UI交互逻辑的时候通常思路是尽量以鼠标来控制,辅以一些快捷键 事件句柄的回调函数绑定 事件句柄需要指定回调函数,即当这个事件发生了,这个指定的回调函数就会被执行. 要绑定回调函数,可以有两种方式: .on = 就像上面列的那些句柄一样直接使用等号将回调函数赋值过去. .addEventListener(event:str,func:Function,usecapture:bool)->undefined使用addEventListener方法将回调函数与事件绑定. 这个方法比上面的多出了一个参数usecapture,它表示注册了该listener的元素是否会先于它下方的任何事件目标接收到该事件.默认为false 绑定异步回调函数 回调函数当然是指的一般的函数,但很多时候我们的代码使用了es6/es7中的异步函数,要知道异步函数是有传染性的,这种时候我们该如何操作呢? 答案就是使用一个箭头函数包装在外层: window.addEventListener(\"load\", () => load(), false); async function load() { // do the await things here. } 按钮button 本节的代码在C1-S4-P2中 button标签用于定义一个按钮,在button元素内部可以放置内容,比如文本或图像.这是该元素与使用input元素创建的按钮之间的不同之处. button控件 与相比，提供了更为强大的功能和更丰富的内容.与标签之间的所有内容都是按钮的内容,其中包括任何可接受的正文内容,比如文本或多媒体内容.例如，我们可以在按钮中包括一个图像和相关的文本,用它们在按钮中创建一个吸引人的标记图像. 唯一禁止使用的元素是图像映射,因为它对鼠标和键盘敏感的动作会干扰表单按钮的行为. 请始终为按钮规定type属性.IE的默认类型是\"button\",而其他浏览器中(包括W3C规范)的默认值是 \"submit\".微软果然搅屎棍. 例子中我们创建了一个图片为空心心的按钮,之后我们点击它让他替换成实心心的按钮. 表单form 本节的代码在C1-S4-P3中 HTML表单用于搜集不同类型的用户输入.它通常不是叶子节点,而是包裹一个控件树的枝节点. HTML表单包含的表单元素通常指的是不同类型的input元素,复选框,单选按钮,提交按钮等等. 表单可以使用type为submit的input标签直接向由form属性action指定的目标地址发送method属性指定的http请求,其请求头的content-type字段会根据form属性enctype来指定,可以有三种: 值 描述 application/x-www-form-urlencoded 在发送前编码所有字符(默认) multipart/form-data 不对字符编码.在使用包含文件上传控件的表单时必须使用该值. text/plain 空格转换为+加号,但不对特殊字符编码. 现在的前端项目通常也不会直接使用submit将数据传回服务端,而是会收集下来要么做一个缓存以防提交失败用户全部重填,要么就干脆在前端就做初步的合规检验,不通过直接刷新页面重填以减轻服务器压力. form的属性 属性 描述 accept-charset 规定在被提交表单中使用的字符集(默认:页面字符集). action 规定向何处提交表单的地址(URL)(提交页面). autocomplete 规定浏览器应该自动完成表单(默认开启) enctype 规定被提交数据的编码(默认:url-encoded,可选还有multipart/form-data和text/plain) method 规定在提交表单时所用的 HTTP 方法(默认:GET) name 规定识别表单的名称(对于 DOM 使用:document.forms.name) novalidate 规定浏览器不验证表单。 target 规定action属性中地址的目标(默认:_self) 方法 描述 reset() 把表单的所有输入元素重置为它们的默认值。 submit() 提交表单 事件句柄 描述 onreset 在重置表单元素之前调用。 onsubmit 在提交表单之前调用。 ps 事件句柄返回fasle,表单的元素就不会提交;如果该函数返回其他值或什么都没有返回,则表单会被提交. 当调用方法时,事件句柄不会被调用. 表单组件分组 有时表单相当复杂,需要将组件分组,不同的组提交给不同的接口,这时就可以使用fieldset标签分组并使用legend标签设定标题. fieldset可以设置的属性有: disabled 如果设置了这个bool值属性,它的后代表单控制元素也会继承这个属性,它的首个可选的legend元素除外,例如,禁止编辑.该元素和它的子元素不会接受任何浏览器事件,比如点击或者focus事件,一般来说浏览器会将这样的元素展示位灰色. form 规定fieldset所属的form表单.这个属性的值与其所属的form的ID相同.默认值是最近的那个form. name 控制元素分组的名称 输入组件input标签 input标签按type属性的不同会被渲染成不同输入控件,具体的可以查看文档中的 types部分. 常见的input标签的type属性包括: 特定类型信息输入email,tel,password,url 这种类型一方面是语义化,另一方面也是会对特定类型做一些默认的检验. 单选信息radio 顾名思义,就是多个选项里选一个,通常用name固定一个组. 多选信息checkbox 顾名思义,就是多个选项里选多个,通常用name固定一个组. 下拉菜单select 和单选多选类似,不同之处只是选择的方式改为了下拉菜单.通常它与option标签配合使用 Volvo Saab Fiat Audi 它的对象属性有: 属性 描述 disabled 设置或返回是否应禁用下拉列表 form 返回对包含下拉列表的表单的引用 id 设置或返回下拉列表的id length 返回下拉列表中的选项数目 multiple 设置或返回是否选择多个项目 name 设置或返回下拉列表的名称 selectedIndex 设置或返回下拉列表中被选项目的索引号 size 设置或返回下拉列表中的可见行数 tabIndex 设置或返回下拉列表的tab键控制次序 type 返回下拉列表的表单类型。 对象方法有: 方法 描述 add() 向下拉列表添加一个选项 blur() 从下拉列表移开焦点 focus() 在下拉列表上设置焦点 remove() 从下拉列表中删除一个选项 事件句柄有: 事件句柄 描述 onchange 当改变选择时调用的事件句柄。 文本输入框text 可以使用属性minlength和maxlength限定文本长度的输入框. 文件选择file 从本地选择文件作为输入.选中文件通过HTMLInputElement.files属性返回. 返回值是一个FileList对象,这个对象是一个包含了许多File文件的列表(你也可以想列表一样操作它). 每个File对象包含了下列信息: name: 文件名. lastModified: UNIX timestamp 形式的最后修改时间. lastModifiedDate: Date 形式的最后修改时间. size: 文件的字节大小. type: DOMString 文件的 MIME 类型. 可以使用input的accept属性控制接收的文件类型. accept属性接受一个逗号分隔的MIME类型字符串,如: accept=\"image/png\" or accept=\".png\" — 只接受png图片. accept=\"image/png,image/jpeg\" or accept=\".png, .jpg, .jpeg\"— PNG/JPEG文件. accept=\"image/*\" — 接受任何图片文件类型. accept=\".doc,.docx,.xml,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document\" — 接受任何 MS Doc 文件类型. 颜色选择器color 呼出颜色选择器 数值输入number 用于应该包含数值的输入域.这个类型的input标签额外可以有属性 属性 描述 max 规定允许的最大值 min 规定允许的最小值 step 规定合法的数字间隔(如果 step=\"3\"，则合法的数是 -3,0,3,6 等) value 规定默认值 数值滑动条range 用于应该包含一定范围内数字值的输入域.还能够设定对所接受的数字的限定 属性 描述 max 规定允许的最大值 min 规定允许的最小值 日期选择器date, month, week,time, datetime, datetime-local 用于选择日期时间.可以使用min和max属性确定日期范围. search 用于搜索域,比如站点搜索或Google搜索等 search域显示为常规的文本域. 重置按钮reset 提交按钮使用value属性控制其中的文本,同时重置操作可以通过设置属性accesskey来指定快捷键. 提交按钮submit 提交按钮使用value属性控制其中的文本,同时提交操作可以通过设置属性accesskey来指定快捷键. 例子 各种控件合在一起构造一个表单,一个常见的表单写法如下: Person Info Gender: Male Female First name: Last name: 本段落的例子我们来获取某个用户的基本信息,点击提交后我们在浏览器的console中打印出来.每次提交则会比较和上次是否不同,只有不同时才会打印.点击reset则清空. 这里我们使用第三方模块js-md5来做除重. 拖拽 本节的代码在C1-S4-P4中 拖放是一种常见的特性,即抓取对象以后拖到另一个位置.在HTML5中,拖放是标准的一部分,任何元素都能够拖放. 拖拽操作步骤 大致分为如下几步: 鼠标点击对象开始拖拽,事件句柄ondragstart 鼠标hold住对象拖动,事件句柄ondrop 拖动至有效元素上,事件句柄ondragover 我们使用元素的属性draggable=\"true\"来让一个元素可以被拖动.然后为事件句柄ondragstart设置回调函数func(event)来设置被拖动的信息. 回调函数的参数为事件对象,其中的字段dataTransfer保存数据转移对象.可以使用其setData(type,id)方法来设置被拖动的数据类型和值. 使用ondragover事件句柄来定义要拖动的对象要放到何处,默认无法将数据或元素放置到其他元素中,如果需要设置允许放置,我们必须阻止对元素的默认处理方式.这可以使用ondragover回调函数的参数的event.preventDefault()方法来实现. 进行放置则是设置事件句柄ondrop,使用其回调函数的参数event的字段event.dataTransfer.getData(\"Text\")来获取被拖拽的对象的id,使用event.target.appendChild(document.getElementById(data))来将元素放置入其中. DataTransfer对象 DataTransfer对象定义的属性和方法有很多种,我们看下列入标准的几个. 属性 说明 types 只读属性。它返回一个我们在dragstart事件中设置的拖动数据格式的数组。 格式顺序与拖动操作中包含的数据顺序相同。IE10+、Edge、safari3.1、Firefox3.5+ 和Chrome4以上支持该属性 files 返回拖动操作中的文件列表。包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。 dropEffect 获取当前选定的拖放操作的类型或将操作设置为新类型。它应该始终设置成effectAllowed的可能值之一【none、move、copy、link】。dragover事件处理程序中针对放置目标来设置dropEffect。 effectAllowed 指定拖放操作所允许的效果。必须是其中之一【 none, copy, copyLink, copyMove, link, linkMove, move, all, uninitialized】默认为uninitialized 表示允许所有的效果。ondragstart处理程序中设置effectAllowed属性 方法 说明 void setData(format, data) 将拖动操作的拖动数据设置为指定的数据和类型。format可以是MIME类型 String getData(format) 返回指定格式的数据，format与setData()中一致 void clearData([format]) 删除给定类型的拖动操作的数据。如果给定类型的数据不存在，此方法不执行任何操作。如果不给定参数，则删除所有类型的数据。 void setDragImage(img, xOffset, yOffset) 指定一副图像，当拖动发生时，显示在光标下方。大多数情况下不用设置，因为被拖动的节点被创建成默认图片。x,y参数分别指示图像的水平、垂直偏移量 例子 我们的例子是一个很常见的交互方式,上面为可选列表,下面为被选列表. 可选项: person1 person2 person3 person4 已选项: 我们要实现拖拽,需要写一个脚本来控制. let listFormRender = { list: document.getElementById(\"container\"), target_list: document.getElementById(\"target_container\"), bindEvent: function () { this.list.ondragstart = this.onDragStart this.target_list.ondrop = this.onDrop this.target_list.ondragover = this.onDragover console.log(\"bind\") }, onDragStart: function (event) { event.dataTransfer.setData(\"TS\", event.target.id) }, onDrop: function (event) { event.preventDefault() let data = event.dataTransfer.getData(\"TS\") let item = document.getElementById(data) event.target.appendChild() item.setAttribute(\"draggable\",false) }, onDragover: function (event) { event.preventDefault() } } let main = () => { console.log(\"main\") listFormRender.bindEvent() } main() 这个脚本中我们定义了一个对象listFormRender来直接管理拖拽列表的活动,设定好拖动对象所在的容器和目标容器.为他们各自的事件句柄分别绑定上回调函数即可. 浏览器提醒 (updated @2019-03-27) 以往的网页提示仅限在其页面中,而html5现在支持桌面级的通知,也就是web notification,这一特性非常适合浏览器端的音乐app.又或者是邮件app,如果结合后文中的websocket则可以实现服务端主动推送提示. 本节的代码在C1-S4-P5中 web notification的用法也简单 首先,由于浏览器权限问题,我们需要向用户请求开通web notification功能 Notification.requestPermission((status)=>{ //status是授权状态，如果用户允许显示桌面通知，则status为'granted' console.log('status: ' + status) //permission只读属性 let permission = Notification.permission //default 用户没有接收或拒绝授权请求 不能显示通知 //granted 用户接受授权请求 允许显示通知 //denied 用户拒绝授权请求 不允许显示通知 console.log('permission: ' + permission) }) 当这段代码执行时,浏览器会询问用户是否允许该站点显示消息通知. 接着就是使用了: if (Notification.permission === 'granted') { //show notification let n = new Notification(\"sir, you got a message\", { icon: 'img/icon.png', body: 'you will have a meeting 5 minutes later.' }) } Notification本身还支持添加交互,它有4个常用的函数可以用来处理事件交互: onshow函数可以在消息展示时执行 onclick函数可以在用户点击消息后被调用 onclose函数是在消息框被关闭时被调用 onerror函数是发生错误时被调用 上面也提到了,如果没有被授权而继续创建消息通知也会执行onerror函数.掌握了这几个事件的应用基本上可以很好地处理消息事件了 需要注意的是:通知功能需要浏览器中打开,默认是被阻止的,chrome中在高级设置中打开 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用页面规范/桌面级消息提醒.html":{"url":"web前端技术/前端概览/前端应用页面规范/桌面级消息提醒.html","title":"桌面级消息提醒","keywords":"","body":"桌面级消息提醒 html5提供了桌面级的消息提醒功能,使用接口Notification,这个接口并不是所有浏览器都支持,我们可以使用下面的代码查看浏览器的支持情况. function checkBrowserSupport(){ if (!\"Notification\" in window) { return false } else { return true } } 消息权限 如果是支持的浏览器,我们也需要用户给与这个网站消息推送权限才可以使用.我们可以使用Notification.permission查看用户对这个网站有没有开放推送权限.Notification.permission有三种值: granted允许 denied不允许 default用户未赋权 我们可以使用Notification.requestPermission()方法请求开放推送权限.它会返回一个Promise,其结果为granted或者denied.因此我们要使用异步函数来申请 async function() { try { let result = await Notification.requestPermission() console.log(result) } catch(e) { return false } return true } 推送消息 推送消息只需要实例化Notification类即可,其构造函数支持两个参数 title,必须,推送的标题 options,可选,是一个对象,可以包含字段包括 dir显示通知的方向,默认是auto,跟随浏览器语言设置行为,你也可以通过设置ltr和rtl的值来覆盖该行为(虽然大多数浏览器似乎忽略这些设置) lang通知的语言. body一个DOMString表示通知的正文,将显示在标题下方. tag一个DOMString代表通知的一个识别标签. icon一个USVString包含要在通知中显示的图标的URL. image一个USVSTring包含要在通知中显示的图像的URL. data想要与通知相关联的任意数据.这可以是任何数据类型. vibrate振动模式v,一些设备支持 renotify一个Boolean类型,指定在新通知替换旧通知后是否应通知用户.默认值为false,这意味着它们不会被通知. requireInteraction表示通知应保持有效直到用户点击或关闭它,而不是自动关闭.默认值为false.不过一般会设置为true Notification的实例 Notification的实例有方法close()可以用于手动关闭实例. Notification的实例可以绑定的事件有 onclick点击事件 onclose关闭事件 onerror错误事件 onshow展示事件 定时关闭推送 由于不同浏览器中自动关闭推送不好控制,所以我们通常使用setTimeout做个定时任务实现自动关闭 let notification = new Notification(\"测试推送\", { body: '测试推送的内容', requireInteraction: true }) notification.onclose = ()=>console.log(\"消息关闭了\") setTimeout(function() { notification.close() }, 3000) Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/":{"url":"web前端技术/前端概览/前端应用调用本地资源/","title":"前端应用调用本地资源","keywords":"","body":"前端应用调用本地资源 前面已经介绍过前端项目的原理,简单说就是调用浏览器接口实现页面渲染,从而为客户提供展示和交互. 照理说浏览器不该为开发者提供过多的本地资源调用方式,这样容易造成客户数据信息的安全问题,也有可能让开发者偷偷利用客户计算资源. 但随着前端项目的工程化和复杂化,现在的前端项目有时候更像一个客户端而非简单的浏览器.在一定程度上越来越依赖客户本地的资源. 浏览器现在也逐渐方宽了这些限制. 本章讲浏览器的本地资源调用方式,本章的例子在C2中 本章的内容包括: 使用本地文件系统 使用本地存储 使用本地摄像头和麦克风 使用语音 使用本地多线程资源 使用本地GPU计算资源 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/使用本地文件系统.html":{"url":"web前端技术/前端概览/前端应用调用本地资源/使用本地文件系统.html","title":"使用本地文件系统","keywords":"","body":"本地文件系统 html5提供了文件读的api,可以浏览器端直接读出文件. 文件的api可以看官方文档 简单说,文件读取需要实例化一个FileReader,它有如下几种触发事件: onabort 取消读取时触发 onerror 读取报错时触发 onload 加载时触发 onloadend 加载完后触发 onloadstart 开始加载时触发 onprogress 追踪读取一般用来做更新进度条 它的实例有个abort()方法可以取消读取 以及3个读取方法: readAsArrayBuffer(f) 以缓冲ArrayBuffer的形式读取文件为二进制码 readAsDataURL(f) 将文件读取为 DataURL readAsText(f[,encoding]) 将文件读取为文本 例子 本文的例子在C2-S1 这个例子实现了从系统拖拽图片文件到指定位置以读取文件,并将图片展示出来的功能. 这个例子我们创建了一个类ReaderRender 来实现读取操作,一个对象ImageReadRender来绑定拖拽,点击等事件句柄. index.html 测试模板 Drop files here Cancel read 0% ReaderRender class ReaderRender { /** * @desc 读取文件的处理对象 * @public {HTMLElement} progress - 进度条 * @public {ReaderRender} reader - 包装的读取对象. */ constructor() { this.progress = document.querySelector('.percent') this.progress.style.width = '0%' this.progress.textContent = '0%' this.reader = new FileReader() } /** * 退出读取. */ abort() { return this.reader.abort() } /** * 根据文件对象绑定读取事件 * @param {File} f - 要读取的文件对象 */ bindEvent(f) { this.reader.onerror = this.errorHandler this.reader.onprogress = this.updateProgress this.reader.onabort = this.onAbort this.reader.onloadstart = this.onLoadStart this.reader.onload = this.onLoad(f) } /** * reader对象的readAsDataURL方法代理 * @param {File} f - 要读取的文件对象 */ readAsDataURL(f) { return this.reader.readAsDataURL(f) } /** * 加载读取退出时的回调函数 * @param {Event} e - 事件 */ onAbort(e) { alert('File read cancelled') } /** * 开始读取加载时的的回调函数 * @param {Event} e - 事件 */ onLoadStart(e) { document.getElementById('progress_bar').className = 'loading'; } _onLoad(theFile) { return function (e) { console.log(\"this.progress\") let progress = document.querySelector('.percent') progress.style.width = '100%' progress.textContent = '100%' let span = document.createElement('span') span.innerHTML = [ '' ].join('') document.getElementById('output').insertBefore(span, null) setTimeout(\"document.getElementById('progress_bar').className='';\", 2000); } } /** * 使用读取的文件来构造加载reader的事件onload的句柄回调函数 * @param {*} f - 读取的文件 * @return {function(e: event)} - 构造成的onload事件的回调函数 */ onLoad(f) { return this._onLoad(f) } /** * 读取出错时的处理方式 * @param {Event} eve - 事件 */ errorHandler(eve) { switch (eve.target.error.code) { case eve.target.error.NOT_FOUND_ERR: alert('File Not Found!') break case eve.target.error.NOT_READABLE_ERR: alert('File is not readable') break case eve.target.error.ABORT_ERR: break default: alert('An error occurred reading this file.') } } /** * 更新进度条 * @param {Event} eve - 事件 */ updateProgress(eve) { // evt is an ProgressEvent. if (eve.lengthComputable) { let percentLoaded = Math.round((eve.loaded / eve.total) * 100); // Increase the progress bar length. if (percentLoaded ImageReadRender let ImageReadRender = { /** * @desc 图片读取渲染对象. * @public {HTMLElement} files - 读取文件的input标签 * @public {HTMLElement} abortbt - 退出读取的按钮标签 * @public {HTMLElement} dropZone - 拖拽的放置位置div标签 * @public {ReaderRender} [reader=null] this is param. */ files: document.getElementById('files'), abortbt: document.getElementById('abortbt'), dropZone: document.getElementById('drop_zone'), reader: null, /** * 将各种事件绑定到对应的控件上 */ bindEvent: function () { if (this.supported_File()) { this.files.addEventListener('change', this.handleFileSelect, false) this.dropZone.addEventListener('dragover', this.handleDragOver, false) this.dropZone.addEventListener('drop', this.handleFileSelect, false) this.abortbt.addEventListener(\"onclick\", this.abortRead, false) } else { alert('The File APIs are not fully supported in this browser.') } }, /** * 判断浏览器是否支持文件读取接口,并不是所有浏览器都支持. */ supported_File: function () { if ((\"File\" in window) && (\"FileReader\" in window) && (\"FileList\" in window) && (\"Blob\" in window)) { return true } else { return false } }, /** * 点击取消按钮的事件回调函数 */ abortRead() { ImageReadRender.reader.abort() }, /** * @desc 处理文件选择的回调函数 * @param {Event} event - 事件对象 */ handleFileSelect: function (event) { let files = null /// 获取到文件 if (event.type == \"drop\") { event.preventDefault() //不会跳转 files = event.dataTransfer.files } else { files = event.target.files } /// 处理文件 let output = []; for (let f of files) { if (!f.type.match('image.*')) { continue } ImageReadRender.reader = new ReaderRender() ImageReadRender.reader.bindEvent(f) ImageReadRender.reader.readAsDataURL(f) output.push('', f.name, ' (', f.type || 'n/a', ') - ', f.size, ' bytes, last modified: ', f.lastModifiedDate.toLocaleDateString(), '') // Read in the image file as a data URL. } document.getElementById('output').innerHTML = '' + output.join('') + '' }, /** * @desc 放置到位后的处理回调函数. * @param {Event} eve */ handleDragOver: function (eve) { eve.stopPropagation() eve.preventDefault() eve.dataTransfer.dropEffect = 'copy' // Explicitly show this is a copy. } } 这样写相对清晰,需要注意的是注册到事件句柄的回调函数中this指针无法指向对象自身,因此要么冲洗获取要操作的元素,要么使用全局变量,不建议使用全局变量,会造成维护的麻烦. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/使用本地存储.html":{"url":"web前端技术/前端概览/前端应用调用本地资源/使用本地存储.html","title":"使用本地存储","keywords":"","body":"本地存储 在早期的html服务中,前端是不应该存在本地存储的,毕竟http协议在设计之初就是一个基于短连接的协议. 但服务可以没有状态,但用户需要有状态,总要有一种方式让服务器知道使用的人是谁,这就带来了状态. 也就必须有本地存储让浏览器记住一些用户对特定网站的状态信息,于是诞生了最简单的本地存储--cookie. 但cookie的限制不少,它有长度限制,是最简单的键值对形式,并且他会在每次对服务的请求中附带上. 尤其在现在前端工程化的趋势中,前端项目很多时候会保存许多用户状态或者操作的中间状态,已然相当接近客户端了,cookie的机制显然已经不能满足需求了. 在比较新的浏览器中现在都已经支持一些其他本地存储方式了,其中的代表是Web Storage和Indexed DB,另外也有更加激进的方案websql 本章的代码在C2-S2 域 提本地存储就不得不提域,这是一个在web开发中绕不开的问题.试想如果要让浏览器知道用户在某个网站上的信息该怎么办?很容易可以想到可以做个映射, 不同的网站存各自的东西就好,这就是最朴素的域的想法了.当然域不光解决存储问题,更关键的是用于安全问题,解决XSS,CSFR等攻击.这个我们在与服务端交互部分细聊. 同源策略 同源策略/SOP(Same origin policy)是一种约定,由Netscape公司1995年引入浏览器,它是浏览器最核心也最基本的安全功能,所谓同源是指\"协议+域名+端口\"三者相同,即便两个不同的域名指向同一个ip地址,也非同源.浏览器在多数情况下只会允许对同源资源进行操作和访问. 在本地存储这个场景下,也就是说A站的前端页面无法访问到B站存在本地的数据. 本文的例子 本文将使用一个相同的例子,使用不同的本地存储技术分别做实现.这个例子很简单--保存之前表单中页面存储的用户信息. 我们的页面会复用其中的现有界面和代码,只是把其中打印到命令行的部分替换为存储到本地存储. 之后我们为页面添加一个表格将保存的数据全都一次展示出来,每次插入都会触发新增一条记录,而展示则需要点击一个按钮控件button.这个展示我们会使用模板标签来实现. index.html 测试模板 Person Info Gender: Male Female First name: Last name: Birthday: Email: Tel: Home Page: Show Table List 已有用户 用户id First name Last name Gender Birthday Email Tel Home Page 展示部分复用外,我们也规定好除了存取以外的js代码: formRender用于定义存的交互逻辑,其中调用Storage.saveOne(this_md5, table)来保存 showRender用于定义读取并展示的交互逻辑,其中调用Storage.loadAll()来取出数据 这样我们只要实现Storage对象,其有两个方法: saveOne(this_md5, table)用于保存一条数据 Storage.loadAll()用于读取全部数据 cookie 虽然cookie)已经有点过气,但架不住它是目前支持最广泛的本地存储工具.虽然各家cookie的个数限制和容量限制各不相同,但大致上,容量在5000字节以下. 其本质是一段键值组成的字符串. js使用document.cookie来访问当前域的cookie.对于cookie的个增删改查操作可以查看文档,这边不做复述. 针对我们的例子,这边大致讲下实现时的思路: 首先由于cookie只能存字符串,要保存对象我们只能先将其编码为json,而键我们则是用json的md5来创建.这个md5就是其id了. 然后是其保存形式,cookie保存的形式类似:key1=value1;key2=value2因此需要先将数据按;分割以获得每一条数据,然后再在每条数据中按=分割获得md5的值和对应的json字符串,之后解析json字符串即可得到每条数据的对象. Storage const Storage = { saveOne: function (md5_id, table) { document.cookie = `${md5_id}=${JSON.stringify(table)}` }, loadAll: function () { if (document.cookie.length>0){ let data = document.cookie.split(\";\") let result = [] for (let i of data) { let content = i.split(\"=\") let id = content[0] let body = content[1] let table = JSON.parse(body) table.id = id result.push(table) } return result }else{ return false } } } 本节的代码在C2-S2-P1 Web Storage webstorage是一个键值对数据存储工具.提供两种类型的API:localStorage和sessionStorage,两者的区别看名字就有大概了解: localStorage在本地永久性存储数据,除非显式将其删除或清空.其对象为Window.localStorage或localStorage sessionStorage存储的数据只在会话期间有效,关闭浏览器则自动删除.其对象为Window.sessionStorage或sessionStorage 两个对象都有共同的API. Storage同样还是键值对存储.因此接口简单但不像关系数据库那样有个固定的schema.有时候并不是太好用. 从容量上讲WebStorage一般浏览器提供5M的存储空间,用来存储视频,图片这类明显不够,但对于绝大部分状态信息已经绰绰有余. webstorage一样受域限制. 从浏览器兼容性来看主流浏览器都已经支持webstorage了. 既然接口一致,我们就使用localStorage作为例子好了. api 借用typescript的接口我们来看下Storage的描述: 属性: interface Storage { readonly attribute unsigned long length; DOMString? key(unsigned long index); getter DOMString getItem(DOMString key); setter creator void setItem(DOMString key, DOMString value); deleter void removeItem(DOMString key); void clear(); }; length:唯一的属性，只读，用来获取storage内的键值对数量。 key：根据index获取storage的键名 getItem：根据key获取storage内的对应value setItem：为storage内添加键值对 removeItem：根据键名，删除键值对 clear：清空storage对象 事件: interface StorageEvent : Event { readonly attribute DOMString key; readonly attribute DOMString? oldValue; readonly attribute DOMString? newValue; readonly attribute DOMString url; readonly attribute Storage? storageArea; }; HTML5规定了一个storage事件，在WebStorage发生变化的时候触发，可以用此监视不同页面对storage的修改 key:键值对的键 oldValue：修改之前的value newValue：修改之后的value url：触发改动的页面url StorageArea：发生改变的Storage 实际操作中Storage用法很简单,就和python中的某个全局字典差不多,不太一样的地方也就是遍历比较麻烦了 创建或修改键值对: localStorage.setItem(key,value)或者localStorage[key]=value 读取键对应的值: localStorage[key] 删除键值对: localStorage.removeItem(key) 清空所有数据: localStorage.clear() 遍历所有数据: for (let i of Object.keys(localStorage)){ ... } 修改例子 本节的代码在[C2-S2-P2](https://github.com/TutorialForJavascript/frontend-basic/tree/master/code/C2/S2/P2 由于我们的代码结构,我们只需要修改Storage对象即可,因为localStorage依然是键值对存储,且依然只接受字符串(由于js是弱类型,不是字符串的对象会被保存为字面量),我们还是使用json先将值序列化. Storage const Storage = { saveOne: function (md5_id, table) { localStorage.setItem(md5_id,JSON.stringify(table)) }, loadAll: function () { if (localStorage.length>0){ let keys = Object.keys(localStorage) let result = [] for (let id of keys) { let body = localStorage[id] let table = JSON.parse(body) table.id = id result.push(table) } return result }else{ return false } } } Indexed DB Web Storage使用简单字符串键值对在本地存储数据,方便灵活,但是对于大量结构化数据存储力不从心,IndexedDB是为了能够在客户端存储大量的结构化数据,并且使用索引高效检索的API. indexedDB依然受域的限制,但除了可以存储字符串,indexedDB也可以存bytes.在容量方面,indexedDB各个浏览器的实现细节不同,火狐无上限,chrome每一条记录大小不能超过130M. indexedDB同时支持webWorker,这也是它相比其他方案优秀之处. 虽然多数浏览器已经支持indexedDB,但不同浏览器中它的对象并不完全一样,且标准接口使用的是事件驱动的方式,这种并不符合我们的使用习惯,我们可以使用封装好的Dexie.js 要使用它最简单的方式是在index.html中head中加一行 Dexie.js的使用方法 indexedDB用起来比较接近MongoDB,通常我们使用Dexie.js的异步接口,主要的接口包括: let db = new Dexie(\"PersonInfoDatabase\")新建一个数据库连接实例 db.version(1).stores({tablename: \"key1,key2,...\"})为数据库建立一个表,并规定其使用的字段 db.transaction('rw', this.db.person, async () => {...}为数据库创建一个事务操作的Promise第三位的异步函数就是事务操作的具体内容. db.就是表对象,可以在上面的事务异步函数内使用,toArray(),count(),add(obj),where(exp)等异步方法可以用于获取需要的数据或做增删改查操作. 修改例子 本节的代码在C2-S2-P3 由于我们使用了异步接口,我们的代码会进行了相对多的变化: Storage 新增了字段db用于保存使用的数据库对象,方法init_db()在main函数中先就调用,用来规定数据库中的表和各自表的key. 同时我们的saveOne和loadAll现在返回的是事务操作的Promise. const Storage = { db: new Dexie(\"PersonInfoDatabase\"), init_db: function () { this.db.version(1).stores({ person: \"id,firstname,lastname,gender,birthday,email,tel,homepage\" }) }, saveOne: function (md5_id, table) { return this.db.transaction('rw', this.db.person, async () => { // Make sure we have something in DB: table.id = md5_id await this.db.person.add(table) }) }, loadAll: function () { return this.db.transaction('rw', this.db.person, async () => { if ((await this.db.person.count()) > 0) { let result = await this.db.person.toArray() return result } else { return false } }) } } 调用保存和读取 由于一般函数中无法使用await关键字,我们就需要在保存和读取时使用Promise的then(result)接口和catch(error)接口定义返回值得使用方式和错误处理方式. let tables_promise = Storage.loadAll() tables_promise.then((result) => { ... }).catch(e => { alert(e.stack || e); }) websql(html5未被收录) websql是被废弃的一个html5标准,目前支持的浏览器包括Safari, Chrome和Opera,它使用sqlite的sql方言作为标准,并且可以自定义数据库大小. websql通常用在一些基于浏览器的客户端技术上,纯前端项目难得会用.我们希望使用websql的异步接口,可以使用websql-promisified配合原生接口使用.这个包我们无法直接使用,可以去它的github上找到源码,然后删掉最后一行的export语句,新加一个方法.我们将这个包命名为websql-promisified.js放在我们的es文件夹中和index.js一起编译. ... function websql(db) { return Object.create(prototype, { db: { value: db } }) } 我们需要在html文件中引用这个包 之后就可以使用了. 接口 websql的操作其实就是使用sql语句执行对应的操作.它接口很少,配合websql-promisified的话大致有如下几个接口: 创建数据库 const db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); 可以允许有5个参数: 数据库名称 版本号 描述文本 数据库大小,单位bytes 创建回调 数据库接口异步化 import websql from 'websql-promisified' const db_promise = websql(db) 创建事务Promise let result = await websqlPromise.transaction((tx) => { ... }) 这个result是一个数组,其第i位即为这个事务中第i条tx.executeSql()的返回值. 在事务中执行sql语句 tx.executeSql('SELECT * FROM someTable'); 允许按顺序最多有三个参数: sql语句字符串 sql语句字符串中如果有?作为占位符可以在第二位的array中按出现顺序补上 执行完后(tx, result)为参数的回调函数. 由于有模板字符串,实际上第二个参数已经没啥用了. 修改例子 本节的代码在C2-S2-P4 前文提到的异步化模块的处理是这个例子中最大的变化,剩下的其实就简单了 Storage storage中定义了db为我们的数据库对象,db_promise为db的异步化包装对象.我们在方法init_db中构造db_promise,并创建其中的表. 剩下的就只是编写sql语句实现插入和查询罢了. const Storage = { db: openDatabase('PersonInfoDatabase', '1.0', 'Test DB', 2 * 1024 * 1024), db_promise: null, init_db: function () { this.db_promise = websql(this.db) this.db.transaction(function (tx) { tx.executeSql( 'CREATE TABLE IF NOT EXISTS Person (' + 'id TEXT PRIMARY KEY NOT NULL,' + 'firstname TEXT NOT NULL,' + 'lastname TEXT NOT NULL,' + 'gender TEXT NOT NULL,' + 'birthday TEXT NOT NULL,' + 'email TEXT NOT NULL,' + 'tel TEXT NOT NULL,' + 'homepage TEXT NOT NULL)' ) }) }, saveOne: function (md5_id, table) { return this.db_promise.transaction(function (tx) { tx.executeSql( `INSERT INTO Person VALUES ('${md5_id}','${table.firstname}','${table.lastname}','${table.gender}','${table.birthday}','${table.email}','${table.tel}','${table.homepage}');` ) }) }, loadAll: function () { return this.db_promise.transaction(function (tx) { tx.executeSql( `SELECT * FROM Person` ) }) } } 在调用部分我们需要注意下result中的结果顺序,每个请求的结果是按请求顺序返回的.而数据则放在result[i].rows中. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/使用本地摄像头和麦克风.html":{"url":"web前端技术/前端概览/前端应用调用本地资源/使用本地摄像头和麦克风.html","title":"使用本地摄像头和麦克风","keywords":"","body":"使用本地摄像头和麦克风 在2015年的时候我在法国第一次和班上的朋友通过facebook在网页上视频通话,当时只有一种感觉--黑科技. 要实现视频通话需要: 让浏览器可以访问到摄像头 让浏览器可以访问到麦克风 让摄像头和麦克风的数据可以传输到远端 客户端视频通话没什么稀奇的,但网页端视频通话就厉害了.能实现这一功能益于一项革命性的技术--webrtc. 我们这一节只先讨论如何让浏览器获取摄像头和麦克风中的输入数据.在后面与服务端交互的部分我们会将在网页上做视频通话这一目标完成. 目前至少chrome支持webm格式录制视频,而如果要将录制下来的视频转变为常见的格式我们还需要借助ffmpeg.js和webworker来实现.这部分我们会在后面的webworker部分完善这个例子. 本节的代码在C2-S3.本节的代码魔改自这个项目. navigator.mediaDevices访问摄像头和麦克风的主要接口 navigator.mediaDevices允许浏览器调用摄像头,麦克风.这样可以做一些比如自拍,录像这样的功能,获取摄像头和麦的捕捉信息由navigator.mediaDevices.getUserMedia(c:Constraints)对象获得,它通过参数对象来设置要捕获的流种类. interface Constraints { audio: boolean||Object video: boolean||Object } 它会返回一个promise,如果成功,就会获得一个Stream,失败就会返回一个error 设备选择 Constraints的内容中可以允许指定输出设备(用设备id), constraints = { audio: { deviceId: audioSource ? { exact: audioSource } : undefined }, video: { deviceId: videoSource ? { exact: videoSource } : undefined } }; 视屏输出的音频输出设备可以用.setSinkId(deviceId)来指定. 可以用navigator.mediaDevices.enumerateDevices()收集系统上可用的媒体输入和输出设备的信息(deviceInfo[]),之后用then中的回调函数选择用哪个,放在一个容器中, 每个deviceInfo会包含有: deviceId,设备编号 kind ,设备类型,包括audioinput,audiooutput,videoinput label ,设备标签 这样只要将这些获得的deviceId放在指定的位置就可以自由的调换设备了 例子介绍 本段的例子是逐步递进式的,分为如下几个: 选择获取设备,并将摄像头捕捉到的内容捕捉到video标签 本段的代码在C2-S3-P1 本段的例子目的有以下几个: 申请获取音频视频的输入输出权限,并可以选择使用的设备 获取到输入设备后再页面上展示视频,音频也获取输入后直接输出到video标签 本段给出了主要结构,即使用类RecordApplication来描述这个项目的功能. index.html: WebRTC samples选择输出的设备 使用mediaDevices.enumerateDevices()获取可用的音频/视频输入资源,以及输出设备,然后使用deviceId指定 要使用的资源给getUserMedia() 音频输入: 音频输出: 视频输入: 注意: 如果听到混响声,则说明麦克风正在获取你的输出,请降低音量或将麦克风远离扬声器/耳机 在html部分,我们使用select标签来作为选择输入输出设备的界面.在选在好后通过绑定其事件onchange来触发播放. 要播放的视频资源会绑定到video标签渲染成对象的资源videoElement.srcObject = stream. index.js /** * 录像用的前端项目 */ class RecordApplication { /** * @public {HTMLElement} videoElement - 展示摄像机捕获内容的video标签 * @public {HTMLElement} audioInputSelect - 选择音频输入的元素 * @public {HTMLElement} audioOutputSelect - 选择音频输出的元素 * @public {HTMLElement} videoSelect - 选择视频输入的元素 * @public {Array[HTMLElement]} selectors - 保存所有的输入输出设备元素 */ constructor() { this.videoElement = document.querySelector('video') this.audioInputSelect = document.querySelector('select#audioSource') this.audioOutputSelect = document.querySelector('select#audioOutput') this.videoSelect = document.querySelector('select#videoSource') this.selectors = [this.audioInputSelect, this.audioOutputSelect, this.videoSelect] this.bindEvent() } /** * 为输入输出设备和按钮绑定事件句柄的回调函数 */ bindEvent() { this.audioInputSelect.onchange = () => this.display() this.audioOutputSelect.onchange = () => this.changeAudioDestination() this.videoSelect.onchange = () => this.display() } /** * 初始化页面 */ async init_render() { try { let media_device_infos = await navigator.mediaDevices.enumerateDevices() this.renderDevices(media_device_infos) } catch (error) { console.log('navigator.getUserMedia error: ', error) } } /** * 将指定的输出音频设备放入指定媒体元素 * @param {HTMLElement} element - 要重置的video元素 * @param {string} sinkId - 音频设备id */ async attachSinkId(element, sinkId) { if (typeof (element.sinkId) !== 'undefined') { try { await element.setSinkId(sinkId) console.log('Success, audio output device attached: ' + sinkId) } catch (error) { let errorMessage = error if (error.name === 'SecurityError') { errorMessage = 'You need to use HTTPS for selecting audio output ' + 'device: ' + error } console.error(errorMessage) // Jump back to first output device in the list as it's the default. audioOutputSelect.selectedIndex = 0 } } else { console.warn('Browser does not support output device selection.') } } /** * 切换音频输出的设备 */ async changeAudioDestination() { let audioDestination = this.audioOutputSelect.value await this.attachSinkId(this.videoElement, audioDestination) } /** * 开始播放收集到的音频视频 */ async display() { if (window[\"stream\"]) { window[\"stream\"].getTracks().forEach((track) => { track.stop() }) } let audioSource = this.audioInputSelect.value let videoSource = this.videoSelect.value let constraints = { audio: { deviceId: audioSource ? { exact: audioSource } : undefined }, video: { deviceId: videoSource ? { exact: videoSource } : undefined } } try { let media_stream = await navigator.mediaDevices.getUserMedia(constraints) this.setStream(media_stream) await this.init_render() } catch (error) { console.log('navigator.getUserMedia error: ', error) } } /** * 通过流数据获取流对应的媒体设备信息 * @param {MediaStream} stream */ setStream(stream) { window[\"stream\"] = stream // make stream available to console // 将数据流绑定到video标签 this.videoElement.srcObject = stream // Refresh button list in case labels have become available } /** * 通过媒体设备信息来构造媒体选择页面 * @param {MediaDeviceInfo} deviceInfos */ renderDevices(deviceInfos) { // Handles being called several times to update labels. Preserve values. let values = this.selectors.map((select) => { select.value }) this.selectors.forEach((select) => { while (select.firstChild) { select.removeChild(select.firstChild) } }) // 将设备信息渲染为select中的option选项 for (let deviceInfo of deviceInfos) { let option = document.createElement('option') option.value = deviceInfo.deviceId switch (deviceInfo.kind) { case 'audioinput': option.text = deviceInfo.label || 'microphone ' + (this.audioInputSelect.length + 1) this.audioInputSelect.appendChild(option) break case 'audiooutput': option.text = deviceInfo.label || 'speaker ' + (this.audioOutputSelect.length + 1) this.audioOutputSelect.appendChild(option) break case 'videoinput': option.text = deviceInfo.label || 'camera ' + (this.videoSelect.length + 1) this.videoSelect.appendChild(option) break default: console.log('Some other kind of source/device: ', deviceInfo) } } } } /** * 入口函数,这个入口函数是一个异步函数 */ async function main() { let app = new RecordApplication() await app.init_render() await app.display() } main() 这段代码中主要的操作在 将设备信息渲染为select中的option选项 将流数据绑定到video标签. 让输入视频可以是屏幕 本段的代码在C2-S3-P2 本段的例子目的有以下几个: 获取屏幕的媒体数据流 要捕获屏幕数据,需要使用接口navigator.mediaDevices.getDisplayMedia({ video: true }) 它和getUserMedia一样返回一个promise对象,调用成功返回媒体流,将这个流赋给video元素即可 我们在videoSelect中添加一位值和文本都是\"Local Display\",用它表示我们屏幕上的输出. 修改display方法,如果选了视频中的\"Local Display\"则会将navigator.mediaDevices.getDisplayMedia({ video: true })获得的流中的视频的tracks添加到 input_video_tracks,并将input_video_tracks中原本的视频Tracks删除. 下面是MediaStream对象的属性: 属性 说明 MediaStream.ended 只读,布尔型.如果 ended事件在这个对象上触发了,也就是说这个流已经被完全读取,值为true.如果还没有到达这个流的尾部,值为false. MediaStream.id 只读,这是一个包含36个字符的DOMString,用来作为这个对象的唯一标识符. 下面是MediaStream对象的事件句柄: 事件句柄 说明 MediaStream.onaddtrack 这是addtrack事件在这个对象上触发时调用的事件处理器,这时一个MediaStreamTrack对象被添加到这个流.回调函数参数为event,可以通过其上的属性track来获取这个被添加的track MediaStream.onended 这是当流终止ended时触发的事件. MediaStream.onremovetrack 这是removetrack事件在这个对象上触发事调用的事件处理器,这时一个对象从流上移除.回调函数参数为event,可以通过其上的属性track来获取这个被删除的track 下面是MediaStream对象支持的方法: 方法 说明 MediaStream.addTrack() 存储传入参数MediaStreamTrack的一个副本.如果这个轨道已经被添加到了这个媒体流,什么也不会发生;如果目标轨道为\"完成\"状态(也就是已经到尾部了),一个INVALID_STATE_RAISE异常会产生. MediaStream.clone() 返回这个MediaStream对象的克隆版本.返回的版本会有一个新的ID.返回给定ID的轨道.如果没有参数或者没有指定ID的轨道将返回null.如果有几个轨道有同一个ID,将返回第一个. MediaStream.getTracks() 返回流中所有的MediaStreamTrack列表. MediaStream.getAudioTracks() 返回流中kind属性为audio的MediaStreamTrack列表.顺序是不确定的,不同浏览器间会有不同,每次调用也有可能不同. MediaStream.getTrackById() 返回给定ID的轨道,如果没有参数或者没有指定ID的轨道,将返回null.如果有几个轨道有同一个ID将返回第一个. MediaStream.getVideoTracks() 返回流中kind属性为video的MediaStreamTrack列表.顺序是不确定的,不同浏览器间会有不同,每次调用也有可能不同. MediaStream.removeTrack() 移除作为参数传入的MediaStreamTrack.如果这个轨道不在MediaStream对象中什么也不会发生;如果目标轨道为\"完成\"状态,一个INVALID_STATE_RAISE异常会产生. 需要注意的是: 目前我测试的chrome72.0.3626.119版本不支持录制音频.也许后续版本会支持也说不定. 视频共享会跳出一个界面让选择要共享的是哪块屏幕. 当使用录屏后视屏输入显示的还是Face Time HD Camera,需要点击页面下方的停止共享才能退出 录制 本段的代码在C2-S3-P3 在完成上段例子的基础上我们添加录制功能 本段的例子目的有以下几个: 点击开始按钮后将获取到的视频输入,音频输入并录制,可选格式为webm. 点击download将录制的数据保存为对应的格式 点击截图获取当前录到的图片 录制需要使用MediaRecorder类,我们创建一个实例 let options = { mimeType: this.MimetypeSelect.value } new MediaRecorder(window[\"stream\"], options) 并为其定义一个事件句柄: mediaRecorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) { this.recordedBlobs.push(event.data) } } 这个实例会将在有新数据后就将数据保存到一个名为recordedBlobs的array中. 使用mediaRecorder.start(timeslice)开始录制,使用mediaRecorder.stop()停止了录制.录完的结果就保存在lastrecordedBlobs中. 文件保存 由于我们想用button的点击事件来触发下载,那最简单的方式就是模拟一个a标签的点击事件 savefile(data,filename){ // 创建一个a标签 let save_link = document.createElement('a') // 绑定地址 save_link.href = data // 绑定文件名 save_link.download = filename // 使a标签的点击事件触发 let event = document.createEvent('MouseEvents') event.initEvent(\"click\", true, false) save_link.dispatchEvent(event) } 这个函数可以实现只要调用它就可以触发下载界面. 下载录像 要下载保存录下来的录像,我们需要创建一个Blob对象.然后为这个blob对象创建一个URL用来作为data. let blob = new Blob(this.lastrecordedBlobs, { type: mimetype }) let data = window.URL.createObjectURL(blob) 截图 我们就不复杂化了就保存png格式的图片.我们只需要将video标签的元素放入canvas.getContext('2d').drawImage的第一位,并将图片的大小划分好这个作图的上下文就会保存在canvas中. 之后使用toDataURL(content-type)创建图片的数据对象.我们需要将图片的数据对象中的image/octet-stream改为png的content-type即可 this.canvas.getContext('2d').drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height) let img_png_src = this.canvas.toDataURL(\"image/png\") let imgData = img_png_src.replace(\"image/png\",'image/octet-stream') let filename = new Date().toISOString()+\".png\" this.savefile(imgData,filename) 最后再调用文件保存函数即可 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/使用语音.html":{"url":"web前端技术/前端概览/前端应用调用本地资源/使用语音.html","title":"使用语音","keywords":"","body":"使用语音 在developer.mozilla.org中规定了一种能够让浏览器处理语音数据的规范web speech,这还是个实验中的规范,目前应该只有chrome完全支持. web speech支持两种功能: 语音识别 通过SpeechRecognition接口进行访问,它提供了识别从音频输入(通常是设备默认的语音识别服务)中识别语音情景的能力.一般来说,你将使用该接口的构造函数来构造一个新的SpeechRecognition对象,该对象包含了一些列有效的对象处理函数来检测识别设备麦克风中的语音输入.SpeechGrammar接口则表示了你应用中想要识别的特定文法.文法则通过JSpeech Grammar Format(JSGF.)来定义. 语音合成 通过SpeechSynthesis接口进行访问,它提供了文字到语音(TTS)的能力,这使得程序能够读出它们的文字内容(通常使用设备默认的语音合成器).不同的声音类类型通过SpeechSynthesisVoice对象进行表示,不同部分的文字则由SpeechSynthesisUtterance对象来表示.你可以将它们传递给SpeechSynthesis.speak() 方法来产生语音. 本节代码在C2-S4 语音识别 本段代码在C2-S4-P1. 这个例子我们调用语音识别接口,通过读出red,blue等颜色来改变页面的背景色. index.html 说出颜色,用英文 ...判断的句子 index.js const SpeechRecognition = webkitSpeechRecognition || SpeechRecognition const SpeechGrammarList = webkitSpeechGrammarList || SpeechGrammarList const SpeechRecognitionEvent = webkitSpeechRecognitionEvent || SpeechRecognitionEvent const colors = [ 'aqua' , 'azure' , 'beige', 'bisque', 'black', 'blue', 'brown', 'chocolate', 'coral', 'crimson', 'cyan', 'fuchsia', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'indigo', 'ivory', 'khaki', 'lavender', 'lime', 'linen', 'magenta', 'maroon', 'moccasin', 'navy', 'olive', 'orange', 'orchid', 'peru', 'pink', 'plum', 'purple', 'red', 'salmon', 'sienna', 'silver', 'snow', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'white', 'yellow']; const grammar = '#JSGF V1.0; grammar colors; public = ' + colors.join(' | ') + ' ;' class SpeechRecongnitionApp{ constructor() { // 初始化语音识别接口 this.recognition = new SpeechRecognition() this.speechRecognitionList = new SpeechGrammarList() this.speechRecognitionList.addFromString(grammar, 1) this.recognition.grammars = this.speechRecognitionList this.recognition.lang = 'en-US' this.recognition.interimResults = false this.recognition.maxAlternatives = 1 //控件 this.diagnostic = document.querySelector('.output') this.bg = document.querySelector('html') this.hints = document.querySelector('.hints') this.bindEvent() } bindEvent(){ document.body.onclick = ()=>this.startRecongnition() this.recognition.onresult = (event)=>this.onResult(event) this.recognition.onspeechend = ()=>this.onSpeeched() this.recognition.onnomatch = (event)=>this.onNoMatch() this.recognition.onerror = (event)=>this.onError(event) } htmlRender(){ let colorHTML= '' colors.forEach(function(v, i, a){ console.log(v, i) colorHTML += ' ' + v + ' ' }) this.hints.innerHTML = 'Tap/click then say a color to change the background color of the app. Try '+ colorHTML + '.' } startRecongnition(){ this.recognition.start() console.log('Ready to receive a color command.') } onResult(event){ let last = event.results.length - 1 let color = event.results[last][0].transcript this.diagnostic.textContent = 'Result received: ' + color + '.' this.bg.style.backgroundColor = color console.log('Confidence: ' + event.results[0][0].confidence) } onSpeeched(){ this.recognition.stop() } onNoMatch(){ this.diagnostic.textContent = \"I didn't recognise that color.\" } onError(event){ this.diagnostic.textContent = 'Error occurred in recognition: ' + event.error } } function main() { let app = new SpeechRecongnitionApp() app.htmlRender() } main() 这个例子来自Run recognition demo live,在https://mdn.github.io/web-speech-api/下还有几个有意思的语音识别例子,感兴趣可以看看. 语音识别接口的用法 大致分为几段: 初始化 我们需要初始化创建SpeechRecognition和SpeechGrammarList两个类的实例. SpeechGrammarList是语音识别中使用的匹配规则列表,其中的对象都是SpeechGrammar对象,可以使用JSGF规则定义的字符串来设置规则,然后调用.addFromString(grammar, 1)这个方法来将规则放入SpeechGrammarList的对象列表中.每一个SpeechGrammar对象都可以设置属性weight来修改权重. SpeechRecognition是语音识别的对象,可以设置属性 属性 说明 lang:string 语言 interimResults:bool=false 是否返回临时结果 continuous:bool:false 是否每个识别返回连续结果 maxAlternatives:int=1 最大被选方案数 serviceURI:str 默认为客户端默认的语音识别服务器可以设置. grammars:SpeechGrammarList 设定语法规则列表 定义语音识别的事件句柄的回调函数 SpeechRecognition的事件句柄有: 事件句柄 说明 audiostart 用户开始捕获音频时触发 audioend 用户完成捕获音频时触发 start 当语音识别服务已经开始收听传入音频时触发. end 语音识别服务断开连接时触发. error 发生语音识别错误时触发. nomatch 当语音识别服务返回没有明显识别的最终结果时触发,这可能涉及某种程度的识别.说明其不满足或超过一个置信度阈值. result 语音识别服务返回结果时触发.即单词或短语已被正确识别,并且已将其传回应用程序. soundstart 在检测到任何声音,可识别的语音时触发. soundend 当没有任何可辨认的声音时被触发. speechstart 当识别出有语音时触发 speechend 当识别出语音结束时触发 我们可以根据需要为事件添加回调函数,最常用的有: start speechend error nomatch result 调用方法启动或者关停语音识别 方法 说明 abort() 停止语音识别服务和收听传入音频,并且不会尝试返回结果 start() 启动语音识别服务,听取传入的音频. stop() 停止语音识别服务以收听传入音频,并尝试使用到目前为止捕获的音频返回结果. 通常我们需要一个外部的条件触发start方法,但stop可以是外部触发,也可以是放在语音识别的事件中,比如发现没有声音了就退出这样 语音合成 本段代码在C2-S4-P2. 不像语音识别接口,SpeechSynthesis这个接口多数浏览器都已经支持了. 这个例子我们制作一个表单,这个表单有一个文本框输入,一个下拉选单用于选语音,两个和一个提交按钮,点击提交或切换语音后我们使用语音合成读出选择的内容. 语音和成使用的是window.speechSynthesis接口其步骤是: 使用window.speechSynthesis.getVoices()可以获取到音源列表 创建SpeechSynthesisUtterance(text:string)的实例来构造一个发音对象 设置发音对象的属性voice来定义一个音源(window.speechSynthesis.getVoices()这个中的一个元素) 设置发音对象的属性pitch来定义发音对象的语调(float) 设置发音对象的属性rate来定义语速(float) 使用window.speechSynthesis.speak(utter:SpeechSynthesisUtterance)读出内容. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/使用本地多线程资源.html":{"url":"web前端技术/前端概览/前端应用调用本地资源/使用本地多线程资源.html","title":"使用本地多线程资源","keywords":"","body":"使用本地多线程资源 html页面的渲染时单线程的,也就是说在页面脚本渲染完成之前页面都是阻塞状态. web worker是运行在后台的JavaScript线程,它独立于其他脚本,不会影响页面的性能,因为是另起了线程,在主页面继续做任何事情都不会影响到后面起的webworker线程.换句话说就是浏览器为前端应用提供了多线程功能. 需要注意的是webworker不能直接双击html文件启动的状态下使用,要使用必须要有服务端环境,即便是静态服务也行. worker可以再生成子worker,这和多线程编程是一样的. webworker的种类 常见的webworker分为两种 dedicated worker 直接使用类Worker或window.Worker实例化.使用postMessage交互是通过传递副本,而不是直接共享数据. dedicated worker的运行逻辑如下: 我们通过new Worker(path_to_worker_js)生成一个worker实例,即子线程 父线程使用worker.onmessage事件句柄监听子线程发送过来的消息,回调函数的参数为event中属性.data即为传递来的消息 父线程使用worker.onerror事件句柄监听子线程是否报错 父线程使用worker.postMessage(msg)方法向子线程传递消息 父线程使用worker.terminate()方法关闭子线程 子线程为全局变量接口onmessage赋值一个参数为event的函数用于监听父线程传递来的消息,回调函数的参数为event中属性.data即为传递来的消息 子线程使用全局方法postMessage(msg)向父线程传递消息 子线程使用全局方法close()自己关闭自己 shared worker 使用类SharedWorker或window.SharedWorker实例化.可被不同的窗体的多个脚本运行,例如IFrames等,只要这些workers处于同一主域.shared worker比dedicated worker稍微复杂一点--脚本必须通过活动端口进行通讯. 这种worker适合用于一个域下有多个页面的情况. shared worker的运行逻辑如下: 我们通过new SharedWorker(path_to_worker_js)生成一个worker实例,即子线程. 父线程使用worker.port.start()来手动启动一个端口用于通讯 父线程使用worker.port.onmessage事件句柄监听子线程发送过来的消息,回调函数的参数为event中属性.data即为传递来的消息 父线程使用worker.port.postMessage(msg)方法向子线程传递消息 父线程使用worker.terminate()方法关闭子线程 子线程为全局变量接口onconnect赋值一个参数为event的函数用于监听父线程传递来的消息,回调函数的参数为event中属性.ports即为所有启动的端口列表. 子线程使用事件句柄port.onmessage接受来自父线程的消息 子线程使用全局方法port.postMessage(msg)向父线程传递消息 子线程使用全局方法close()自己关闭自己 webworker中可以调用的接口 全局方法包括 函数 说明 atob(string) 对用base-64编码过的字符串进行解码 btoa(string) 对字符串进行base-64编码 clearInterval() 取消先前通过调用setInterval()建立的周期执行程序 clearTimeout() 取消了先前通过调用setTimeout()建立的定时器 dump(msg) 将信息打印到(本地)控制台(console) setInterval() 设置周期性执行程序 setTimeout() 设置定时器 支持的浏览器API 这个会不断更新,可以查看https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers#APIs_available_in_workers postMessage可以传递的消息类型 对象类型 注意 所有的原始类型 symbols除外 Boolean --- String --- Date --- RegExp lastIndex字段不会被保留 Blob --- File --- FileList --- ArrayBuffer --- ArrayBufferView 这基本上意味着所有的类型化数组,如Int32Array等 ImageData --- Array --- Object 仅包括普通对象(如对象字面量) Map --- Set --- 基本上除了Function和Error,Event,Promise外都可以传 在webworker中import第三方模块 Worker线程能够访问一个全局函数importScripts()来引入脚本,该函数接受0个或者多个URI作为参数来引入资源,以下例子都是合法的: importScripts(); /* 什么都不引入 */ importScripts('foo.js'); /* 只引入 \"foo.js\" */ importScripts('foo.js', 'bar.js'); /* 引入两个脚本 */ 浏览器加载并运行每一个列出的脚本.每个脚本中的全局对象都能够被worker使用.如果脚本无法加载将抛出 NETWORK_ERROR异常,接下来的代码也无法执行.而之前执行的代码(包括使用window.setTimeout()异步执行的代码)依然能够运行.importScripts()之后的函数声明依然会被保留,因为它们始终会在其他代码之前运行. 注意:脚本的下载顺序不固定,但执行时会按照传入importScripts()中的文件名顺序进行.这个过程是同步完成的;直到所有脚本都下载并运行完毕importScripts()才会返回. 最简单的dedicated worker例子 本节的代码在C2-S5-P1 这个例子中我们使用dedicated worker实现了一个算乘法的简单功能. 输入框中输入两个数,回车后我们的主线程就会将两个输入框中的值发送给子线程计算乘法的结果,算好后子线程再将结果发送回主线程,主线程接收到结果后渲染到页面. index.js class MulApplication { constructor() { // 控件 this.first = document.querySelector('#number1') this.second = document.querySelector('#number2') this.result = document.querySelector('.result') this.myWorker = new Worker(\"worker.js\") // 绑定事件 this.bindEvent() } /** * 为输入输出设备和按钮绑定事件句柄的回调函数 */ bindEvent() { this.first.onchange = () => this.query() this.second.onchange = () => this.query() this.myWorker.onmessage = (event) => this.onResult(event) this.myWorker.onerror = (e)=> console.log(e) } /** * 向worker请求计算结果 */ query() { this.myWorker.postMessage([this.first.value, this.second.value]) console.log('Message posted to worker') } /** * 收到结果后将其渲染到result位置 * @param {Event} event - 消息传递事件 */ onResult(event) { this.result.textContent = event.data; console.log('Message received from worker'); } } /** * 入口函数,这个入口函数是一个异步函数 */ function main() { let app = new MulApplication() } main() worker.js /** * 将数据相乘 * @param {Event} event - 消息传递事件 */ function mul(event) { console.log('Worker: Message received from main script') let result = event.data[0] * event.data[1] if (isNaN(result)) { postMessage('Please write two numbers') } else { let workerResult = 'Result: ' + result console.log('Worker: Posting message back to main script') postMessage(workerResult) } } addEventListener(\"message\", mul) 最简单的shared worker例子 本节的代码在C2-S5-P2 这个例子是上一个例子的扩展.我们使用shared worker为同一个域中的页面服务. 我们定义两个页面: index.html用于计算两数相乘,对应的js为index.js /** * 计算乘法用的应用 */ class MulApplication { constructor() { // 控件 this.first = document.querySelector('#number1') this.second = document.querySelector('#number2') this.form = document.querySelector('form') this.result1 = document.querySelector('.result1') this.myWorker = new SharedWorker(\"worker.js\") // 绑定事件 this.bindEvent() } /** * 为输入输出设备和按钮绑定事件句柄的回调函数 */ bindEvent() { this.first.onchange = () => this.query() this.second.onchange = () => this.query() this.form.onsubmit = function (e) { e.preventDefault() } this.myWorker.port.onmessage = (event) => this.onResult(event) } /** * 向worker请求计算结果 */ query() { this.myWorker.port.postMessage([this.first.value, this.second.value]) console.log('Message posted to worker') } /** * 收到结果后将其渲染到result位置 * @param {Event} event - 消息传递事件 */ onResult(event) { this.result1.textContent = event.data; console.log('Message received from worker'); } } /** * 入口函数,这个入口函数是一个异步函数 */ function main() { let app = new MulApplication() } main() square.html计算平方,使用的js为square.js class SquareApplication { constructor() { // 控件 this.squareNumber = document.querySelector('#number3') this.result2 = document.querySelector('.result2') this.form = document.querySelector('form') this.myWorker = new SharedWorker(\"worker.js\") // 绑定事件 this.bindEvent() } /** * 为输入输出设备和按钮绑定事件句柄的回调函数 */ bindEvent() { this.squareNumber.onchange = () => this.query() this.form.onsubmit = function (e) { e.preventDefault() } this.myWorker.port.onmessage = (event) => this.onResult(event) } /** * 向worker请求计算结果 */ query() { this.myWorker.port.postMessage([this.squareNumber.value, this.squareNumber.value]) console.log('Message posted to worker') } /** * 收到结果后将其渲染到result位置 * @param {Event} event - 消息传递事件 */ onResult(event) { this.result2.textContent = event.data; console.log('Message received from worker'); } } /** * 入口函数,这个入口函数是一个异步函数 */ function main() { let app = new SquareApplication() } main() 这两个页面共用一个后台的worker: worker onconnect = function (e) { let port = e.ports[0] port.onmessage = function (e) { let workerResult = 'Result: ' + (e.data[0] * e.data[1]) port.postMessage(workerResult) } } 需要注意,port是在连接建立后才能获取的对象. 使用webworker结合ffmpeg.js让录屏的下载视频为mp4格式 本节的代码在C2-S5-P3 本项目并没有自己写worker,而是使用的kagami/ffmpeg封装的ffmpeg.js项目.它可以使用npm install ffmpeg.js安装,装好后进入这个模块找出ffmpeg-worker-mp4.js放入public文件夹.使用的时候Worker初始化指定这个文件即可.具体如何使用可以看这个项目的README.md. 这个包的基本使用方法是 向worker发送一个形为 myWorker.postMessage({ type:\"run\", arguments: '-nostdin -i video.webm output.mp4'.split(' '), MEMFS: [{name: \"video.webm\", data: data}], TOTAL_MEMORY: 128 * 1024 * 1024 }) 的对象,其中type指定操作,arguments指定命令行参数,MEMFS指定视频文件信息,值得注意的是TOTAL_MEMORY,这是一个编译选项,用于设置使用多大的内存做编码解码工作.默认是64m.我是不够用. 定义监听函数根据返回数据的type判断后续动作. getMp4Result(event){ let message = event.data console.log('Message received from worker') switch (message.type){ case \"ready\":{ console.log('ffmpeg.js file has been loaded.') } break case \"stdout\":{ console.log(message.data) } break case \"stderr\":{ console.log('ffmpeg.js stderr.') console.log(message.data) } break case \"done\":{ console.log(JSON.stringify(message)) //let result = message.data[0] let result = message.data.MEMFS[0] // console.log(JSON.stringify(result)) let blob = new File([result.data], 'test.mp4', { type: 'video/mp4' }); // console.log(JSON.stringify(blob)); this.lastrecordedBlobs = blob this.downloadButton.hidden = false this.RecordButton.hidden = false } break case \"exit\":{ console.log('ffmpeg.js worker exit.') } break case \"error\":{ console.log('ffmpeg.js worker error.') console.log(JSON.stringify(message)) console.log(message.data) } break } } 当正常编码后数据会通过type为done的消息传递过来,我们要的文件数据就在message.data.MEMFS[i].data中. 由于项目编码完全是异步的,我们需要在交互逻辑上做一些改变,比如下载按钮需要在编码完成后才出现,编码过程中不能进行录制等,这些操作都可以在donetype下执行. 后续的学习 更加详细的介绍可以看https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用调用本地资源/使用本地gpu计算资源.html":{"url":"web前端技术/前端概览/前端应用调用本地资源/使用本地gpu计算资源.html","title":"使用本地gpu计算资源","keywords":"","body":"使用本地GPU的计算资源 webgl是浏览器上的opengl,它可以直接操作gpu进行运算渲染,然后渲染到canvas或者其他什么上面 webgl相当底层,并不适合没有opengl基础的人,而我们也没兴趣拿他做什么渲染,高性能计算才是我们感兴趣的. google在2018年开源了他们基于webgl的前端高性能计算框架tensorflow for javascript(tfjs),当然这个框架主要是做deeplearning的,但即便如此我们也可以使用它来调用gpu来做一些计算工作. 前端项目使用tfjs进行矩阵计算 这个项目在C2-S6-P1 这个项目只使用了tfjs的matMul接口.通常用tfjs做运算的流程是这样: 使用数组创建张量(矩阵)tf.tensor(arr),这个过程张量会被加载到gpu 控制张量对象计算过程 使用.array()接口从gpu中取出计算结果 使用tf.dispose(a)或者a.dispose()手动释放张量内存,也可以使用 const y = tf.tidy(() => { const result = a.square().log().neg() return result }) 来回收一个函数中执行过程中产生的所有Tensor 而这个result的值也就是这个y的值,注意这种方式无法返回Promise. 需要注意由于从gpu取出计算结果是一个异步的过程. tfjs的接口可以在https://js.tensorflow.org/api/latest/找到,但拿前端训练数据实在是有点不现实.常规来说还是做做矩阵运算靠谱一些. class matMulApplication { constructor() { // 控件 this.n = document.querySelector('#n') this.m = document.querySelector('#m') this.form = document.querySelector('form') this.result = document.querySelector('#result') // 绑定事件 this.bindEvent() } /** * 为输入输出设备和按钮绑定事件句柄的回调函数 */ bindEvent() { this.form.onsubmit = (e) => { e.preventDefault() this.calcul() } } /** * 计算 */ randomMatrix(n, m) { let result = [] for (let i = 0; i ## 使用TensorFlow训练好的模型 --> Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用与通信/":{"url":"web前端技术/前端概览/前端应用与通信/","title":"前端应用与通信","keywords":"","body":"前端应用与通信 web技术最大的优势是通用性和快速实现的能力,最大的劣势则是安全性和性能.这点在前端应用的通信方式上可以比较好的体现,比如由于通用性好便于调试,Restful接口和各种基于http协议的rpc是催常见的微服务接口形式.而如何解决各种性能问题提高并发,以及安全问题则是web技术的永恒课题. 前端项目的数据通常都是从外部获取的,这个外部包括服务端和其他前端项目.通常我们可将它分为3类: 前端项目与服务器间请求响应模式的通信,主要包括ajax及相关技术和grpc-web技术 前端项目与服务器间的双工通信,主要包括websocket技术. 前端项目与其他前端项目间的p2p通信,主要包括webrtc技术. 这些技术模式不同使用场景也不同. 基于ajax的RESTful接口由于其对于描述资源表现力出色,通常用于最外一层向外部提供基于数据库的业务逻辑接口服务.其同步的特性注定了对于计算密集型任务这类比较重负载的任务它并不是最好的解决方案. grpc-web在一定程度上解决了RESTful接口同步的问题,但它依然是请求响应模式,并且其表现力不及RESTful接口因此通常用作对外部提供比较重的计算服务.比如如果我们要为训练出来的一个分类模型提供服务接口,那可能grpc-web更加合适.使用grpc体验上和调用函数差不多因此也适合作为代替sdk的的接口服务 而websocket更加关注于有推送的业务场景.通常一些订阅信息比如一个定期推送新闻的应用就会使用它. webrtc技术则因其p2p的特性相对更加私密对于一些关注区中心话的产品可能用它的就会多些 本文将顺次介绍 ajax及相关技术 websocket技术 grpc-web技术 利用webrtc进行端对端通信 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用与通信/ajax及相关技术.html":{"url":"web前端技术/前端概览/前端应用与通信/ajax及相关技术.html","title":"ajax及相关技术","keywords":"","body":"ajax及相关技术 前端项目往往只是作为展现层(view层).数据,业务运算往往要依赖后端服务器,因此与服务器间的通信是非常重要的.在最开始的时候http协议只想做个用于发布和接收HTML页面的协议,它不想搞得太复杂,但随着时代的变迁,越来越多的通信需求让它与服务器间的交互手段越来越多,web的发展是在太快,很少有实现快于标准的技术,而web技术就是一个.回顾历史,在最初的时候前端app只能通过提交表单来与服务器交互,到后来出现了ajax,可以通过XML作为数据的表现层协议来做到与服务端的频繁通讯.再后来json逐渐取代了XML的地位,而更加规范更加符合直觉的RESTful接口成了前端与后台通讯的首选.现在facebook提倡的GraphQL 这些花样繁多的技术其本质都是一样的,即请求响应模式: 前端向后端发起请求 后端响应请求并带上请求的结果数据. 这其实就是利用的http协议本身.浏览器获取页面也是同样的模式. 下面开始我们从例子出发来看看如何向后端发起请求. 本文适合配合本js攻略的使用Javascript构建RESTful接口服务文章一起看 本文例子在C3-S1 axios 本文例子在C3-S1-P1 本质上axios是各家浏览器XMLHttpRequest的封装,因此它具有最好的通用性,而且node中也可以使用,所以是向后端发起请求的首选工具. 我们来实现一个网页来抓取github上最近注册的用户数据,并展示到页面上.这个页面和项目C0功能一样,我们这边只是替换其请求方式. fetch fetch是一个和XMLHttpRequest同级的底层接口,但老浏览器并不支持它使他的使用受到了限制,我们在项目C0中已经实现了这个例子这边就不再重复 顺道一提要在node中使用fetch可以安装node-fetch 浏览器的同源策略与跨域请求 上面的例子中我们很轻易的就访问到了数据,但并不是所有的请求都可以如此轻易,因为浏览器有同源策略--前端页面只能访问与之协议同域名同端口的后端服务. 服务器A上的页面想要获取服务器B上的资源,这种行为叫跨域请求. 这个可以看项目C3-S1-P2.这个项目会在端口4000起一个后端服务来提供api,而前端静态页面服务的端口是3000. 可以看到结果,在4000端口的页面正常使用,而3000端口的会报错误,F12打开控制台可以看到是跨域错误. 这个问题呢其实比较尴尬,是只有通过浏览器访问才会碰到的问题所以应该归属于前端问题,但其解决方案和前端没有一点关系.解决跨域问题常见的是两种方式: 服务端添加跨域支持 使用反向代理 如果是使用服务端添加跨域支持的方法,那么就要用到CORS(跨域共享请求Cross-origin resource sharing).其实现方式就是浏览器会检查上面服务器B的HTTP头(HEAD请求),如果Access-Control-Allow-Origin中有\"A\",或者是通配符*,浏览器就会允许跨域, 本文的例子P3就是借助koa2-cors做的一个支持跨域的服务端.执行这个例子,我们可以看到问题就解决了. 如果希望使用代理解决,那么可以看我关于[nginx的这篇博客]中的相关内容. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用与通信/websocket.html":{"url":"web前端技术/前端概览/前端应用与通信/websocket.html","title":"websocket","keywords":"","body":"websocket websocket则是一种相对颠覆协议,它用起来和tcp的套接字类似,可以实现客户端(浏览器)和服务器间的双工通信. 在websocket之前,大家往往使用轮询技术来模拟双工通信,轮询是在特定的的时间间隔(如每1秒)由浏览器对服务器发出HTTP request,然后由服务器返回最新的数据给客户端的浏览器.这种传统的request-response的模式带来很明显的缺点--浏览器需要不断的向服务器发出请求,从而占用大量的流量.同时HTTP request的header是非常长的,里面包含的有用数据可能只是一个很小的值,这样会占用很多不必要的带宽. 使用websocket的话浏览器和服务器只需要做一个握手的动作,这之后浏览器和服务器之间就形成了一条快速通道.两者之间就直接可以数据互相传送.在此WebSocket协议中，为我们实现即时服务带来了两大好处: 长连接 一旦建立连接除非关闭否则可以一直相互通信,包括服务端也可以主动推送信息 安全高效 一次连接只用验证一次用户,大大减小了验权的频率. 对websocket原理感兴趣的可以看下我js后端的ws服务器攻略 websockets api使用示例 这个例子的代码在C3-S2 前端项目可以直接通过浏览器的websockets api来直接和后端的ws服务器建立连接. 本例复用'js后端的ws服务器'篇中的例子helloworld作为后端, 我们来基于这个构建一个前端例子. 由于后端我们已经有一个docker镜像,我们可以直接使用docker启动它. 这个项目很简单点击按钮我们就向后端ws服务器发送一个helloworld消息,后端收到后就原样传回来,前端则监听message事件由数据传过来就新建个p标签的节点插入到main节点下. index.js class WebsocketApp { constructor() { this.ws = new WebSocket(\"ws://localhost:4000\") this.container = document.querySelector(\"main\") this.button = document.querySelector(\"main button\") this.bind_event() console.log(\"init\") } bind_event() { this.button.onclick = () => this.onClick() // 注意这里和node中ws框架下不一致,事件监听接口的命名规则和其他前端事件一样. this.ws.onclose = () => { console.log('disconnected'); } this.ws.onmessage = (message_event) => this.onMessage(message_event) console.log(\"bind\") } onClick() { this.ws.send('helloworld') } onMessage(message_event) { // 注意这里和node中ws框架下不一致,数据放在event.data中 console.log(message_event.data) let content = message_event.data let p = document.createElement(\"p\") p.innerText = content this.container.appendChild(p) } } function main() { let app = new WebsocketApp() } main() index.html websocket demo 点击请求 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用与通信/grpc-web.html":{"url":"web前端技术/前端概览/前端应用与通信/grpc-web.html","title":"grpc-web","keywords":"","body":"grpc-web grpc-web是google新推出的一种前端与后端交互的方式,它的本质是让前端可以作为grpc的客户端直接与服务端交互. grpc-web的使用相对是比较麻烦的,它必须依托于: grpc服务器 一个webgrpc的代理用于将grpc转为http2的服务 使用grpc-web的前端项目 开发环境依赖 grpc-web的开发需要工具protoc和grpc-web将protobuf文件编译为js模块.主意安装好后我们需要先将这两个放入PATH环境变量 安装好这两个后我们可以使用如下命令将目标protobuf文件编译为 protoc -I=$proto_dir $proto_file \\ --js_out=import_style=commonjs:$target_dir \\ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:$target_dir 其中import_style=commonjs表示编译出来的js模块使用commonjs标准引用,即require('mod') 其中mode=grpcwebtext表示编译出来的js模块使用Content-type: application/grpc-web-text且使用base64-encoded编码数据 webgrpc的代理 我们当然希望前端可以直接和grpc服务端相连,但现在官方还没有解决方案,只能借助一层网关来代理的grpc服务端,使之可以接收http请求. 官方推荐的是使用envoy作为grpc-web的代理,这个东西整体来说太重了但其他的工具目前看都无法使用. envoy.yml admin: access_log_path: /tmp/admin_access.log address: socket_address: { address: 0.0.0.0, port_value: 9901 } static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8000 } # 这里修改对外暴露的端口和hostname filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: local_service domains: [\"*\"] routes: - match: { prefix: \"/\" } route: cluster: test_service max_grpc_timeout: 0s cors: allow_origin: - \"*\" allow_methods: GET, PUT, DELETE, POST, OPTIONS allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout max_age: \"1728000\" expose_headers: custom-header-1,grpc-status,grpc-message enabled: true http_filters: - name: envoy.grpc_web - name: envoy.cors - name: envoy.router clusters: - name: test_service connect_timeout: 0.25s type: logical_dns http2_protocol_options: {} lb_policy: round_robin hosts: [{ socket_address: { address: grpc-api, port_value: 5000 }}]# 这里修改要代理的服务器 一个简单的例子 我们来代理使用js搭建后端服务攻略中grpc部分的C0项目. 本项目放在C3-S3 服务端部分 我们使用envoy的官方镜像来实现对grpc-web的网关. docker-compose.yml version: '3.6' services: grpc_web_proxy: image: envoyproxy/envoy-dev:latest depends_on: - grpc-api ports: - 8000:8000 networks: - rest_test logging: options: max-size: \"10m\" max-file: \"3\" volumes: - ./envoy.yaml:/etc/envoy/envoy.yaml command: /usr/local/bin/envoy -c /etc/envoy/envoy.yaml -l trace --log-path /tmp/envoy_info.log grpc-api: image: hsz1273327/js-server:grpc_c0 networks: - rest_test networks: rest_test: 前端部分 前端部分我们修改自websocket的例子,只是点击以后发送和接收改为了使用grpc-web而已. 修改package.json 由于编译出来的pb模块是commonjs的引用形式,而浏览器端是没有require方法的,所以这时候我们就需要借助一些前端模块化编程工具,当然我们可以使用webpack,但这个对于我们这个简单的项目来说太重,因此你我们使用的是更加轻量的browserify 我们将编译pb文件和打包js都写到package.json中 ... \"scripts\": { \"start\": \"./node_modules/.bin/live-server --port=3000 public\", \"build\": \"./node_modules/.bin/babel es -d public\", \"browserify\":\"browserify public/main.js > public/index.js\", \"build_pb\": \"protoc -I=schema square_service.proto --js_out=import_style=commonjs:es --grpc-web_out=import_style=commonjs,mode=grpcwebtext:es\" }, ... 入口模块为es/main.js编译后使用的js文件为index.js 执行npm run build_pb在es文件夹下生成grpc到js的模块 编辑main.js const { Message } = require('./square_service_pb.js') const { SquareServiceClient } = require('./square_service_grpc_web_pb.js') class WebGrpcApp { constructor() { this.clientcb = new SquareServiceClient('http://localhost:8000') this.container = document.querySelector(\"main\") this.button = document.querySelector(\"main button\") this.bind_event() console.log(\"init\") } bind_event() { this.button.onclick = () => this.onClick() console.log(\"bind\") } onClick() { let query = new Message() query.setMessage(12.3) console.log(query) ///grpc-web基于回调 this.clientcb.square(query, {}, (error, message) => this.onMessage(error, message)) } onMessage(error, message) { console.log(message) let content = message let p = document.createElement(\"p\") p.innerText = content this.container.appendChild(p) } } function main() { let app = new WebGrpcApp() } main() 执行npm run build=>npm run browserify在public文件夹下创建出index.js 执行npm start 在页面上点击按钮,稍等一会儿就可以看到结果了 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用与通信/WebRTC进行端对端通信.html":{"url":"web前端技术/前端概览/前端应用与通信/WebRTC进行端对端通信.html","title":"WebRTC进行端对端通信","keywords":"","body":"WebRTC WebRTC是一项革命性的技术.其api)可以点击查阅. webRTC除了控制摄像头麦克风,更关键的特性是支持p2p通信. 几个概念 SDP一种会话描述格式 iceServers(Interactive Connectivity Establishment Servers)交互式连接建立服务器 DTLS(Datagram Transport Layer Security)数据包传输层安全性协议 SCTP(Stream Control Transmission Protocol)流控制传输协议 RTP(Real TimeProtocol)实时协议 RTCP(Real-time ControlProtocol)实时传输控制协议 SRTP(SecureReal-time Transport Protocol)安全实时传输协议 STUN(Simple Traversal of UDP Through NATs)用UDP穿透NAT的服务 TURN(Traversal Using Relays around NAT)使用中继穿透NAT--STUN的中继扩展,自己可以使用这个镜像来部署 更多的p2p相关技术可以看这篇文章 建立连接的过程 类RTCPeerConnection用于处理p2p连接,其使用方法是: let connection = new RTCPeerConnection([configuration]) 我们可以创建的时候加入设置,也可以创建后用.setConfiguration(restartConfig)方法来设置这个连接. 比较重要的是iceServers这个参数,它用于穿过防火墙 { 'iceServers': [{'url': 'stun:23.21.150.121'}] } { 'optional': [{'DtlsSrtpKeyAgreement': true}] } 通常我们需要借助stun(Session Traversal Utilities for NAT)服务来帮助我们实现NAT穿越. 国内可用的免费stun有: stun:stun1.l.google.com:19302 stun:stun2.l.google.com:19302 stun:stun3.l.google.com:19302 stun:stun4.l.google.com:19302 stun:23.21.150.121 stun:stun01.sipphone.com stun:stun.ekiga.net stun:stun.fwdnet.net stun:stun.ideasip.com stun:stun.iptel.org stun:stun.rixtelecom.se stun:stun.schlund.de stun:stunserver.org stun:stun.softjoys.com stun:stun.voiparound.com stun:stun.voipbuster.com stun:stun.voipstunt.com stun:stun.voxgratia.org stun:stun.xten.com 完成这个配置之后就是为通道创建端点连接了.一根管道当然是有两个端点,所以肯定会要有两个RTCPeerConnection的实例,本机一端叫localConnection,另一机一端叫remoteConnection 连接实例可以有事件绑定 事件句柄 说明 onaddstream 连接上添加了流 onconnectionstatechange 连接状态改变 ondatachannel 当RTCDataChannel由调用createDataChannel()的远程对等体添加到连接时会发送类型为RTCDataChannelEvent的此事件. onicecandidate 每当本地ICE代理需要通过信令服务器将消息递送到另一对等体时发生 oniceconnectionstatechange 当由iceConnectionState属性表示的连接的ICE代理的状态发生变化时会发生这种情况 onicegatheringstatechange 当ICE收集状态(即ICE代理是否主动收集候选项)时发生这种情况 onidentityresult 当生成身份断言时,通过getIdentityAssertion()或在提供或回答的创建期间发送此类事件 onidpassertionerror 当相关联的身份提供商(IdP)在生成身份断言时遇到错误时,发送这样的事件. onidpvalidationerror 当相关联的身份提供商(IdP)在验证身份断言时遇到错误时,发送这样的事件. onnegotiationneeded 当发生需要进行会话协商的更改时,会触发此事件. onpeeridentity 当从对等体接收到的身份断言已经被成功验证时,发送这样的事件. onremovestream 当从此连接中删除MediaStream时,将发送此类事件. onsignalingstatechange 当RTCPeerConnection.signalingState的值更改时,作为调用setLocalDescription()或setRemoteDescription()的结果将发送此事件. ontrack 当创建了新的传入MediaStreamTrack并与已在连接时添加到该组接收器的RTCRtpReceiver对象相关联时会发送此事件 我们要让两端可以通信,除了要建立连接,还要在同一个频道,RTCPeerConnection的实例的.createDataChannel(channelname[,option])方法就是用来创建频道,一般都是在本机端创建频道,频道可以有 .onopen和.onclose两个事件绑定 而另一机那端则是并不需要,但一般要设置ondatachannel来确认通道建立成功. 接着我们需要两个端点都有有icecandidate,就用刚才的事件绑定onicecandidate: localConnection.onicecandidate = e => !e.candidate || remoteConnection.addIceCandidate(e.candidate) .catch(handleAddCandidateError) 另一端也是一样,IceCandidate需要两边都有. 有了连接,有了通道,还要为两端找到标识,这样才能两边建立连通的连接.RTCSessionDescription就是这个标识. localConnection.createOffer()可以产生一个offer,也就是一个包含元数据信息的RTCSessionDescription的promise,接着我们可以拿这个offer来设置为本机的SessionDescription localConnection.setLocalDescription(offer) 所谓SessionDescription就是一组对连接的唯一表示元数据,包括RTCSessionDescription.type和RTCSessionDescription.sdp两部分,可以用.toJSON()方法获得json格式序列化后的数据. 每个端点都必须要知道自己的唯一标识和对面的唯一标识,我们本地的连接有了自己的唯一标识,但还不知道对面的唯一标识,这时候就需要一个服务器来传递这个标识到另一端,而另一端则要先用.setRemoteDescription(offer)记录自己对面的标识,之后使用remoteConnection.createAnswer()来创建回应的RTCSessionDescription,并将之设置为自己的标识.setLocalDescription(answer),然后再把这个answer传回给之前的端点连接 这个用来转发标识的服务器就是所谓的发信服务器了.事实上发信服务器只是一个简单的消息传递,数据传递是p2p的.发信服务器没有限制,只要能发能收就可以了我们完全可以用websocket来实现.当然了,实际上只要能交换就行,因此不通过服务器,而是通过其他比如im呀,邮件呀,人肉呀的方法也是完全可以的. 这样就可以用浏览器实现直播,视频通话之类的功能,这样一些原本只能通过客户端实现的功能了 总结下webrtc的连接建立顺序: 创建端点RTCPeerConnection 创建channel,这时我们设置的ice服务器就可以触发让我们获得IceCandidate的事件 两端通过发信服务器相互交换IceCandidate并互设彼此为IceCandidate,用addIceCandidate()方法 创建offer获取本机RTCSessionDescription,并设置为本机的LocalDescription,之后通过发信服务器发送给对面 对面接收到本机offer后将之设为RemoteDescription,然后在创建answer,并设为LocalDescription,之后再将answer通过发信服务器发送回本机 或得到answer后将之设置为本机的RemoteDescription 通过发信服务器建立连接 本例在C3-S4 我们可以用websocket来建立发信服务器.一个发信服务器应该有如下几个接口: offer:用来将offer传出 answer: 用来将answer传回 candidate:用来交换candidate 而这个业务流程应该是: 用户A通过接口candidate发现用户B在线 用户A通过发信服务向其发送一个offer 用户B收到offer后确认通过发信服务发回answer给用户A 消息传递 这个部分对应文件夹message中的内容. 消息传递只需要使用DataChannel的send方法即可. index.js const WSURL = 'ws://localhost:4500' const CONNECT_CFG = { 'iceServers': [{ 'url': 'stun:23.21.150.121' }], 'optional': [{ 'DtlsSrtpKeyAgreement': true }] } let storage = localStorage class WebrtcApplication { constructor(wsurl = WSURL, connectcfg = CONNECT_CFG) { this.wsurl = wsurl this.connectcfg = connectcfg this.socket = null this.connection = null this.channel = null this.socketStatus = document.getElementById('ws-status') this.roomInfoList = document.getElementById('room-info') this.roomForm = document.getElementById('room-form') this.usernameField = document.getElementById('username') this.roomField = document.getElementById('room') this.createRoomBtn = document.getElementById('create_room') this.leaveRoomBtn = document.getElementById('leave_room') this.messagesList = document.getElementById('messages') this.messagesSubmit = document.getElementById('submit') this.messageField = document.getElementById('message') this.statueMsg = document.getElementById(\"channel-status\") this.leaveChannelBtn = document.getElementById('leave_channel') this.connection_init() this.socket_init() this.bind_event() } socketOnError(error) { console.log('WebSocket Error: ' + error.message) } socketOnConnect() { this.socketStatus.innerHTML = `Connected to: ${this.wsurl}` this.socketStatus.className = 'open' } socketOnDisconnect() { this.socketStatus.innerHTML = 'Disconnected from WebSocket.' this.socketStatus.className = 'closed' } socketOnAnswer(data) { console.log(`answer: ${data}`) let message = data.sdp let remote_session_desc = new RTCSessionDescription(data) this.connection.setRemoteDescription(remote_session_desc) console.log(this.connection.remoteDescription) this.roomInfoList.innerHTML += `Remote:${message}` console.log(`now con ${this.connection.iceConnectionState}`) } async socketOnOffer(data) { console.log(`offer ${data}`) let message = data.sdp this.roomInfoList.innerHTML += `Remote:${message}` let remote_session_desc = new RTCSessionDescription(data) await this.connection.setRemoteDescription(remote_session_desc) let answer = await this.connection.createAnswer() console.log(`answer:${answer}`) this.roomInfoList.innerHTML += `Local:${answer.sdp}` this.connection.setLocalDescription(answer) let sendinfo = { \"room\": storage.getItem(\"room\"), \"answer\": answer } this.socket.emit(\"answer\", sendinfo, (data) => console.log(data)) console.log(\"now con\") } socketOnMessage(data) { this.roomInfoList.innerHTML += `message:${data}` } socketOnCandidate(data) { console.log(data) this.connection.addIceCandidate(data) this.roomInfoList.innerHTML += `candidate:${data.candidate}added` } socket_init() { console.log(\"socket_init\") this.socket = io(this.wsurl) this.socket.on(\"error\", (error) => (error) => this.socketOnError(error)) this.socket.on(\"connect\", () => this.socketOnConnect()) this.socket.on(\"disconnect\", () => this.socketOnDisconnect()) this.socket.on(\"answer\", (data) => this.socketOnAnswer(data)) this.socket.on(\"offer\", (data) => this.socketOnOffer(data)) this.socket.on(\"message\", (data) => this.socketOnMessage(data)) this.socket.on(\"candidate\", (data) => this.socketOnCandidate(data)) } channelOnMessage(event) { this.messagesList.innerHTML += `Remote message:${event.data}` } channelOnStateChange(event) { let state = (this.channel.readyState == \"open\") ? 'online' : \"offline\" this.statueMsg.innerHTML = state this.statueMsg.className = state } connOnDataChannel(event) { this.channel = event.channel this.channel.onmessage = (event) => this.channelOnMessage(event) this.channel.onopen = (event) => this.channelOnStateChange(event) this.channel.onclose = (event) => this.channelOnStateChange(event) } connOnIceConnectionStateChange(event) { console.log(\"oniceconnectionstatechange\") console.log(this.connection.iceConnectionState) } connOnIceGatheringStateChange(event) { console.log(\"onicegatheringstatechange\") console.log(this.connection.iceGatheringState) } connOnIceCandidate(event) { console.log(\"onicecandidate\") console.log(event) console.log(event.candidate) if (event.candidate) { let data = { \"type\": 'iceCandidate', \"room\": storage.getItem(\"room\"), \"payload\": event.candidate } let callback = (data) => { console.log(data) console.log(this.connection) } this.socket.emit(\"candidate\", data, (data) => callback(data)) } } connection_init() { console.log(\"connection_init\") if (!((\"webkitRTCPeerConnection\" in window) || (\"RTCPeerConnection\" in window))) { alert(\"RTCPeerConnection not supported\") throw \"RTCPeerConnection not supported\" } else { this.connection = new RTCPeerConnection(this.connectcfg) console.log(\"webkitRTCPeerConnection\") this.connection.ondatachannel = (event) => this.connOnDataChannel(event) //connection.setConfiguration(connectcfg) this.connection.onsignalingstatechange = state => console.info('signaling state change:', state) this.connection.oniceconnectionstatechange = (event) => this.connOnIceConnectionStateChange(event) this.connection.onicegatheringstatechange = (event) => this.connOnIceGatheringStateChange(event) this.connection.onicecandidate = (event) => this.connOnIceCandidate(event) } } bind_event() { this.roomForm.onsubmit = (e) => this.roomForm_onsubmit(e) this.createRoomBtn.onclick = (e) => this.createRoomBtn_onclick(e) this.leaveRoomBtn.onclick = (e) => this.leaveRoomBtn_onclick(e) this.messagesSubmit.onclick = (e) => this.messagesSubmit_onclick(e) this.leaveChannelBtn.onclick = (e) => this.leaveChannelBtn_onclick(e) } roomForm_onsubmit(e) { e.preventDefault() let info = { \"username\": this.usernameField.value, 'room': this.roomField.value } this.socket.emit(\"join\", info, function (data) { console.log(data) storage.setItem(\"username\", info[\"username\"]) storage.setItem(\"room\", info[\"room\"]) console.log(\"local info saved\") }) this.usernameField.value = '' this.roomField.value = '' return false } async createRoomBtn_onclick(e) { e.preventDefault() this.channel = this.connection.createDataChannel('test', { reliable: true }) console.log(this.channel) this.channel.onopen = (e) => this.channelOnStateChange(e) this.channel.onclose = (e) => this.channelOnStateChange(e) this.channel.onmessage = (e) => this.channelOnMessage(e) let offer = await this.connection.createOffer() console.log(`offer:${offer.toJSON()}`) this.connection.setLocalDescription(offer) let sendinfo = { \"room\": storage.getItem(\"room\"), \"offer\": offer } this.roomInfoList.innerHTML += `Local:${offer.sdp}` this.socket.emit(\"offer\", sendinfo, (data) => console.log(data)) } leaveRoomBtn_onclick(e) { e.preventDefault() let sendinfo = { \"username\": this.usernameField.value, 'room': this.roomField.value } this.socket.emit(\"leave\", sendinfo, (data) => console.log(data)) this.socket.close() } messagesSubmit_onclick(e) { console.log(\"send message\") e.preventDefault() let message = this.messageField.value this.messageField.value = '' this.channel.send(message) this.messagesList.innerHTML += `Local message:${message}` } leaveChannelBtn_onclick(e) { console.log(\"leave channel\") e.preventDefault() this.channel.close() } } window.onload = () => { new WebrtcApplication() } 文件传递 这个例子对应文件夹file中的内容.是传递文件,文件已经有了html5支持,要传输我们只要设置channel的binaryType = 'arraybuffer'即可,之后只要把用reader.readAsArrayBuffer(f)读出的数据直接发送过去就行了,为了显示,我先将文件信息传了过去,这样就好显示了. ... fileOnLoad(file, offset) { return (e)=>{ let result = e.target.result this.channel.send(result) if (file.size > offset + e.target.result.byteLength) { window.setTimeout(sliceFile, 0, offset + chunkSize) } this.sendProgress.value = offset + e.target.result.byteLength } } sliceFile(file, offset) { let reader = new FileReader(); reader.onload = this.fileOnLoad(file, offset) let slice = file.slice(offset, offset + chunkSize); reader.readAsArrayBuffer(slice) } ... channelOnMessage(event) { try { let info = JSON.parse(event.data) console.log(event) switch (info.type) { case \"info\": { this.filename = info.name this.filesize = info.size this.timestampStart = info.starttime this.receiveProgress.max = this.filesize this.messagesList.innerHTML += 'Remote message:' + \"reciving :\" + info.name + '' this.channel.send(JSON.stringify({ \"type\": \"return\", \"result\": \"ok\" })) } break case \"return\": { this.sliceFile(this.file, 0) } } } catch (error) { console.log(error) this.receiveBuffer.push(event.data) this.receivedSize += event.data.byteLength console.log(\"receivedSize\") console.log(this.receivedSize) this.receiveProgress.value = this.receivedSize ? this.receivedSize : 0 // we are assuming that our signaling protocol told // about the expected file size (and name, hash, etc). if (this.receivedSize === this.receiveProgress.max) { let received = new window.Blob(this.receiveBuffer); this.receiveBuffer = [] this.downloadAnchor.href = URL.createObjectURL(received) this.downloadAnchor.download = this.filename this.downloadAnchor.textContent = 'Click to download \\'' + this.filename + '\\' (' + this.filesize + ' bytes)'; this.downloadAnchor.style.display = 'block'; let bitrate = Math.round(this.receivedSize * 8 / ((new Date()).getTime() - this.timestampStart)); this.bitrateDiv.innerHTML = 'Average Bitrate: ' + bitrate + ' kbits/sec (max: ' + this.bitrateMax + ' kbits/sec)'; } } } ... async createRoomBtn_onclick(e) { e.preventDefault() this.channel = this.connection.createDataChannel('test', { reliable: true }) this.channel.binaryType = 'arraybuffer'//文件使用arraybuffer ... } ... messagesSubmit_onclick(e) { console.log(\"send message\") e.preventDefault() this.file = this.fileField.files[0] console.log(this.file) if (this.file.size) { this.sendProgress.max = this.file.size this.channel.send(JSON.stringify({ \"type\": \"info\", \"size\": this.file.size, \"name\": this.file.name, \"starttime\": (new Date()).getTime() })) } else { this.messagesList.innerHTML += 'Local message:' + \"File is empty, please select a non-empty file\" + '' this.messagesList.textContent = 'File is empty, please select a non-empty file' return; } } 后续还可以加入md5检验,有兴趣的可以自己实现 多媒体传递 如果是视屏通讯的话,我们甚至不用借助channel的send方法,只要在各端使用addStream添加流,并且各端监听onaddstream事件即可. 我们在页面加载后就将流读取到本地video标签.当建立连接后本地的流会推送到远端 ... ///新增 connection_onaddstream(event) { console.log(\"onaddstream\") this.remoteVideo.srcObject = event.stream } ... connection_init() { ... this.connection.onicecandidate = (event) => this.connOnIceCandidate(event) /// 新增事件句柄 this.connection.onaddstream = (event) => this.connection_onaddstream(event) } } ... ///新增 async addStream() { let stream = await navigator.mediaDevices.getUserMedia({ video: true }) this.connection.addStream(stream) this.localVideo.srcObject = stream } ... Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/前端概览/前端应用与通信/EventSource.html":{"url":"web前端技术/前端概览/前端应用与通信/EventSource.html","title":"EventSource","keywords":"","body":"EventSource EventSource是html5中新增的一个实用技术,它的主旨是让服务端拥有推送能力,从而弥补单纯http接口服务在实时性上的短板. 我们的http接口服务只有req/resp模式,而EventSource相当于在其上打了一个支持push/pull模式的补丁.这个技术非常适合如下场景: 有基于http接口的项目,需要有推送服务,但全部迁移至websocket需要时间缓冲 只需要消息推送,不需要双工通信 其优点主要是: 使用HTTP协议 轻量级,使用简单 默认支持断线重连 发送纯文本消息,完美支持json数据格式 实现原理 HTTP协议无法做到服务器主动推送信息,但有一种变通方法: 客户端向服务端发起一个请求,申明好需要返回的是一个流. 服务器向客户端发送流数据,并声明发送的是流信息而且流还没结束.这时客户端也就不会关闭连接. 服务端的流发送完了,就会发送一个消息在流的末尾,客户端收到也就断开连接了. 本质上来讲这种通信就是以流信息的方式完成一次用时很长的下载.可以看出EventSource需要服务端支持流数据作为响应,而且一旦建立起这个连接这个连接时无法复用的. 浏览器支持程度 目前除了微软家两个浏览器不支持外其他的应该是都支持的,我们可以使用window.EventSource ? true:false来验证当前的浏览器支不支持. 使用方法 EventSource对象的构造函数有两个参数 url,要访问的url options,配置参数,这个参数必须是一个对象,其中只可以有字段withCredentials,它的值是布尔值,用于设置跨域请求. 一旦设置为true,它就可以进行跨域了.但很遗憾跨域的Access-Control-Allow-Origin不能是*,必须指明要跨的hostname.并且需要设置Access-Control-Allow-Credentials为true EventSource实例有readyState属性可以查看当前连接的状态,这些状态包括: CONNECTING (0) OPEN (1) CLOSED (2) 要在客户端断开连接可以使用实例方法close(),而获取流数据必须使用事件监听,可以监听的事件有: onerror,当报错时触发 onmessage,当有消息推送来时触发 onopen,当连接建立成功时触发 我们的onmessage注册的回调函数参数为MessageEvent,它有如下字段: data 消息数据 origin发送者的源头 lastEventId消息id source 可以是Window对象的代理Proxy,web worker的MessagePort或者ServiceWorker对象 port正在通过其发送消息的通道相关联的端口 例子--一个推送时间的服务 这个例子在S5,我们用koa来构建服务端. 这个服务端会每隔1s发送一个当前时间给页面,我们将其写入页面,我们定义/stream为获取流数据的接口,那么在前端我们可以这样定义: function main() { let url = 'http://localhost:5000/stream' let evtSource = new EventSource(url); evtSource.onmessage = function (e) { console.log('onmsg: ' + e.data); document.querySelector(\"#local_time\").textContent = e.data } evtSource.onerror = function (e) { console.log('error', e); evtSource.close(); } } main() 当收到消息后我们就会将id为local_time的p标签中的内容用收到的内容填充. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-17 21:31:14 "},"web前端技术/Stylus/":{"url":"web前端技术/Stylus/","title":"Stylus","keywords":"","body":"Stylus Stylus是一种富有表现力的、动态的、健壮的CSS描述语言,他由node写成,只要使用npm安装stylus即可(推荐全局安装). 使用也非常方便,只要简单的使用stylus命令即可 stylus -w style.styl -o style.css 上面的意思是监控style.styl,并将其编译到style.css 它采用缩进语法,喜欢python的一定喜欢它. css描述非常繁琐,又是花括号又是分号,但他只是做了定义标签样式这样一个简单的事儿, 这让很多程序员无法忍受,他们希望用简洁直接的语言描述这种样式,并且可以引入逻辑使写css也像写程序一样,Stylus解决的正是这一个问题. 我们来看看他的特性: 冒号可选 分号可选 逗号可选 括号可选 变量 插值 混合书写 算术 强制类型转换 动态导入 条件 迭代 嵌套选择 父级参考 变量函数调用 词法作用域 内置函数(>25) 内部语言函数 压缩可选 图像内联可选 可执行Stylus 健壮的错误报告 单行和多行注释 CSS字面量 字符转义 TextMate捆绑 以及其他更多 让我们从一个最简单的对比开始吧: css: body { font: 12px Helvetica, Arial, sans-serif; } a.button { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; } stylus--缩进语法的css: body font 12px Helvetica, Arial, sans-serif a.button -webkit-border-radius 5px -moz-border-radius 5px border-radius 5px stylus--灵活的css: border-radius(x) -webkit-border-radius x -moz-border-radius x border-radius x body font 12px Helvetica, Arial, sans-serif a.button border-radius(5px) 这三个是等价的 接下来的部分我们会详细讨论以下部分: 注释 选择器 变量与插值 运算符 控制语句 内置方法 混入模式与函数 复用 @字符与特殊用法 jsApi 这篇文章主要是参考官方文档,大量使用了文档中的例子,稍加总结提炼,主要是为了让用python的也能比较好的理解. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/注释.html":{"url":"web前端技术/Stylus/注释.html","title":"注释","keywords":"","body":"注释 Stylus支持三种注释，单行注释，多行注释，以及多行缓冲注释 单行注释 跟JavaScript一样，双斜杠，CSS中不输出。 // 我是注释! body padding 5px // 蛋疼的padding 多行注释 多行注释看起来有点像CSS的常规注释。然而，它们只有在compress选项未启用的时候才会被输出。 /* * 给定数值合体 */ add(a, b) a + b 多行缓冲注释 跟多行注释类似，不同之处在于开始的时候，这里是/*!.这个相当于告诉Stylus压缩的时候这段无视直接输出。 /*! * 给定数值合体 */ add(a, b) a + b Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/选择器.html":{"url":"web前端技术/Stylus/选择器.html","title":"选择器","keywords":"","body":"选择器 基本语言风格 stylus使用缩进语法,并且可以省略{},;,:,(),每一层次代表一级作用域. 设定 选择器使用 和css一样,标签直接使用标签名选择,类使用.{类名},id则使用#{id}. 可以一次选择复数的选择器,他们之间可以空格隔开或者,隔开.为了可读性最好用, 父级引用 &符号表示父级引用, 如 textarea,input color #FFFFFF &:hover color #000 编译后结果就是: textarea,input { color: #a7a7a7; } textarea:hover,input:hover { color: #000; } 在函数中使用()避免歧义 类似padding - n的表达式可能既被解释成减法运算，也可能被释义成一元负号属性。为了避免这种歧义，用括号包裹表达式： pad(n) padding (- n) body pad(5px) 等价于 body { padding: -5px; } 有Stylus无法处理的属性值？可以使用unquote()： filter unquote('progid:DXImageTransform.Microsoft.BasicImage(rotation=1)') 生成为： filter progid:DXImageTransform.Microsoft.BasicImage(rotation=1) Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/运算符.html":{"url":"web前端技术/Stylus/运算符.html","title":"运算符","keywords":"","body":"运算符 下面是运算的优先级由高到底排序: 符号 优先级 说明 [] 1 用于按位取值,类似python ! 2 非 ~ 2 按位取反 + 2 正号 - 2 负号 is defined 3 用于判断变量是否已经被定义了,lookup(name)可以查看变量的具体值,如果没定义则返回null ** 4 乘方 * 4 乘 / 4 除 % 4 取余 + 5 加法 - 5 减法 ... 6 间隔为1的等差数列.类似python中的range(),后一位参数是最大值+1(拿不到) .. 6 间隔为1的等差数列,后一位参数是最大值(拿得到) 7 小于等于 >= 7 大于等于 7 小于 > 7 大于 in 8 包含在 == 9 等于 is 9 判断是 != 9 不等于 is not 9 判断不是 isnt 9 判断不是 is a 10 用于类型检查,我们也可以用type()来查看值得类型注意：color是唯一的特殊情况，当左边是RGBA或者HSLA节点时，都为true. && 11 与 and 11 与 II(双竖杠) 11 或 or 11 或 ?: 12 三元运算符xxx? true:false = 13 变量赋值 := 13 当变量未赋值时赋值 ?= 13 当变量未赋值时赋值 += 13 自加 -= 13 自减 *= 13 自乘 /= 13 自除 %= 13 自取余 not 14 非 if 15 如果 unless 15 除非 真与假 Stylus近乎一切都是true, 包括有后缀的单位，甚至0%, 0px等都被认作true. 不过，0在算术上本身是false. 表达式（或“列表”）长度大于1被认为是真。 颜色操作 颜色操作提供了一个简洁，富有表现力的方式来改变其组成。例如，我们可以对每个RGB： #0e0 + #0e0 // => #0f0 另外一个例子是通过增加或减少百分值调整颜色亮度。颜色亮，加；暗，则减。 #888 + 50% // => #c3c3c3 #888 - 50% // => #444 我们也可以通过增加或减去色度调整色调。例如，红色增加65deg就变成了黄色。 #f00 + 50deg // => #ffd500 值适当固定。例如，我们可以\"旋转\"180度的色调，如果目前的值是320deg, 将变成140deg. 我们也可能一次调整几个值（包括alpha），通过使用rgb(), rgba(), hsl(), 或 hsla(): #f00 - rgba(100,0,0,0.5) // => rgba(155,0,0,0.5) 格式化字符串 格式化字符串模样的字符串%可以用来生成字面量值，通过传参给内置s()方法。 'X::Microsoft::Crap(%s)' % #fc0 // => X::Microsoft::Crap(#fc0) 多个值需要括起来： '-webkit-gradient(%s, %s, %s)' % (linear (0 0) (0 100%)) // => -webkit-gradient(linear, 0 0, 0 100%) Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/控制语句.html":{"url":"web前端技术/Stylus/控制语句.html","title":"控制语句","keywords":"","body":"控制结构 条件 条件提供了语言的流控制，否则就是纯粹的静态语言。条件可用于导入、混入、函数等。 if / else if / else 最基础的流控制,语义是如果xxx stylus: overload-padding = true if overload-padding padding(y, x) margin y x else padding(y, x) margin x y body padding 5px 10px css: body { margin: 5px 10px; } unless unless提供了和if语句完全相反的语义,除非 stylus: overload-padding = true unless overload-padding is defined and overload-padding padding(y, x) margin y x body padding 5px 10px css: body { padding: 5px 10px; } 后缀条件语句 stylus允许使用后缀条件语句,就像python中一样使用 true if xxx else false 他其实与 xxx? true : false 一样 同时unless也可以使用后缀条件语句 true unless xxx 迭代 Stylus允许你通过for/in对表达式进行迭代,就像python一样,形式如下： for [, ] in xxx 等差数列 ...和..可以很容易的生成间隔为1的等差数列 ...类似python中的range(),后一位参数是最大值+1(拿不到) ..与上面不同之处就是后一位参数是最大值(拿得到) 后缀循环语句 for语句也可以作为后缀语句,与判断语句搭配可以做到类似python中列表解析的功能 sum($nums) $sum = 0 $sum += n if n%2 == 0 for n in $nums Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/内置方法.html":{"url":"web前端技术/Stylus/内置方法.html","title":"内置方法","keywords":"","body":"内置方法 像python一样,stylus也有定义了一些内置方法 颜色 red(color) 返回color中的红色比重。 red(#c00) // => 204 green(color) 返回color中的绿色比重。 green(#0c0) // => 204 blue(color) blue(color) 返回color中的蓝色比重。 red(#00c) // => 204 alpha(color) 返回color中的透明度比重。 alpha(#fff) // => 1 alpha(rgba(0,0,0,0.3)) // => 0.3 dark(color) 检查color是否是暗色。 dark(black) // => true dark(#005716) // => true dark(white) // => false light(color) 检查color是否是亮色。 light(black) // => false light(white) // => true light(#00FF40) // => true hue(color) 返回给定color的色调。 hue(hsla(50deg, 100%, 80%)) // => 50deg saturation(color) 返回给定color的饱和度。 saturation(hsla(50deg, 100%, 80%)) // => 100% lightness(color) 返回给定color的亮度。 lightness(hsla(50deg, 100%, 80%)) // => 80% hslaa(color | h,s,l,a) 转换给定color为HSLA节点，或h,s,l,a比重值。 hslaa(10deg, 50%, 30%, 0.5) // => HSLA hslaa(#ffcc00) // => HSLA hsla(color | h,s,l) 转换给定color为HSLA节点，或h,s,l比重值。 hsla(10, 50, 30) // => HSLA hsla(#ffcc00) // => HSLA rgba(color | r,g,b,a) 从r,g,b,a通道返回RGBA, 或提供color来调整透明度。 rgba(255,0,0,0.5) // => rgba(255,0,0,0.5) rgba(255,0,0,1) // => #ff0000 rgba(#ffcc00, 0.5) // rgba(255,204,0,0.5) 另外，stylus支持#rgba以及#rrggbbaa符号。 #fc08 // => rgba(255,204,0,0.5) #ffcc00ee // => rgba(255,204,0,0.9) rgb(color | r,g,b) 从r,g,b通道返回RGBA或生成一个RGBA节点。 rgb(255,204,0) // => #ffcc00 rgb(#fff) // => #fff lighten(color, amount) 给定color增亮amount值。该方法单位敏感，例如，支持百分比，如下： lighten(#2c2c2c, 30) // => #787878 lighten(#2c2c2c, 30%) // => #393939 darken(color, amount) 给定color变暗amount值。该方法单位敏感，例如，支持百分比，如下： darken(#D62828, 30) // => #551010 darken(#D62828, 30%) // => #961c1c desaturate(color, amount) 给定color饱和度减小amount. desaturate(#f00, 40%) // => #c33 saturate(color, amount) 给定color饱和度增加amount. saturate(#c33, 40%) // => #f00 invert(color) 颜色反相。红绿蓝颜色反转，透明度不变。 invert(#d62828) // => #29d7d7 数据结构 push(expr, args…) 后面推送给定的args给expr. nums = 1 2 push(nums, 3, 4, 5) nums // => 1 2 3 4 5 别名为append(). unshift(expr, args…) 起始位置插入给定的args给expr. nums = 4 5 unshift(nums, 3, 2, 1) nums // => 1 2 3 4 5 别名为prepend(). keys(pairs) 返回给定pairs中的键。 pairs = (one 1) (two 2) (three 3) keys(pairs) // => one two three values(pairs) 返回给定pairs中的值。 pairs = (one 1) (two 2) (three 3) values(pairs) // => 1 2 3 last(expr) 返回给定expr的最后一个值。 nums = 1 2 3 last(nums) last(1 2 3) // => 3 list = (one 1) (two 2) (three 3) last(list) // => (three 3) length([expr]) 括号表达式扮演元组，length()方法返回该表达式的长度。 length((1 2 3 4)) // => 4 length((1 2)) // => 2 length((1)) // => 1 length(()) // => 0 length(1 2 3) // => 3 length(1) // => 1 length() // => 0 反射 typeof(node) 字符串形式返回node类型。 type(12) // => 'unit' typeof(12) // => 'unit' typeof(#fff) // => 'rgba' type-of(#fff) // => 'rgba' 别名有type-of和type. unit(unit[, type]) 返回unit类型的字符串或空字符串，或者赋予type值而无需单位转换。 unit(10) // => '' unit(15in) // => 'in' unit(15%, 'px') // => 15px unit(15%, px) // => 15px 字符串操作 match(pattern, string) 检测string是否匹配给定的pattern. match('^foo(bar)?', foo) match('^foo(bar)?', foobar) // => true match('^foo(bar)?', 'foo') match('^foo(bar)?', 'foobar') // => true match('^foo(bar)?', 'bar') // => false join(delim, vals…) 给定vals使用delim连接。和python中str的join类似 join(' ', 1 2 3) // => \"1 2 3\" join(',', 1 2 3) // => \"1,2,3\" join(', ', foo bar baz) // => \"foo, bar, baz\" join(', ', foo, bar, baz) // => \"foo, bar, baz\" join(', ', 1 2, 3 4, 5 6) // => \"1 2, 3 4, 5 6\" 数值操作 数值操作允许带单位 abs(unit) 绝对值。 abs(-5px) // => 5px abs(5px) // => 5px ceil(unit) 向上取整。 ceil(5.5in) // => 6in floor(unit) 向下取整。 floor(5.6px) // => 5px round(unit) 四舍五入取整。 round(5.5px) // => 6px round(5.4px) // => 5px min(a, b) 取较小值。 min(1, 5) // => 1 max(a, b) 取较大值。 max(1, 5) // => 5 even(unit) 是否为偶数。 even(6px) // => true odd(unit) 是否为奇数。 odd(5mm) // => true sum(nums) 求和。 sum(1 2 3) // => 6 avg(nums) 求平均数。 avg(1 2 3) // => 2 eval 这部分是字符串与内置属性标签等的转化 unquote(str | ident) 给定str引号去除，返回Literal节点。 unquote(\"sans-serif\") // => sans-serif unquote(sans-serif) // => sans-serif unquote('1px / 2px') // => 1px / 2px s(fmt, …) s()方法类似于unquote()，不过后者返回的是Literal节点，而这里起接受一个格式化的字符串，非常像C语言的sprintf(). 目前，唯一标识符是%s. s('bar()'); // => bar() s('bar(%s)', 'baz'); // => bar(\"baz\") s('bar(%s)', baz); // => bar(baz) s('bar(%s)', 15px); // => bar(15px) s('rgba(%s, %s, %s, 0.5)', 255, 100, 50); // => rgba(255, 100, 50, 0.5) s('bar(%Z)', 15px); // => bar(%Z) s('bar(%s, %s)', 15px); // => bar(15px, null) 为表现一致检测这个%字符串操作符。 函数式 operate(op, left, right) 在left和right操作对象上执行给定的op. op = '+' operate(op, 15, 5) // => 20 错误处理 warn(msg) 使用给定的error警告，并不退出。 warn(\"oh noes!\") error(msg) 伴随着给定的错误msg退出。 add(a, b) unless a is a 'unit' and b is a 'unit' error('add() expects units') a + b p(expr) 检查给定的expr. fonts = Arial, sans-serif p('test') p(123) p((1 2 3)) p(fonts) p(#fff) p(rgba(0,0,0,0.2)) add(a, b) a + b p(add) 标准输出： inspect: \"test\" inspect: 123 inspect: 1 2 3 inspect: Arial, sans-serif inspect: #fff inspect: rgba(0,0,0,0.2) inspect: add(a, b) 特殊操作 opposite-position(positions) 返回给定positions相反内容。 opposite-position(right) // => left opposite-position(top left) // => bottom right opposite-position('top' 'left') // => bottom right add-property(name, expr) 使用给定的expr为最近的块域添加属性name。 例如： something() add-property('bar', 1 2 3) s('bar') body foo: something() 真实面目： body { bar: 1 2 3; foo: bar; } image-size(path) 返回指定path图片的width和height. 向上查找路径的方法和@import一样，paths设置的时候改变。 width(img) return image-size(img)[0] height(img) return image-size(img)[1] image-size('tux.png') // => 405px 250px image-size('tux.png')[0] == width('tux.png') // => true 上下文全局变量 current-property 这个变量自动提供给函数体，且包含当前属性名和值的表达式。 例如，我们使用p()检查这个局部变量，我们可以得到： p(current-property) // => \"foo\" (foo __CALL__ bar baz) p(current-property[0]) // => \"foo\" p(current-property[1]) // => foo __CALL__ bar baz 使用current-property我们可以让例子走得更远点，使用新值复制该属性，且确保功能的条件仅在属性值中使用。 something(n) if current-property add-property(current-property[0], s('-webkit-something(%s)', n)) add-property(current-property[0], s('-moz-something(%s)', n)) s('something(%s)', n) else error('something() must be used within a property') body { foo: something(15px) bar; } 生成为： body { foo: -webkit-something(15px); foo: -moz-something(15px); foo: something(15px) bar; } 如果你注意上面这个例子，会发现bar只在一开始调用的时候出现，因为我们返回something(15px), 其仍留在表达式里，然而，其他人并不重视其余的表达式。 更强大的解决方案如下，定义一个名为replace()的函数，其克隆表达式，以防止出现变化，用另外一个替换表达式的字符串值，并返回克隆的表达式。然后我们继续在表达式中替换CALL，表示循环调用something(). replace(expr, str, val) expr = clone(expr) for e, i in expr if str == e expr[i] = val expr something(n) if current-property val = current-property[1] webkit = replace(val, '__CALL__', s('-webkit-something(%s)', n)) moz = replace(val, '__CALL__', s('-moz-something(%s)', n)) add-property(current-property[0], webkit) add-property(current-property[0], moz) s('something(%s)', n) else error('something() 必须在属性中使用') 生成： body { foo: foo -webkit-something(5px) bar baz; foo: foo -moz-something(5px) bar baz; foo: foo something(5px) bar baz; } 无论是内部调用的使用还是调用的位置上，我们实现的方法现在是完全透明的了。这个强大概念有助于在一些私有属性使用时调用，例如渐变。 未定义方法 未定义方法一字面量形式输出。例如，我们可以在CSS中调用rgba-stop(50%, #fff), 其会按照你所期望的显示，我们也可以使用这些内部助手。 下面这个例子中我们简单定义了方法stop(), 其返回了字面上rgba-stop()调用。 stop(pos, rgba) rgba-stop(pos, rgba) stop(50%, orange) // => rgba-stop(50%, #ffa500) Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/混入模式与函数.html":{"url":"web前端技术/Stylus/混入模式与函数.html","title":"混入模式与函数","keywords":"","body":"混入模式与函数 混入模式和函数都是对代码的封装,他们的定义形式相同,而使用范围不同 混入模式 混入模式可以理解为定义一组对标签,类,id,属性操作的过程,可以理解为全部是赋值操作,它没有返回值,而且调用可以完全不写扩号 你可以把它当属性写 border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius n form input[type=button] border-radius(5px) 编译成： form input[type=button] { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; } 混合书写可以利用父级引用字符&, 继承父业而不是自己筑巢。 例如，我们要用stripe(even, odd)创建一个条纹表格。even和odd均提供了默认颜色值，每行也指定了background-color属性。我们可以在tr嵌套中使用&来引用tr，以提供even颜色。 stripe(even = #fff, odd = #eee) tr background-color odd &.even &:nth-child(even) background-color even 然后，利用混合书写，如下： table stripe() td padding 4px 10px table#users stripe(#303030, #494848) td color white 另外，stripe()的定义无需父引用： stripe(even = #fff, odd = #eee) tr background-color odd tr.even tr:nth-child(even) background-color even 混合书写中的混合书写 自然，混合书写可以利用其它混合书写，建立在它们自己的属性和选择器上。 例如，下面我们创建内联comma-list()（通过inline-list()）以及逗号分隔的无序列表。 inline-list() li display inline comma-list() inline-list() li &:after content ', ' &:last-child:after content '' ul comma-list() 渲染： ul li:after { content: \", \"; } ul li:last-child:after { content: \"\"; } ul li { display: inline; } 函数 函数是用来计算值的 类似于python,函数可以为参数设定默认值,其余参数和关键字参数, func(a,args...,b=1) return a+b+sum(args) input border func(a:2,3,3,4,5) 输出: input { border: 18; } 函数返回值可以用return,也可以不用,不用的话默认会返回最后一个表达式的结果, 可以有多返回值,当然了,类似python,也可以多返回值,返回值其实是变成了列表,需要的时候可以用[]取出. 同时这边一样支持高阶函数,支持将函数赋值给变量. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/复用.html":{"url":"web前端技术/Stylus/复用.html","title":"复用","keywords":"","body":"复用 复用可以说是所有css处理语言的关键了,stylus的主要复用手段有: 利用混入模式和函数实现复用 利用@import或者@require导入css或者styl文件从而复用 利用@extend复用 第一种不再多说,这边主要说第二第三种: 利用@import或者@require导入css或者styl文件从而复用 熟悉python或者node的朋友一定看出来了这是模块极的复用,我们可以直接引入css或者stylus文件中的内容 model.styl func(a,args...,b=1) return a+b+sum(args) main.styl @import 'model' input border func(a:2,3,3,4,5) 编译main.styl文件后可得 input { border: 18; } 值得注意的是css文件同样可以引入,但必须指明后缀.没有后缀的就是styl文件 利用@extend复用 继承这一概念容易让我们想到面向对象编程,确实这个关键字也很有点面向对象的意味 Stylus的@extend指令受SASS实现的启发，基本一致，除了些轻微差异。此功能大大简化了继承其他语义规则集的语义规则集的维护。 混合书写下的“继承” 尽管你可以使用混写实现类似效果，但会导致重复的CSS. 典型的模式式定义如下的几个类名，然后归结到一个元素中， 例如\"warning message\". 该技术实现是没什么问题，但是维护就比较麻烦了。 message, .warning { padding: 10px; border: 1px solid #eee; } .warning { color: #E2E21E; } 使用@extend得到同样的输出，只要把对应的选择器传给@extend即可。然后.warning选择器就会继承已经存在的.message规则。 .message { padding: 10px; border: 1px solid #eee; } .warning { @extend .message; color: #E2E21E; } 这儿是个更复杂的例子，演示了@extend如何级联。 red = #E33E1E yellow = #E2E21E .message padding: 10px font: 14px Helvetica border: 1px solid #eee .warning @extends .message border-color: yellow background: yellow + 70% .error @extends .message border-color: red background: red + 70% .fatal @extends .error font-weight: bold color: red 生成CSS如下： .message, .warning, .error, .fatal { padding: 10px; font: 14px Helvetica; border: 1px solid #eee; } .warning { border-color: #e2e21e; background: #f6f6bc; } .error, .fatal { border-color: #e33e1e; background: #f7c5bc; } .fatal { font-weight: bold; color: #e33e1e; } 目前Stylus与SASS不同之处在于SASS不允许@extend嵌套选择器。 form button padding: 10px a.button @extend form button Syntax error: Can't extend form button: can't extend nested selectors // 解析错误： 无法继承自 button: 不能继承嵌套选择器 on line 6 of standard input Use --trace for backtrace. Stylus中，只要选择器匹配，就可以生效： form input[type=text] padding: 5px border: 1px solid #eee color: #ddd textarea @extends form input[type=text] padding: 10px 生成： form input[type=text], form textarea { padding: 5px; border: 1px solid #eee; color: #ddd; } textarea { padding: 10px; } Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/at字符与特殊用法.html":{"url":"web前端技术/Stylus/at字符与特殊用法.html","title":"@字符与特殊用法","keywords":"","body":"@字符与特殊用法 关键帧(@keyframes) Stylus支持@keyframes规则，当编译的时候转换成@-webkit-keyframes： @keyframes pulse 0% background-color red opacity 1.0 -webkit-transform scale(1.0) rotate(0deg) 33% background-color blue opacity 0.75 -webkit-transform scale(1.1) rotate(-5deg) 67% background-color green opacity 0.5 -webkit-transform scale(1.1) rotate(5deg) 100% background-color red opacity 1.0 -webkit-transform scale(1.0) rotate(0deg) 生成为： @-webkit-keyframes pulse { 0% { background-color: red; opacity: 1; -webkit-transform: scale(1) rotate(0deg); } 33% { background-color: blue; opacity: 0.75; -webkit-transform: scale(1.1) rotate(-5deg); } 67% { background-color: green; opacity: 0.5; -webkit-transform: scale(1.1) rotate(5deg); } 100% { background-color: red; opacity: 1; -webkit-transform: scale(1) rotate(0deg); } } 扩展 使用@keyframes，通过vendors变量，会自动添加私有前缀(webkit moz official)。这意味着你可以子啊任意时候立即高效地做修改。 考虑下面的例子： @keyframes foo { from { color: black } to { color: white } } 扩增两个默认前缀，官方解析： @-moz-keyframes foo { 0% { color: #000; } 100% { color: #fff; } } @-webkit-keyframes foo { 0% { color: #000; } 100% { color: #fff; } } @keyframes foo { 0% { color: #000; } 100% { color: #fff; } } 如果我们只想有标准解析，很简单，修改vendors： vendors = official @keyframes foo { from { color: black } to { color: white } } 生成为： @keyframes foo { 0% { color: #000; } 100% { color: #fff; } } 自定义字体(@font-face) @font-face跟其在CSS中作用表现一样，在后面简单地添加个块状属性即可，类似下面： @font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf) .ingeo font-family Geo 生成为： @font-face { font-family: Geo; font-style: normal; src: url(\"fonts/geo_sans_light/GensansLight.ttf\"); } .ingeo { font-family: Geo; } 媒体(@media) @media工作原理和在常规CSS中一样，但是，要使用Stylus的块状符号。 @media print #header #footer display none 生成为： @media print { #header, #footer { display: none; } } CSS字面量(@css) 不管什么原因，如果遇到Stylus搞不定的特殊需求，你可以使用@css使其作为CSS字面量解决之。 @css { body { font: 14px; } } 编译为： body { font: 14px; } Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Stylus/jsApi.html":{"url":"web前端技术/Stylus/jsApi.html","title":"jsApi","keywords":"","body":"JavaScript API require模块，用给定的Stylus代码字符串调用render()，以及（可选的）optional对象。 传递filename参数可以利用Stylus框架提供更好的错误报告。 var stylus = require('stylus'); stylus.render(str, { filename: 'nesting.css' }, function(err, css){ if (err) throw err; console.log(css); }); 我们可以用更渐进的方式实现做一样的事： var stylus = require('stylus'); stylus(str) .set('filename', 'nesting.css') .render(function(err, css){ // logic }); .set(setting, value) 应用诸如filename的设置，或导入paths: .set('filename', __dirname + '/test.styl') .set('paths', [__dirname, __dirname + '/mixins']) .include(path) 渐进替换.set('paths',...)的就是.include(). 当其他Stylus库（已暴露路径）暴露的时候，这个是理想的选择。 stylus(str) .include(require('nib').path) .include(process.env.HOME + '/mixins') .render(...) .import(path) 推迟给定path导入，直到计算被执行。下面这个例子基本上跟在Stylus片段中执行@import 'mixins/vendor'一样： var stylus = require('../') , str = require('fs').readFileSync(__dirname + '/test.styl', 'utf8'); stylus(str) .set('filename', __dirname + '/test.styl') .import('mixins/vendor') .render(function(err, css){ if (err) throw err; console.log(css); }); .define(name, node) 通过传递一个Node，我们可以定义一个全局变量。当库（该库依赖于其它库可用性）里面暴露某些条件特征的时候，这个就很有用。例如Nib扩展库条件支持node-canvas, 提供图片生成。 但这并不是一直可用的，因此Nib可以定义： .define('has-canvas', stylus.nodes.false); .define('some-setting', new stylus.nodes.String('some value')); 如果可能，Stylus也会转换JavaScript值为Stylus值。 .define('string', 'some string') .define('number', 15.5) .define('some-bool', true) .define('list', [1,2,3]) .define('list', [1,2,[3,4,[5,6]]]) .define('list', { foo: 'bar', bar: 'baz' }) .define('families', ['Helvetica Neue', 'Helvetica', 'sans-serif']) 下面是一些规则应用在js函数返回值上： .define('get-list', function(){ return ['foo', 'bar', 'baz']; }) .define(name, fn) 该方法允许你未Stylus提供JavaScript定义的函数。正如想到JavaScript用C++绑定。当有一些事情无法用Stylus完成的时候，就在JavaScript中定义它。 下面这个例子，我们定义了4个函数：add(), sub(), image-width(), image-height(). 这些函数必须返回一个Node, 通过stylus.nodes该构造以及其它nodes都可以了。 var stylus = require('../') , nodes = stylus.nodes , utils = stylus.utils , fs = require('fs'); function add(a, b) { return a.operate('+', b); } function sub(a, b) { return a.operate('-', b); } function imageDimensions(img) { // 宣告 node (img) 是一个 String 节点, // 为错误报告传递参数名 utils.assertType(img, 'string', 'img'); var path = img.val; // 得到尺寸有必要取得字节数 // 如果这是真的，你会每种格式都处理下， // 而不是读取整个图片 :) var data = fs.readFileSync(__dirname + '/' + path); // GIF // 当然，你可以支持更多 :) if ('GIF' == data.slice(0, 3).toString()) { var w = data.slice(6, 8) , h = data.slice(8, 10); w = w[1] 为了进一步的参考（直到本文档全部结束），请看下面的文件： lib/nodes/* lib/utils.js .use(fn) 当被调用时，给定fn被渲染器调用，允许所有上面的方法被使用。这允许插件轻易地暴露自己，定义函数，路径等。 var mylib = function(style){ style.define('add', add); style.define('sub', sub); }; stylus(str) .use(mylib) .render(...) Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Webpack/":{"url":"web前端技术/Webpack/","title":"Webpack","keywords":"","body":"webpack 前端项目的资源无非就是: html文件 css文件 图片文件 js文件 其他文件 webpack将所有这些不同类型的文件视作平等的资源--js模块,通过加载器将他们组合到统一的前端项目中.本文将创建一个简单的示例页面,一步一步的将webpack的基本用法引出来. webpack是一个前端项目的打包工具,它会把你的项目当做一个整体,我们使用它的时候并不需要开始就定义好html中的内容,而是通过js直接构造DOM.通过一个给定的主文件(如:index.js),Webpack将从这个文件开始找到你的项目的所有依赖文件,使用loaders处理它们,最后打包为一个(或多个)浏览器可识别的JavaScript文件. 本文介绍webpack的最基本安装,顺便引出webpack的几个基本概念: 加载器loader 插件Plugins 本文的例子代码在https://github.com/TutorialForJavascript/frontend-Webpack/tree/master/code,实现一个最简单的仅仅只是显示文字的html页面.但也分为几个步骤 本体安装 webpack本体安装很简单: npm install --save-dev webpack webpack-cli 这个最简单的前端项目(C1)源码上看包括: 一个用于渲染的html文件(public/index.html) Webpack Sample 一个入口文件(src/index.js) const greeter = require('./greeting.js'); document.querySelector(\"#root\").appendChild(greeter()); 若干模块文件(src/greeting.js) module.exports = function() { var greet = document.createElement('div'); greet.textContent = \"greetings!\"; return greet; }; 为了可以让webpack正确的打包项目,同时还要为webpack写一个配置文件webpack.config.js: const path = require('path') module.exports = { entry: './src/index.js', output: { path: __dirname + '/public', filename: 'bundle.js' } } 这个配置指明了入口函数和编译后项目的输出位置以及输出的文件. 之后我们只要执行命令./node_modules/.bin/webpack --config webpack.config.js即可,为方便起见我们将这条命令放到package.json的scripts中. babel支持 本系列文章使用babel来实现js的高级语法,因此ts,或者coffeescript等不再本文讨论范围内. babel使用babel-loader实现加载,但个人测试最新的babel-loader必须搭配@babel/core和@babel/preset-env使用,但似乎目前还有一些bug,我使用这个搭配的时候并不成功.作为替代可以使用babel-loader@7来强制安装支持babel-core和babel-preset-env的版本. npm install --save-dev babel-core babel-preset-env babel-loader@7 同时不要忘记在package.json中和node环境下一样加上babel的配置: { \"babel\": { \"presets\": [ [ \"env\" ] ] }, } babel-loader是一个加载器. Loaders是webpack提供的核心功能之一了.通过使用不同的loader,webpack有能力调用外部的脚本或工具实现对不同格式的文件的处理.比如说分析转换scss为css或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件. Loaders需要单独安装并且需要在webpack.config.js中的modules字段下的rules字段中进行配置.这是一个由对象组成的array.每个对象描述一组加载规则,包括以下几方面: test一个用以匹配loaders所处理文件的拓展名的正则表达式(必须) use配置使用的loader,loader描述对象可以有如下字段配置: loaderloader的名称(必须) options对应loader项的配置项 include/exclude手动添加必须处理的文件(文件夹)或屏蔽不需要处理的文件(文件夹)(可选) query为loaders提供额外的设置选项(可选) 修改后的webpack配置文件webpack.config.js如下: const path = require('path') module.exports = { entry: './src/index.js', output: { path: __dirname + '/public', filename: 'bundle.js' }, module: { rules: [ { test: /\\.js$/, use:{ loader: 'babel-loader' }, exclude: path.resolve(__dirname, 'node_modules'), include: path.resolve(__dirname, 'src') } ] } } 在代码C2中我们修改C1中的js代码为es6写法 入口文件(src/index.js) import greeter from './greeting.js' document.querySelector(\"#root\").appendChild(greeter()) 模块文件(src/greeting.js) export default function(){ let greet = document.createElement('div') greet.textContent = \"greetings!\" return greet } 为导入css 另一种资源就是css文件.我们来为项目设置下样式,新的代码在C3-E1中. 要加载css文件需要使用css-loader和style-loader,二者处理的任务不同. css-loader使你能够使用类似@import 和url(...)的方法实现require()的功能; style-loader将所有的计算后的样式加入页面中. 二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中. 安装加载器: npm install --save-dev style-loader css-loader 修改配置文件: const path = require('path') module.exports = { entry: './src/index.js', output: { path: __dirname + '/public', filename: 'bundle.js' }, module: { rules: [ { test: /\\.js$/, use:{ loader: 'babel-loader' }, exclude: path.resolve(__dirname, 'node_modules'), include: path.resolve(__dirname, 'src') }, { test: /\\.css$/, use: [ { loader: \"style-loader\" }, { loader: \"css-loader\" } ] } ] } } 可以看到对同一个种文件引入多个loader,这在webpack中也是可以的 新增一个css文件main.css放在src文件夹下: html { box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; } *, *:before, *:after { box-sizing: inherit; } body { margin: 0; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; } h1, h2, h3, h4, h5, h6, p, ul { margin: 0; padding: 0; } 我们要用这个css可以在入口js文件中使用import导入: import greeter from './greeting.js' import './main.css' document.querySelector(\"#root\").appendChild(greeter()) 使用stylus定义css 本节代码在C3-E2中. 就像babel之于js,我更愿意使用stylus来定义样式,这还需要安装如下依赖: npm install --save-dev stylus stylus-loader 之后修改配置文件: const path = require('path') module.exports = { entry: './src/index.js', output: { path: __dirname + '/public', filename: 'bundle.js' }, module: { rules: [ { test: /\\.js$/, use:{ loader: 'babel-loader' }, exclude: path.resolve(__dirname, 'node_modules'), include: path.resolve(__dirname, 'src') }, { test: /\\.css$/, use: [ { loader: \"style-loader\" }, { loader: \"css-loader\" } ] }, { test: /\\.styl$/, use: [ { loader: \"style-loader\" }, { loader: \"css-loader\" },{ loader: \"stylus-loader\" } ] } ] } } 我们删掉src/main.css后新增一个stylus源码文件main.styl html box-sizing border-box -ms-text-size-adjust 100% -webkit-text-size-adjust 100% *, *:before, *:after box-sizing: inherit body margin 0 font-family 'Helvetica Neue', Helvetica, Arial, sans-serif h1, h2, h3, h4, h5, h6, p, ul margin 0 padding 0 然后修改入口js文件index.js为: import greeter from './greeting.js' import './main.styl' document.querySelector(\"#root\").appendChild(greeter()) 导入图片 在html中引入图片实际上就是引入一个图片的url 我们使用webpack将图片作为模块打包,实际上就是把这个图片的位置指出来,即 import eg_tulip from \"./eg_tulip.jpg\" 要将图片作为模块加载依赖于url-loader和file-loader: npm install --save-dev url-loader file-loader url-loader用于导入图片,如果图片小与限制就会转化为base64码 file-loader用于在图片过大时从文件系统中找到文件 修改配置文件: const path = require('path') module.exports = { entry: './src/index.js', output: { path: __dirname + '/public', filename: 'bundle.js' }, module: { rules: [{ test: /\\.js$/, use: { loader: 'babel-loader' }, exclude: path.resolve(__dirname, 'node_modules'), include: path.resolve(__dirname, 'src') }, { test: /\\.css$/, use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }] }, { test: /\\.styl$/, use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }, { loader: \"stylus-loader\" }] }, { test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)$/i, use: [{ loader: 'url-loader', options: { limit: 10000 } }] } ] } } 上面的配置中url-loader我们设置了limit,只要图片大小小于1000字节限制时图片会自动转成base64码引用 我们在greeting模块中引入这张图片: import eg_tulip from \"./eg_tulip.jpg\" export default function(){ let greet = document.createElement('div') greet.textContent = \"greetings!\" let img = document.createElement(\"img\") img.src = eg_tulip greet.appendChild(img) return greet } 由于我们的图片有36k大,执行完成后会生成一个文件名由16进制字符串组成的jpg文件.如果我们希望图片更有可读性,可以修改配置文件中url-loader的部分: { loader: 'url-loader', options: { limit: 10000, name: '[path][name].[ext]?[hash:6]!./dir/file.png' } } 对图片进行压缩 本节的代码在C4-E2. 我们往往希望加快前端项目的加载速度,压缩图片是最常见最简单暴力的方式,可以使用image-webpack-loader来压缩图片 npm install --save-dev image-webpack-loader 修改配置文件: const path = require('path') module.exports = { entry: './src/index.js', output: { path: __dirname + '/public', filename: 'bundle.js' }, module: { rules: [{ test: /\\.js$/, use: { loader: 'babel-loader' }, exclude: path.resolve(__dirname, 'node_modules'), include: path.resolve(__dirname, 'src') }, { test: /\\.css$/, use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }] }, { test: /\\.styl$/, use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }, { loader: \"stylus-loader\" }] }, { test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)$/i, use: [{ loader: 'url-loader', options: { limit: 10000, name: '[path][name].[ext]?[hash:6]!./dir/file.png' } }, {//对图片进行压缩 loader: 'image-webpack-loader', query: { progressive: true, optimizationLevel: 7, interlaced: false, pngquant: { quality: '65-90', speed: 4 } } }] } ] } } 需要注意的是image-webpack-loader需要放在url-loader之后 压缩的配置项都在query字段里.可以看到经过loader压缩后图片从36k压缩到了19k 将html模板作为组件 本节的例子为C5 上面的所有例子中我们都需要有一个html文件来加载js.那我们可以不可以将这个html文件也作为组件呢,这样我们就不再需要预先定义public文件夹了 我们可以使用HtmlWebpackPlugin,这是一个webpack插件,其作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html.这在每次生成的js文件名称不同时非常有用(比如添加了hash值). 安装: npm install --save-dev html-webpack-plugin 修改配置文件: const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { ... plugins:[ new HtmlWebpackPlugin({ template: __dirname + \"/src/index.tmpl.html\" //new 一个这个插件的实例，并传入相关的参数 }) ] } 现在我们重新构建项目的代码结构: 删除public文件夹 在src文件夹下新建一个index.tmpl.html Webpack Sample Project 插件(Plugins)是webpack中另一个很关键的功能,它用于拓展Webpack.插件会在整个构建过程中生效,执行相关的任务. Loaders和Plugins常常被弄混,但是他们其实是完全不同的东西.可以这么来说,loaders是在打包构建过程中用来处理源文件的(JSX，Scss，Less..),一次处理一个,插件并不直接操作单个文件,它直接对整个构建过程其作用. Webpack有很多内置插件,同时也有很多第三方插件,可以让我们完成更加丰富的功能. 使用插件的方法如上面的例子,我们需要通过npm安装它,然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例(plugins是一个数组) 为前端项目配置调试工具 本部分代码在C6. 上面的内容其实已经可以直接使用了,但以上的配置并不方便调试.为了方便开发时进行调试,我们可以再多做下面几件事 启动调试用的静态服务器和热加载 调试用静态服务器依赖webpack-dev-server这个node模块 安装: npm install --save-dev webpack-dev-server 热加载模块其实是webpack自带的功能,我们只需要修改配置文件即可,下面是修改好后的配置文件: const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { ... devtool: 'eval-source-map', devServer: { contentBase: \"./public\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true, hot: true }, ... plugins: [ ..., new webpack.HotModuleReplacementPlugin() //热加载插件 ] } 这边我们可以看到新增了两个一级字段 devtool,这个用于产生sourcemap,什么是sourcemap可以看阮一峰的科普文章. 在webpack的配置文件中配置sourcemap,需要配置devtool字段,它有以下四种不同的配置选项,各具优缺点.描述如下: devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件.这个文件具有最好的sourcemap,但是它会减慢打包速度; cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map,不带列映射提高了打包速度,但是也使得浏览器开发者工具只能对应到具体的行,不能对应到具体的列(符号),会对调试造成不便; eval-source-map 使用eval打包源文件模块,在同一个文件中生成干净的完整的sourcemap.这个选项可以在不影响构建速度的前提下生成完整的sourcemap,但是对打包后输出的JS文件的执行具有性能和安全的隐患.在开发阶段这是一个非常好的选项,在生产阶段则一定不要启用这个选项; cheap-module-eval-source-map 这是在打包文件时最快的生成sourcemap的方法,生成的sourcemap会和打包后的JavaScript文件同行显示,没有列映射,和eval-source-map选项具有相似的缺点 devServer,这个字段可以用于配置开发服务器包括: contentBase默认webpack-dev-server会为根文件夹提供本地服务器,如果想为另外一个目录下的文件提供本地服务器,应该在这里设置其所在目录 port设置默认监听端口,如果省略默认为8080 inline设置为true时,当服务器指定文件夹中文件改变时会自动刷新页面 historyApiFallback如果设置为true时所有的跳转将指向index.html,这个选项在开发单页应用时非常有用,它依赖于HTML5 history API. hot,当设置为true时启动热更新,即当源文件有修改时,就会自动编译自动刷新页面 open,是否启动默认浏览器 要使用这个服务器,我们可以使用命令./node_modules/.bin/webpack-dev-server --open 为了方便起见,我们在package.json的scripts中将其配置为命令\"start\": \"./node_modules/.bin/webpack-dev-server --open\",这种方式可以使用命令npm start启动这个服务器 缓存 缓存无处不在,使用缓存的最好方法是保证你的文件名和文件内容是匹配的(内容改变,名称相应改变) webpack可以把一个哈希值添加到打包的文件名中,使用方法如下添加特殊的字符串混合体([name],[id] and [hash])到输出文件名前(实际上我们已经在图片部分使用过了). const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { .. output: { path: __dirname + \"/build\", filename: \"bundle-[hash].js\" }, ... }; 清除上次编译后的残余文件 调试阶段不可避免的会反反复复的编译,如果使用了缓存,那必然会有越来越多的无用文件残留下来,可以使用插件clean-webpack-plugin进行清除操作. 安装: npm install --save-dev clean-webpack-plugin 修改配置文件: ... const CleanWebpackPlugin = require(\"clean-webpack-plugin\") module.exports = { ... plugins: [ ...// 这里是之前配置的其它各种插件 new CleanWebpackPlugin('build/*.*', { root: __dirname, verbose: true, dry: false }) ] } 正式环境使用 本部分代码在C7. 上面的代码已经可以满足大部分简单的前端任务了,但现实是复杂的往往我们需要在不同的部署环境中使用不同的配置,并且也要考虑代码的安全性问题和性能问题. 优化代码 本部分代码在C7-E1 webpack提供了一些在发布阶段非常有用的优化插件,它们大多来自于webpack社区,可以通过npm安装,通过以下插件可以完成产品发布阶段所需的功能 OccurenceOrderPlugin:为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多的模块,并为它们分配最小的ID uglifyjs-webpack-plugin压缩JS代码 ExtractTextPlugin分离CSS和JS文件. 不用这个插件的话我们会发现css描述的样式实际上是在js文件中包含的,这个插件的作用是讲包含在js文件中的样式抽取出来放到一个css文件中. 这个作用听起来是脱裤子放屁,但实际是有用的,实际开发中css源文件未必只有一个,这个插件可以将分散在各个模块中的样式抽取到一起,同时由于css被抽出了,js文件变小了, 这样可以避免因为js过大影响前端性能的问题. 注意目前这个插件对webpack4支持不好,可以使用extract-text-webpack-plugin@next OccurenceOrder是内置插件,你需要做的只是安装其它非内置插件. npm install --save-dev extract-text-webpack-plugin@next uglifyjs-webpack-plugin 修改配置文件: ... const webpack = require('webpack'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); const ExtractTextPlugin = require('extract-text-webpack-plugin'); module.exports = { ... module: { rules: [ ... { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\"] }) }, { test: /\\.styl$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\", \"stylus-loader\"] }) } ... ] }, plugins: [ ... new webpack.optimize.OccurrenceOrderPlugin(), new ExtractTextPlugin(\"style.css\") ], optimization: { minimizer: [ new UglifyJSPlugin(), ] } } 需要注意的是: UglifyJSPlugin插件不放在plugins字段中,而在optimization->minimizer字段中 ExtractTextPlugin除了要在plugins字段中创建外,还需要在定义css规则的loader部分做处理,其形式是:{ test: /\\.styl$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\", \"stylus-loader\"] }) } 区分环境 环境其实可以分为两块: 编译环境 比如说我们在生产环境下需要压缩图片,但开发环境不用,这样更好调试,这样就区分出了两个环境的编译环境. 源码环境 比如我们的测试环境下前端接的后端api的host在localhost下,而生产环境下api是的host是一串ip地址,这种时候在源码中我们就需要区分不同的环境. 要区分环境我们需要使用工具webpack-merge,他可以用于merge两个Object以实现类似继承的功能. 这个部分的例子我们的目标是让不同环境的源码编译出来后greeting后面接的字不同,比如dev环境的源码编译出来后就是greeting dev! 编译环境隔离 本部分的代码在C7-E2. 在最开始的时候我们就看到webpack需要指定一个config因此针对不同环境我们可以配置不同配置文件. 要实现不同配置文件间的聚合我们需要安装webpack-merge. 安装: npm install --save-dev webpack-merge 我们新建一个文件夹env在其中写上三个环境的webpack配置文件,为了代码不重复,我们定义一个基对象 webpack.config.base.js const path = require('path') const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin') const CleanWebpackPlugin = require(\"clean-webpack-plugin\") module.exports = { entry: path.resolve(__dirname, '../src/index.js'), output: { path: path.resolve(__dirname, '../build'), filename: 'bundle-[hash].js' }, devServer: { contentBase: path.resolve(__dirname, '../build'), //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true, hot: true }, module: { rules: [{ test: /\\.js$/, use: { loader: 'babel-loader' }, exclude: path.resolve(__dirname, '../node_modules'), include: path.resolve(__dirname, '../src') }, { test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)$/i, use: [{ loader: 'url-loader', options: { limit: 10000, name: '[path][name].[ext]?[hash:6]!./dir/file.png' } }, { loader: 'image-webpack-loader', query: { progressive: true, optimizationLevel: 7, interlaced: false, pngquant: { quality: '65-90', speed: 4 } } } ] } ] }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve(__dirname, '../src/index.tmpl.html') //new 一个这个插件的实例，并传入相关的参数 }), new webpack.HotModuleReplacementPlugin(), //热加载插件 new CleanWebpackPlugin('build/*.*', { root: path.resolve(__dirname, \"..\"), verbose: true, dry: false }) ] } 这个对象是各个环境编译环境的基础,各个环境就是在其基础上进行添加修改,注意由于配置文件位置变了,需要修改所有与位置相关的部分. webpack.config.dev.js 开发环境的配置文件 const merge = require('webpack-merge') const base = require('./webpack.config.base.js') module.exports = merge(base,{ devtool: 'eval-source-map', module: { rules: [ { test: /\\.css$/, use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }] }, { test: /\\.styl$/, use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }, { loader: \"stylus-loader\" }] } ] } }) 开发环境我们并不需要将js和css分离,因此只用使用最简单的配置方式. webpack.config.test.js 测试环境,通常编译设置和生产环境的大部分是一样的,这样才好做基准测试嘛.但也要便于调试 const webpack = require('webpack'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin') const ExtractTextPlugin = require('extract-text-webpack-plugin') const merge = require('webpack-merge') const base = require('./webpack.config.base.js') module.exports = merge(base,{ devtool: 'eval-source-map', module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\"] }) }, { test: /\\.styl$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\", \"stylus-loader\"] }) } ] }, plugins: [ new webpack.optimize.OccurrenceOrderPlugin(), new ExtractTextPlugin(\"style.css\") ], optimization: { minimizer: [ new UglifyJSPlugin(), ] } }) webpack.config.prod.js 生产环境下我们不需要sourcemap,因此就不设置devtool了 const webpack = require('webpack'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin') const ExtractTextPlugin = require('extract-text-webpack-plugin') const merge = require('webpack-merge') const base = require('./webpack.config.base.js') module.exports = merge(base,{ module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\"] }) }, { test: /\\.styl$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"css-loader\", \"stylus-loader\"] }) } ] }, plugins: [ new webpack.optimize.OccurrenceOrderPlugin(), new ExtractTextPlugin(\"style.css\") ], optimization: { minimizer: [ new UglifyJSPlugin(), ] } }) 注意merge并不会覆盖操作,一旦base中定义的在后面一个对象中也有定义,那就会引起冲突报错. 源码环境隔离 本部分的代码在C7-E3. 在env/conf文件夹下我们创建3个json文件来设置不同环境下源码中使用的配置量 env/conf/dev.json { \"env\":\"dev\" } env/conf/test.json { \"env\":\"test\" } env/conf/prod.json { \"env\":\"prod\" } 为了可以使用这些配置项中的参数,我们需要修改我们的源码: src/conf.js const NODE_ENV = process.env.NODE_ENV export default NODE_ENV 这个模块用于给上面定义的配置对象一个统一的导入入口. src/greeting.js import eg_tulip from \"./eg_tulip.jpg\" import conf from \"./conf.js\" export default function () { let greet = document.createElement('div') greet.textContent = `greeting ${conf.env}!` let img = document.createElement(\"img\") img.src = eg_tulip greet.appendChild(img) return greet } 我们将这个模块的文字内容配置化.使用上面定义的conf.js定义的对象中的字段来构造输出的内容 如何将这两边联系起来呢?我们需要修改配置文件,引入插件webpack.DefinePlugin: webpack.config.dev.js 开发环境的配置文件 ... const env = require(\"./conf/dev.json\") module.exports = merge(base,{ ... plugins: [ new webpack.DefinePlugin({ 'process.env': { 'NODE_ENV': JSON.stringify(env) } }) ] }) webpack.config.test.js 测试环境,通常编译设置和生产环境的大部分是一样的,这样才好做基准测试嘛.但也要便于调试 ... const env = require(\"./conf/test.json\") module.exports = merge(base,{ ... plugins: [ ... new webpack.DefinePlugin({ 'process.env': { 'NODE_ENV': JSON.stringify(env) } }) ] }) webpack.config.prod.js 生产环境下我们不需要sourcemap,因此就不设置devtool了 ... const env = require(\"./conf/prod.json\") module.exports = merge(base,{ ... plugins: [ ... new webpack.DefinePlugin({ 'process.env': { 'NODE_ENV': JSON.stringify(env) } }) ] }) 收尾工作 最后我们修改下package.json中的scripts字段,为不同的执行命令区分环境: \"scripts\": { \"serv:dev\": \"./node_modules/.bin/webpack-dev-server --open --config env/webpack.config.dev.js\", \"serv:test\": \"./node_modules/.bin/webpack-dev-server --open --config env/webpack.config.test.js\", \"serv:prod\": \"./node_modules/.bin/webpack-dev-server --open --config env/webpack.config.prod.js\", \"build:dev\": \"./node_modules/.bin/webpack --config env/webpack.config.dev.js\", \"build:test\": \"./node_modules/.bin/webpack --config env/webpack.config.test.js\", \"build:prod\": \"./node_modules/.bin/webpack --config env/webpack.config.prod.js\" } 以上就是一个相对完整的webpack环境 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"web前端技术/Vue/":{"url":"web前端技术/Vue/","title":"Vue","keywords":"","body":"Vue.js攻略 Vue.js是一个专注于网页前端的框架项目,其支持渐进式的开发模式,也就是由少到多的使用它.不过本文的目标读者是非前端开发人员但需要使用前端技术的人,因此历史包袱小,我们没有必要从jquery开始按前端架构演变的路线一路下来,只需要直接全盘使用vue.js即可. vue.js的基本特点 vue.js本体专职页面渲染,大致有如下特点: 声明式模板 数据双向绑定 组件化 配合生态中的状态管理插件Vuex和路由插件Vue Router就可以完整的构建前端项目了. helloworld 我们先创建一个简单完整的vue项目用于演示.这个项目的代码在github上.通常为了快速开始我们会使用脚手架.vue.js的脚手架工具是vue cli使用npm install -g @vue/cli全局安装. 安装好后我们在目标文件夹下执行vue create helloworld 根据提示我们选择需要的插件,选择babel+vuex+Router即可.等全部安装完成我们进入项目文件夹下执行npm run serve即可执行,我们可以看到一个最简单的页面介绍vue项目;使用npm run build就可以将项目编译为前端项目的最终成果(在目录dist中). vue项目基本结构 我们可以看到基本结构如下: helloworld--| |--dist //编译完成后的项目 |--node_modules //依赖的模块 |--public--| | |--index.html //入口html文件,必须包含`` | |--favicon.ico //前端页的窗口图标 | |--src--| |--main.js //vue项目的入口 |--App.vue //vue项目的跟组件 |--assets //存放图片资源 |--router //定义路由,内部是js文件 |--store //定义状态,内部是js文件 |--views //展示视图组件 |--components //其他组件 vue.js是完全组件化的,通常每个文件就是一个组件,管理页面中的一个元素,组件之间可以嵌套,构造成一个组件树,这个组件树就是我们要表现的页面了.我们要表现的完整页面通常被称为视图(view)会放在单独的文件加下管理,通常组件树的根节点并不直接包含视图节点,而是通过路由来串联. 在这个例子中这个组件树如下: App.vue(+router)--| |--views/About.vue |--views/Home.vue--| |--components/HelloWorld.vue Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/工具链.html":{"url":"web前端技术/Vue/工具链.html","title":"工具链","keywords":"","body":"工具链 工欲善其事必先利其器,vue的生态属于麻雀虽小五脏俱全那种,该有的都有,但你也没什么可选择的.vue的工具链主要有几个方面 脚手架 chrome调试插件 vscode开发插件 脚手架 vue cli在helloworld项目中我们已经介绍并简单使用了,它使用npm install -g @vue/cli全局安装.,除了命令行用法外我们还可以使用vue ui可视化的配置前端项目.同时支持保存选择的配置到本地文件(~/.vuerc)中 我们使用vue cli构造一个了helloworld项目. vue cli是插件化的,我们可以使用vue add {插件名}来安装和初始化插件.当然也可以全程使用vue ui来完成,只要找到插件点击安装即可. 目前总结的实用插件除了官方的外还有: 功能性: vue-cli-plugin-axios绑定axios vue-cli-plugin-i18n国际化 vue-cli-plugin-moment性能优化 ui: vue-cli-plugin-electron-builderelement组件库 vue-cli-plugin-storybookstorybook组件库 跨平台: vue-cli-plugin-browser-extensionchrome插件 vue-cli-plugin-electron-builderelectron桌面端浏览器封装 vue-cli-plugin-uni-app小程序端 vue-cli-plugin-cordova移动端浏览器封装 vue-cli-plugin-nativescript-vue移动端nativescript chrome调试插件 可以在chrome中安装Vue Devtools插件来调试vue项目,它会在你的开发者工具中新增一项vue来专门用于调试组件.我们的组件会在其中展示所有的属性和数据状态. vscode插件 Vetur是官方给出的vue开发插件,有高亮显示关键字,快速模板展开,语法检查等各种功能,可以满足大部分需求. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/组件.html":{"url":"web前端技术/Vue/组件.html","title":"组件","keywords":"","body":"组件 vue.js中最基本的单位是组件,虽然vue可以使用Vue.component方式通过js构造组件,但它并不好用,更加推荐的做法是使用单文件组件.单文件组件使用扩展名.vue,它的基本形式如下: Home | About // @ is an alias to /src import HelloWorld from '@/components/HelloWorld.vue' export default { name: 'home', components: { HelloWorld } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; } #nav { padding: 30px; } #nav a { font-weight: bold; color: #2c3e50; } #nav a.router-link-exact-active { color: #42b983; } 可以看到每个组件可以有3个部分 脚本部分(可选),以标识,使用js语法,用于申明模板属性,操作等 模板部分(必须),以标识,用html语法构造组件模板.但是其中的元素可以是其他组件 样式部分(可选),以标识,使用css语法,当然如果有安装其他css转义语言插件也可以使用其他比如less这些.注意样式定义的作用域只在本组件,不是全局的 组件脚本 组件脚本部分使用声明式的方式定义组件的行为和属性.vue的脚本部分可以声明的属性可以查看api文档,比较重要的包括: data用于保存组件状态 props用于作为占位符接收来自父组件的数据 computed本质是惰性计算,类似python的属性描述符,计算属性是基于它们的响应式依赖进行缓存的,只要使用的数据不变就不会重新计算.这常用于计算比较复杂的数据 methods绑定函数,这个通常与事件结合使用,比如v-on:click这种. watch侦听属性,用于监听状态,并根据状态的变化进行操作. 组件模板 模板部分是每个组件必须定义的,和html文件一样它用于声明组件和其子组件间是什么样的关系.当组件只使用html自带的元素而没有使用其他组件时我们就可以只有组件模板部分没有组件脚本部分. 模板语法 vue的模板是跟着html来的,我们使用`来在元素的值部分插入内容,使用vue的指令`在元素的属性部分插入js的表达式.比如我们修改helloworld项目的about页面 This is an about page I'm ! baidu... export default { data: function() { return { user: \"hsz\", url: \"http://www.baidu.com\" }; } }; vue指令 所有的vue指令可以在api文档中查找到.比较重要的包括 变量绑定指令 事件绑定指令 循环指令 判断指令 变量绑定指令 变量绑定指令使用v-bind可以缩写为:.它可以绑定data中的字段,也可以绑定props占位后由父组件传进来的字段. 循环指令 一个常见的需求是我们的组件维护了一个列表,我们希望可以渲染出这个列表中每个元素,这时候就需要使用v-for.还是修改about页面. This is an about page I'm ! baidu... export default { data: function() { return { user: \"hsz\", url: \"http://www.baidu.com\", friends: [\"hzj\", \"tangqi\", \"zhengyufan\", \"yaolili\"] }; } }; 需要注意v-for中需要绑定一个特殊属性key用于辨识列表中的元素, 一个通用的方式就是使用v-for=\"(friend,index) in friends:key=index这样的方式.index是列表的索引,使用索引就不会有问题了. 判断指令 我们可能会需要根据属性的不同渲染不同的内容,这时候就会需要判断指令做分支.可以使用v-if. This is an about page I'm ! baidu... she is he is export default { data: function() { return { user: \"hsz\", url: \"http://www.baidu.com\", friends: [\"hzj\", \"tangqi\", \"zhengyufan\", \"yaolili\"] }; } }; 因为v-if是一个指令,所以必须将它添加到一个元素上.但是如果分支下面不是简单的内容而是一个复杂的结构,那就可以使用template元素作为一个隐藏的元素来放置v-if 如果只是为了简单的判断是否需要隐藏或者展示,我们可以使用v-show. This is an about page I'm ! baidu... he is export default { data: function() { return { user: \"hsz\", url: \"http://www.baidu.com\", friends: [\"hzj\", \"tangqi\", \"zhengyufan\", \"yaolili\"] }; } }; 事件绑定指令 事件绑定指令使用v-on,可以缩写为@.它可以绑定method中定义的函数或者是带赋值的表达式比如x+=1. 表单数据双向绑定 表单处理和发送是网页最传统的需求,vue中有专门的指令v-mode用于做表单数据的双向绑定. 我们改进about页面,增加一个表单用于添加好友. 我们需要通过v-mode将表单中的数据绑定到临时字段friend_name,friend_gender,friend_phone中,然后绑定表单的Submit按钮(注意不能用type为submit的按钮,因为会刷新页面)的点击事件到SaveToFriendsList方法.由这个方法将临时变量中的数据保存到friends这个列表中. This is an about page I'm ! baidu... 我的好友 姓名 性别 电话 Friend Info Name: Phone: Gender: male female export default { data: function() { return { user: \"hsz\", url: \"http://www.baidu.com\", friend_name: null, friend_gender: null, friend_phone: null, friends: [ { name: \"hzj\", gender: \"male\", phone: 123454 }, { name: \"tangqi\", gender: \"male\", phone: 128454 }, { name: \"zhengyufan\", gender: \"male\", phone: 163454 }, { name: \"yaolili\", gender: \"female\", phone: 123444 } ] }; }, methods:{ SaveToFriendsList: function(){ let newfriend = { name:this.friend_name, gender:this.friend_gender, phone:this.friend_phone } this.friends.push(newfriend) this.friend_name = null this.friend_gender = null this.friend_phone = null } } }; 组件状态变化和监控 我们可以声明一个watch用于监控组件中属性状态的变化,比如上面的例子我们可以添加watch监控friends,当有变化时我们弹出一个提示. ... export default { data: ..., methods: ..., watch: { friends: function(val, oldVal) { let newfriend = val[val.length - 1]; if (Notification.permission === \"granted\") { console.log(\"用户允许通知\"); let notification = new Notification(\"新增用户\", { body: newfriend }); } else { console.log(\"用户还没选择，去向用户申请权限吧\"); let newname = newfriend.name; alert(`新增用户${newname}`); } } } }; 组件生命周期 vue的组件都是有生命周期的,有生命周期也就意味着有钩子,我们就可以利用钩子做一些事情. 我们可以修改脚本部分,添加一个钩子用于每次更新后统计当前是多少个朋友 ... export default { data: ..., methods: ..., watch: ..., updated: function() { let now_len = this.friends.length; console.log(`共有用户${now_len}人`); } }; 子组件的声明 一个组件要在其上添加一个子组件需要先声明,像例子中Home.vue一样,要用什么子组件就需要先用`字段声明,然后才可以使用components` ... // 先导入 import HelloWorld from \"@/components/HelloWorld.vue\"; export default { ... //申明使用哪些组件,需要注意元素是组件对象而非字符串 components: { HelloWorld } }; 组件间交互 组件间的数据传递是使用前端框架的一个重要问题,在不使用vuex的条件下组件间交互可以分为3种: 父组件向子组件发送数据 子组件向父组件发送数据 节点组件向其所有子节点发送数据 更加复杂的组件间交互就需要使用vuex来实现了.这个会在状态维护部分介绍 父组件向子组件发送数据 父组件向子组件发送数据主要有如下几种途径: 通过Prop向子组件传递组件的属性状态 使用slot向子组件传递组件内容 通过Prop向子组件传递组件的属性状态 我们的组件home.vue和HelloWorld.vue已经使用了这个方式传递message这个值,原始的例子是传递一个静态的值,我们可以使用v-bind传递动态值; 同时prop除了必备的类型校验外还可以设置默认值和设置自定义校验器.我们也修改HelloWorld.vue为其设置一个默认值. 我们来实现一个功能传递打招呼人的名字,这个名字通过父组件传递,如果没有则使用默认的\"Welcome to Your Vue.js App\"来填充. Home.vue send message message: // @ is an alias to /src import HelloWorld from \"@/components/HelloWorld.vue\"; export default { name: \"home\", data: function() { return { msg: undefined }; }, watch: { msg: function(val, oldVal) { if ((val === null) | (val === \"\")) { this.msg = undefined; } } }, components: { HelloWorld } }; HelloWorld.vue ... export default { name: 'HelloWorld', props: { msg: { type: String, default: \"Welcome to Your Vue.js App\" } } } ... 使用slot向子组件传递组件内容 vue提供了标签用于像jinja2中的继承语法一样父组件向子组件传递元素的内容. 父组件 插入的内容 子组件 这是插槽 这样我们在父组件中卸载子组件内容中的内容就可以在中的内容可以被子组件获取到渲染出来 需要注意父组件和子组件是各自独立渲染的,插槽只会传递给子组件内容而无法传递父组件的其他属性字段.这里的内容可以是文本,可以是html也可以是其他组件的组合. slot的默认值 我们在slot定义的时候就可以给他赋个默认值,就是在标签slot中间填上内容. 子组件 这是插槽 slot默认值 具名slot slot可以有名字,在父组件的slot上使用这样的形式就可以指定子组件slot的名字,不指定名字的slot使用default作为名字, 而父组件可以通过v-slot指定要插入的slot名,这通常要配合标签使用. 父组件 Here might be a page title the main content. Here might be a page end 子组件 这是插槽 作用域插槽 我们很多时候会希望父组件使用插槽时可以使用子组件的属性,但由于父子组件都是各自渲染的,所以没有办法直接获取. vue提供了一套作用域插槽的方法来实现这一需要.子组件需要在声明插槽时定义插槽prop 子组件 这是插槽 使用v-bind将子组件的user属性传递给插槽prop的user属性,这样父级就可以使用v-slot的值来访问这个插槽prop了 父组件 Here might be a page title the main content. Here might be a page end 我们继续修改Home.vue和HelloWorld.vue让我们可以展示slot Home.vue send message message: 这边是 ! // @ is an alias to /src import HelloWorld from \"@/components/HelloWorld.vue\"; export default { name: \"home\", data: function() { return { msg: undefined }; }, watch: { msg: function(val, oldVal) { if ((val === null) | (val === \"\")) { this.msg = undefined; } } }, components: { HelloWorld } }; HelloWorld.vue ... 默认的插槽数据 export default { ... data: function(){ return { user:\"hsz\" } } } ... 子组件向父组件发送数据 子组件向父组件发送消息也是两种方式: 自定义事件消息. v-model绑定变量. 自定义事件消息 子组件向父组件传递消息最常见的方式是使用事件传递,子组件使用$emit(事件名:String,消息:Any)发出一个事件,这个事件可以带上消息, 父组件则使用v-on:事件名=事件处理函数或表达式监听这个事件处理消息. 下面我们为Helloworld.vue组件创建一个按钮,点击它我们就将事件传递到父组件弹出一个alert Helloworld.vue ... export default { ... methods: { sendToParent: function (){ this.$emit(\"toParent\",{\"msg\":\"1234\"}) } } } Home.vue ... 这边是 ! // @ is an alias to /src import HelloWorld from \"@/components/HelloWorld.vue\"; export default { ... methods: { recvFromChild: function(msg) { alert(msg.msg); } }, ... }; v-model绑定变量 我们前面使用v-model实现了表单标签和其父组件间的双向绑定,vue中的v-model本质上是这样的效果: 它需要子组件上有一个value字段的prop用于映射父组件上的字段searchText,并且监听一个事件input,当收到事件后将子组件的消息值赋值给父组件上的字段searchText. 可以看到v-model实际上在子组件上的实现只有两个东西: value字段的prop 事件input 我们可以定义model字段来自定义子模块使用v-model时使用的prop和事件,我们再来一个例子,让Home.vue使用v-model双向绑定Helloworld.vue中的一个input标签 Home.vue ... 这边是 ! // @ is an alias to /src import HelloWorld from \"@/components/HelloWorld.vue\"; export default { ... data: function() { return { ... child_msg: \"\" }; }, ... watch: { ... child_msg: function(val, oldVal) { alert(`子组件改变了父组件 child_msg:${val}`); } }, components: { HelloWorld } }; Helloworld.vue ... export default { ... model: { prop: 'co_msg', event: 'toParent2' }, props: { msg: { type: String, default: \"Welcome to Your Vue.js App\" } , co_msg: String }, ... } ... 当然了既然只是需要事件和prop就可以绑定v-model,那么自定义的v-model用途也就不局限在表单了. 节点组件向其所有子节点发送数据 节点组件向其所有子节点发送数据主要使用provide/inject来实现.这个方法并不推荐使用,主要是因为这会很不好debug.但我们还是可以给出一个例子. 我们修改App.vue,让其有字段provide,并给其他各个组件都设置inject App.vue ... export default { name: \"app\", provide: { foo: 'bar' }, }; ... About.vue about ... export default { inject: ['foo'], ... } Home.vue home ... // @ is an alias to /src import HelloWorld from \"@/components/HelloWorld.vue\"; export default { inject: ['foo'], ... }; Helloworld.vue hello world ... export default { inject: ['foo'], ... } ... Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/使用element组件包构建前端项目.html":{"url":"web前端技术/Vue/使用element组件包构建前端项目.html","title":"使用element组件包构建前端项目","keywords":"","body":"使用第三方组件库 使用组件库主要是为了快速开发,通常都不会要求有太多设计什么的,使用组件库最大的好处就是可以省去自己写css,组件逻辑这些事情的麻烦,我们要做的基本只是写个view层就可以了. vue生态下最知名的组件库应该是饿了么的element,本文也会使用这个组件库作为例子,其他比较流行的组件库还有iview 等.基本上使用也是一个套路. 我们可以使用vue-cli的插件vue-cli-plugin-element快速初始化一个项目. 如果是命令行操作就是创建好项目后执行vue add vue-cli-plugin-element,按提示选择一路回车就好.注意最好我们选择按需要部分导入而非全部导入. 一个完整的例子 接下来我们来做一个简单的英雄指南项目,这个项目非常经典,是angular教程使用的例子.这个例子我们会贯穿整个这一章节,这边只是先给出第一版--视图部分,因此本文对应这个项目的分支view-only. 后续的路由部分和数据状态部分我们会在接下来介绍 我们先来规划下这个例子,这个例子会有3个view: 首页仪表盘 英雄列表 英雄详情 他们之间的关系入下图 最终我们要做到的效果功能上如下: 当然因为是套组件,我们的样式不可能和上面的完全一致,本文重点也不是样式,而是如何构建一个vue的前端工程. vue-cli-plugin-element项目的结构 使用vue-cli-plugin-element插件构造的项目会比之前的helloworld项目多出一个文件夹src/plugins其中的element.js文件专门用于导入element组件,这也就意味着只要在这个文件中导入组件,那么这些组件就在项目的全局都可以被使用了.其基本使用方式是: import Vue from 'vue' import { Container, Main, Header, } from 'element-ui' Vue.use(Container) Vue.use(Main) Vue.use(Header) 我们只需要导入要用的组件,然后使用Vue.use加载它即可. 视图构建 上面说过我们有3个视图 首页仪表盘 英雄列表 英雄详情 我们分别来构造这三个视图的页面,但在这之前我们先来给整个页面排个版.在考虑路由和数据之前我们先使视图组件内各自有自己的数据,同时在根节点上直接展示这3个view组件以方便调试. 可以看到这个最终版本app头部实际上是一直不变的,永远是app名字和两个主要视图的路由;而下面会变的部分才是这些路由渲染的页面.我们可以在App.vue组件上声明好这个根视图. App.vue 英雄指南 仪表盘 英雄列表 import Dashboard from \"./views/Dashboard.vue\"; import Herodetail from \"./views/Herodetail.vue\"; import Herolist from \"./views/Herolist.vue\"; export default { name: \"app\", data() { return { activeIndex: \"1\" }; }, components: { Dashboard, Herodetail, Herolist } }; #app { font-family: \"Avenir\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 这个根视图除了我们的view组件外使用了如下组件: 容器相关 这部分是容器相关的组件,用于对app整体布局. | 组件模块对象 | 组件名 | 功能 | | ------------ | ------------ | -------------- | | Container | el-container | 声明容器 | | Main | el-main | 声明是主体部分 | | Header | el-header | 声明是头部 | 容器相关的组件会根据配置自动按规则排版,具体的可以去看官方文档 布局相关 这部分布局相关的组件通常需要配合容器相关组件,通常容器相关的是整体布局,而布局相关的则是局部布局,element类似以前的bootstrap使用行作为单位,每一行被分成24份,通过设置一些参数进行排列其中的单元, | 组件模块对象 | 组件名 | 功能 | | ------------ | ------ | ---------------- | | Row | el-row | 声明这是一行组件 | 导航菜单 导航菜单组件作用就是构造导航栏,除了可以构造这种传统的顶部导航栏,也可以构造侧边导航.具体的可以看文档中的样例. | 组件模块对象 | 组件名 | 功能 | | ------------ | ------------ | ------------------ | | Menu | el-menu | 声明导航栏 | | MenuItem | el-menu-item | 声明导航栏中的项目 | 分割线 分割线组件模块可以以特定格式画出一条分割线 | 组件模块对象 | 组件名 | 功能 | | ------------ | ---------- | -------------- | | Divider | el-divider | 声明一条分割线 | 首页仪表盘 仪表盘我们可以看到其实就两行 标题行 一个卡片的横向排列行,卡片上是我们的英雄名字 我们的组件可以这样定义: Dashboard.vue Top Heros 白金之星 红色魔术师 隐者之紫 法皇 银色战车 export default { name: \"dashboard\" }; 我们现在只是展示用,数据都是写死的.这不重要,后续我们再来整理这些数据. 这个组件使用到的element组件有: 布局相关 此处出现布局中的列,列是布局中的最小单元,行上,可以决定列的间隔,对其方式等属性,列自己则可以决定自己占据行中的长度. | 组件模块对象 | 组件名 | 功能 | | ------------ | ------ | -------------------- | | Col | el-col | 声明这是一行中的一列 | 卡片组件 卡片组件一般用于展示图片或者介绍信息,其主要的配置项是 header这是一个slot,可以插入内容,通常用于些标题或者操作按钮什么的 body-style这个属性可以传入css描述,借此可以插入图片,填充背景色等等 shadow卡片阴影,通常用于交互,提示用户的鼠标覆盖情况 英雄列表 英雄列表也是很简单的结构 一个标题 一个英雄的表格 我们的组件可以这样定义: Herolist.vue Hero List 编辑 删除 export default { name: \"herolist\", data: function() { return { heros: [ { id: 1, name: \"隐者之紫\" }, { id: 2, name: \"红色魔术师\" }, { id: 3, name: \"白金之星\" }, { id: 4, name: \"法皇\" }, { id: 5, name: \"银色战车\" } ] }; }, methods: { handleEdit(index, row) { console.log(index, row); }, handleDelete(index, row) { console.log(index, row); } } }; 这个组件使用到的element组件有: 表格组件 表格是展示结构化数据的最佳方式,element提供了足够优秀的表格组件,可以满足大部分需求,具体的样式可以看文档. element的表格导入数据使用data字段,只要绑定这个字段到我们的父组件上想展示的列表数据上就可以了,因此表格的配置主要是配置列.列除了可以使用data字段中的值外,也可以插入其他元素或者自定义样式,只要使用作用域slot即可. | 组件模块对象 | 组件名 | 功能 | | ------------ | --------------- | -------------------------------- | | Table | el-table | 声明这是一个表格,必须绑定data | | TableColumn | el-table-column | 声明这是一列,可以设置标题,宽度等 | 标签组件 标签组件一般用于标记和选择,预定义了几种type类型success/info/warning/danger用颜色区分等级,如果不填则使用默认配色. | 组件模块对象 | 组件名 | 功能 | | ------------ | ------ | ---------------- | | Tag | el-tag | 声明这是一个标签 | 按钮组件 按钮组件就是定义一个按钮,可以通过size字段设置medium / small / mini定义按钮大小,通过plain/round/circle这些属性的布尔值来设定形状,也可以使用icon添加图标. | 组件模块对象 | 组件名 | 功能 | | ------------ | --------- | ---------------- | | Button | el-button | 申明这是一个按钮 | 英雄详情 详情页我们就做一个例子介绍隐者之紫好了. Herodetail.vue 英雄详情 名字： 提交 export default { name: \"herolist\", data: function() { return { hero_name: \"\", hero: { id: 1, name: \"隐者之紫\" } }; }, methods: { submitHero: function (){ if (this.hero){ this.hero=Object.assign(this.hero,{name:this.hero_name}) this.hero_name=\"\" } } } }; 项目中详情页即作为我们的展示页,也作为修改页,也作为新增页. 详情页我们用的组件有: 输入框 这个组件可以使用v-mode做数据的双向绑定.input的类型可以时html中规定的类型 | 组件模块对象 | 组件名 | 功能 | | ------------ | -------- | ------------------ | | Input | el-input | 申明这是一个输入框 | 至此,我们的三个页面就都写好了,虽然只是初版,还很不成熟,但基本的样式已经有了,后续的就是数据通信和路由设置了. 在后续的介绍中我们还会修改现有的方案使用的组件以满足更多的需求. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/数据状态维护.html":{"url":"web前端技术/Vue/数据状态维护.html","title":"数据状态维护","keywords":"","body":"数据状态维护 观察我们的英雄指南项目,可以看出其实所有的数据都可以放在同一个数据结构下: heros=[ {id:int,name:str}, ... ] 而且各个组件间这个数据应该是共享的,一处组件改变了这个数据就该会处处都改变. 这种相对比较复杂的需求就可以使用vuex来实现了. 本文的代码在store分支 store 每一个 Vuex 应用的核心就是store(仓库).store基本上就是一个容器,它包含着你的应用中大部分的状态(state).Vuex和单纯的全局对象有以下两点不同: Vuex 的状态存储是响应式的.当 Vue组件从store中读取状态的时候,若store中的状态发生变化,那么相应的组件也会相应地得到高效更新. 你不能直接改变store中的状态.改变store中的状态的唯一途径就是显式地提交(commit)mutation.这样使得我们可以方便地跟踪每一个状态的变化,从而让我们能够实现一些工具帮助我们更好地了解我们的应用. vuex使用单一状态树保存和维护状态,也就是说一个应用只会有一个store对象, 在我们的项目中,store文件夹中的index.js就是用于创建和管理store对象的. 一个典型的store对象如下定义: Vuex.Store({ state: { }, getters:{ }, mutations: { }, actions: { }, modules: { } }) 其中 state声明和初始化要保存维护状态的数据 getters是关于state的惰性计算,类似python中的属性 mutations声明和定义所有对state的写操作,所有的写操作必须使用这其中定义的方法.注意mutation中只能是同步的函数,异步函数无法使用. actions,对mutations的进一步包装,可以使用异步函数,通常我们的组件不会直接执行mutations中的函数访问数据,而是通过actions.毕竟可以使用异步函数会方便很多. modules,方便拆分业务可以用modules组合外部定义的store描述对象. 可以看出vuex的结构是读写分离的, state和getters负责读,mutations和actions负责写.而不同的业务则可以用多个文件描述,最终使用modules组合使用 要在vue组件中访问store,我们需要先将其注册到所有vue组件上,在main.js中我们使用如下设置实现. main.js ... import store from './store' ... new Vue({ ... store, ... }).$mount('#app') 这样我们就可以在所有的组件中通过访问this.$store来访问store对象了 业务拆分 我们的项目实际上只有一个业务--管理英雄列表,因此我们可以拆出一个模块来,store文件夹结构如下: store--| |--index.js |--modules--| |--herolist.js 我们的herolist.js文件如下: // initial state import { heroValidate } from \"../../validates\" const Counter = () => { let count = 0 return () => { count += 1 return count } } let counter = Counter() const state = { heros: [] } // getters const getters = { getHero: (state) => (heroId) => { if (typeof(heroId)===\"number\"){ let hero_list = state.heros.filter(hero => hero.id === heroId) if (hero_list.length === 0) { return null } else { let hero = hero_list[0] hero = {...hero} return hero } }else{ return null } }, first5heros: (state) => { if (state.heros.length > 0) { let heros_copy = [...state.heros] return heros_copy.sort((herof, herol) => herol.weight - herof.weight).slice(0, 5) } else { return [] } } } // actions 定义业务逻辑 const actions = { appendHero(context, payload) { let heroObj = payload.heroObj let validated = heroValidate(heroObj) if (validated) { context.commit('appendHero', payload) } else { console.error(`添加hero失败,验证错误`) } }, updateHero(context, payload) { context.commit('updateHero', payload) } } // mutations 定义数据状态的操作 const mutations = { appendHero(state, payload) { let id = counter() let weight = Math.floor((Math.random() * 100) + 1); let hero = Object.assign(payload.heroObj, { id, weight }) state.heros.push(hero) }, deleteHero(state, payload) { state.heros = state.heros.filter((i) => i.id !== payload.heroId) }, updateHero(state, payload) { let heros_copy = [...state.heros]; let hero_list = heros_copy.filter(hero => hero.id === payload.heroId) if (hero_list.length !== 0) { let hero = hero_list[0] Object.assign(hero, payload.source) state.heros = heros_copy } } } export default { namespaced: true, state, getters, actions, mutations } 我们定义了state,getters,actions,mutations并将其打包为一个模块对象直接暴露给index.js 而index.js文件如下: import Vue from 'vue' import Vuex from 'vuex' import herolist from './modules/herolist' Vue.use(Vuex) const debug = process.env.NODE_ENV !== 'production' export default new Vuex.Store({ state: { }, mutations: { }, actions: { }, modules: { herolist }, strict: debug }) index.js中我们将vuex注册到vue上,并将herolist放到了modules中 严格模式 上面的字段拆分中我们已经介绍了vuex对状态的控制是读写分离的,必须使用mutation来写.但这个机制在vue中并不是强制的,如果要强制这样就可以使用严格模式. 在严格模式下,无论何时发生了状态变更且不是由mutation函数引起的都将会抛出错误.这能保证所有的状态变更都能被调试工具跟踪到.但注意不要在发布环境下启用严格模式. 严格模式会深度检测状态树,这回造成性能损失 影响应用鲁棒性,如果有开发人员没按严格模式的要求做读写分离而且上线检查没有查出来,那就造成了线上应用崩溃的可能. 我们在index.js中通过监控NODE_ENV状态来判断是否启用严格模式. ... const debug = process.env.NODE_ENV !== 'production' ... export default new Vuex.Store({ ... strict: debug }) 命名空间 如果在模块中不声明namespaced: true,那么模块中定义的所有字段都会进入全局命名空间,也就是说比如我们在A模块中定义了state中的字段A_a,那么在B模块中同样可以用A_a来访问到. 这在一些业务场景中当然是有用的,但一旦有多人参与或者项目变大就会很容易造成混乱,同时也不利于复用和分发.因此我们一般都会使用namespaced: true声明使用命名空间. 读数据 state state是实际负责保存数据状态的.它和vue中的data一样要求数据是纯粹(plain)的.无论是其他读操作还是写操作,归根到底都是在访问state. 其大致定义方法如下: const state = { heros: [] } 我们需要声明一个字段,并给他一个初值. 在vue组件中我们通过this.$store.state访问,像上面的heros字段,我们就可以用this.$store.state.heros来访问,如果我们使用了命名空间,那么因为模块路径为herolist.js, 我们就需要用this.$store.state.herolist.heros来访问它 getters getters是针对state的惰性计算,类似vue中的computed.它可以有参数,但需要借助函数封装,主要是用于封装一些由state来的数据,比如我们希望按id号从heros中取出一个hero,就可以定义一个getter来实现 const getters = { hero: (state) => (heroId) => { let hero_list = state.heros.filter(hero => hero.id === heroId) if (hero_list.length === 0) { return null } else { let hero = hero_list[0] hero = {...hero} return hero } }, ... } 在vue组件中访问getters需要使用store.getters访问,如果是全局命名空间可以直接使用.运算符获取:store.getters.hero; 如果是独立命名空间,则需要使用ES6的Symbol语法访问store.getters['herolist/hero']. 写数据 mutations vuex中只有mutations可以用于对state做写操作,其使用消息机制,我们在mutations中定义的实际上是回调函数,而这些回调函数的就依靠与这些函数同名的事件来触发. 我们知道消息机制可以有效的防止资源争抢.mutations中定义的回调函数满足如下签名(state:object[,payload:Any])->None.其中state就是本地命名空间下的state对象. 而在vue组件中可以使用store.commit(event:str[,payload:Any[,{ root: true }]])来提交事件消息,第三个参数用来强制分发事件到全局命名空间. Mutation回调函数的定义需遵守Vue的响应规则: 提前在你的store中初始化好所有所需属性 当需要在对象上添加新属性时应该使用Vue.set(obj, 'newProp', 123),或者以新对象替换老对象,更加推荐后一种. 在我们的例子中需要对数据进行的操作基本只有如下几个: 添加 删除 修改 在例子中我们的mutations如下定义 const mutations = { appendHero(state, payload) { let id = counter() let weight = Math.floor((Math.random() * 100) + 1); let hero = Object.assign(payload.heroObj, { id, weight }) state.heros.push(hero) }, deleteHero(state, payload) { state.heros = state.heros.filter((i) => i.id !== payload.heroId) }, updateHero(state, payload) { let heros_copy = [...state.heros]; let hero_list = heros_copy.filter(hero => hero.id === payload.heroId) if (hero_list.length !== 0) { let hero = hero_list[0] Object.assign(hero, payload.source) state.heros = heros_copy } } } actions 实际上离业务更近的还是actions,它和mutations类似也是消息机制,因此也是两块--回调函数和消息发送. 回调函数部分满足如下签名(context:object[,payload:Any])->None, 其中context包含如下字段: state本地命名空间的state commit提交mutations消息的commit getters本地命名空间的getters dispatch提交actions消息的dispatch,用于组合actions构造复杂业务结构 rootState全局命名空间的state rootGetters全局命名空间的getters 而在vue组件中可以使用store.dispatch(event:str[,payload:Any[,{ root: true }]])来提交事件消息,第三个参数用来强制分发事件到全局命名空间. 与commit不同的是,如果回调函数是一个异步函数,dispatch则可以被await 映射 为了可以更加方便的在vue组件中使用store,vuex提供了4种映射函数,他们会返回一个对象,其中的字段就是我们要映射的字段. 我们可以利用对象展开运算符将它们直接展开到vue组件种需要的位置,然后像使用vue组件本身的字段一样的使用映射的字段. 这4个映射函数是 mapState用于映射state mapGetters用于映射getters mapMutations用于映射mutations mapActions用于映射actions 通常mapState和mapGetters会放在vue组件的computed字段中;而mapMutations和mapActions会放在methods里. 由于这几个映射的用法基本一样,只是mapState由于我们是放在computed中所以需要将其放到函数里. ... computed: { ...mapState(\"herolist\", { heros: state => state.heros }) }, ... 另外三个我就不一一举例,这边我们以mapGetters为computed添加字段为例: ... computed: { ...mapGetters(\"herolist\", [\"first5heros\"]) } ... 而访问它们也就和访问正常的computed或者其他字段中定义的值或者方法一样了. 针对业务的修改 这个例子中我们还有额外几处修改: 一个序列号生成器,用于生成英雄的id.这个实现就很简单了,就是一个闭包. const Counter = () => { let count = 0 return () => { count += 1 return count } } let counter = Counter() 一个随机的权重,用于在首页仪表盘中为英雄排序. ... const getters = { ... first5heros: (state) => { if (state.heros.length > 0) { let heros_copy = [...state.heros] return heros_copy.sort((herof, herol) => herol.weight - herof.weight).slice(0, 5)//按权重排序并截取前5位 } else { return [] } } } ... const mutations = { appendHero(state, payload) { let id = counter() let weight = Math.floor((Math.random() * 100) + 1);//随机权重 let hero = Object.assign(payload.heroObj, { id, weight }) state.heros.push(hero) }, ... } ... 数据验证 由于有用户输入环节,我们有必要做一下数据验证,一个比较通用的方法就是使用我们的老朋友json schema,js中比较常用的实现是ajv. import Ajv from \"ajv\" const heroSchema = { \"type\": \"object\", \"properties\": { \"name\": { \"type\": \"string\" } } } const ajv = new Ajv() const heroValidate = ajv.compile(heroSchema) export { heroValidate } 要使用的时候只要import进来,然后当方法那样执行即可: ... import { heroValidate } from \"../../validates\" ... let validated = heroValidate(heroObj) if (validated) { ... } else { ... } 可以看出和数据相关的逻辑都在store中,这也是关注点分离的一个体现,vue组件负责交互和样式,vuex则专注于数据 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/路由.html":{"url":"web前端技术/Vue/路由.html","title":"路由","keywords":"","body":"路由 在前面的例子中我们只是将view组件排列到根组件上,但是通常我们会讲究体验--交互应该是有层级有路径的,这就需要另一个插件vue router 这部分我们的代码在router分支中. 定义路由 一个路由对象的定义格式如下: { path: string, component?: Component, name?: string, // 命名路由 components?: { [name: string]: Component }, // 命名视图组件 redirect?: string | Location | Function,//重定向 props?: boolean | Object | Function,//参数传入组件 alias?: string | Array,//路由别名 children?: Array, // 嵌套路由 beforeEnter?: (to: Route, from: Route, next: Function) => void,//进入路由指定的view前的钩子 meta?: any, // 2.6.0+ caseSensitive?: boolean, // 匹配规则是否大小写敏感？(默认值：false) pathToRegexpOptions?: Object // 编译正则的选项 } 项目中我们的路由定义在文件router/index.js中. import Vue from 'vue' import VueRouter from 'vue-router' import Dashboard from '../views/Dashboard.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'dashboard', component: Dashboard }, { path: '/herolist', name: 'Herolist', component: () => import(/* webpackChunkName: \"about\" */ '../views/Herolist.vue') }, { path: '/herodetail', name: 'HeroCreate', component: () => import(/* webpackChunkName: \"about\" */ '../views/Herodetail.vue') }, { path: '/herodetail/:id', name: 'Herodetail', component: () => import(/* webpackChunkName: \"about\" */ '../views/Herodetail.vue') } ] const router = new VueRouter({ routes }) export default router 路由定义的基本结构 可以看到我们定义的路由实际是按Array[Object]的形式定义,然后使用new VueRouter({routes})构造而成的.路由列表中的每个object固定有字段: path路径,访问到view组件的路径 name路由名(可选),用于方便的定位特定到路由 component路由对应的组件,可以是组件对象也可以是组件的工厂函数. 路由懒加载 我们在router中并没有一开始就导入所有的view,而是使用了懒加载的功能,除了首页的dashboard外我们都是按需加载的,这可以一定程度上降低服务器单次请求的压力,要使用懒加载也很简单,在定义component时不是直接指定组件而是使用工厂函数返回组件对象即可. 注册路由对象 在main.js中我们需要将创建出来的router注册到vue项目上: ... import router from './router' new Vue({ router, ... }).$mount('#app') 这样router对象就会注册在vue项目所有组件的this.$router上了. 路由内容展示 有专门的组件专门用于展示路由对应的内容.这通常在根组件上申明位置. 路由跳转 路由跳转有两种方式: 声明式导航,使用组件,这种方式是比较推荐的方式,点击对应的组件就会跳转到指定路径.我们可以在组件中定义好path然后绑定to的值,这样利于组件模块化减少耦合 编程式导航,使用函数router.push/router.replace/router.go实现让页面跳转到对应的route上 this.$router.push(routeObject[,onComplete[, onAbort]])最常见的跳转函数,routeObject可以有如下字段: path:\"/herolist\"直接通过路径跳转 name:\"Herolist\"使用名字跳转 params: { userId: '123' }用于构造动态路由,比如name:\"Herolist\",params: { userId: '123' }则相当于访问路径模板为/herolist/:userId的路径/herolist/123 query: { plan: 'private' }用于构造路由请求,比如name:\"Herolist\",query: { plan: 'private' }则相当于访问路径/herolist/?plan=private this.$router.replace(routeObject[,onComplete[, onAbort]])跟router.push很像,唯一的不同就是,它不会向history添加新记录,而是跟它的方法名一样--替换掉当前的history记录. this.$router.go(n)这个方法的参数是一个整数,意思是在history记录中向前或者后退多少步,类似window.history.go(n),这个方法常用在实现后退操作.一个常见的goback实现如下goBack() { window.history.length > 1 ? this.$router.go(-1) : this.$router.push(\"/\"); } 需要注意一般使用path就不会用name了,而params在有path字段时是无效的. 动态路由 像我们项目中的Herodetail.vue组件它需要可以访问指定id的英雄.我们不能知道究竟有多少个英雄所以也就没法通过创建固定个数的组件来满足这个要求,这种时候就可以使用动态路由.动态路由定义和一般的后端框架类似,就是使用:id这样的形式,需要注意的是获取到的id是String类型,需要做一些必要的类型转化. ... { path: '/herodetail/:id', name: 'Herodetail', component: () => import(/* webpackChunkName: \"herodetail\" */ '../views/Herodetail.vue') } ... 通常vue组件有两种方式获取到动态路由中的值: 使用this.$router.params获取所有定义的动态路由占位符的值.这种方式比较简单直观,但明显不利于组件复用 使用组件的props承接来自路由的占位符的值.这种方式需要在定义路由时声明props router... { path: '/herodetail/:id', name: 'Herodetail', component: () => import(/* webpackChunkName: \"herodetail\" */ '../views/Herodetail.vue'), props:true } ... 组件... props: { id: { type: String, default: null } }, ... 路由参数 上面讲到路由可以使用query带参数,组件接收query中的参数也可以使用this.$router.query获取.如果也想像动态路由一样使用props传参,则可以在路由定义时声明一个函数来实现: { path: '/herodetail', name: 'Herodetail', component: () => import(/* webpackChunkName: \"herodetail\" */ '../views/Herodetail.vue'), props: (route) => ({ query: route.query.q }) } 这样在路径/search?q=vue时会将{query: 'vue'}作为属性传递给组件Herodetail 嵌套路由 vue-router支持嵌套路由,这种路由的形式也很常见,比如一个接口是 /user/:id/friends,一个接口是/user/:id/parents,我们当然也可以不使用嵌套路由来定义,但这样可能不利于业务划分.如果使用嵌套路由,则可以这样定义 ... { path: '/user/:id', component: User, children: [ { // 当 /user/:id/friends 匹配成功， // UserFriends 会被渲染在 User 的 中 path: 'friends', component: UserFriends }, { // 当 /user/:id/parents 匹配成功 // UserParents 会被渲染在 User 的 中 path: 'parents', component: UserParents } ] } ... html5的history模式路由 vue-router支持使用html5的history模式的路由,不过并不推荐使用,因为这需要服务端配合实现. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/从后端同步数据.html":{"url":"web前端技术/Vue/从后端同步数据.html","title":"从后端同步数据","keywords":"","body":"从后端同步数据 web应用的最大特点就是网络连接,后台服务自然是不可缺少的,我们现在用koa构建一个简单的api服务,使用pg做后端服务器,来模拟真实情况.本部分的代码在remote-api分支. api服务器在api_server文件夹下,要执行可以直接使用命令npm run api启动.默认我们的api服务会在localhost:5000启动,我们的api服务已经做好了接收跨域请求的设置. 由于我们在前面已经做好了数据和交互展示的分离工作,这边的例子就只需要修改store部分了. 本文主要是介绍如何在vuex中使用异步操作. 异步操作 我们的数据来自远端的api服务器,所以自然的,操作都是异步操作,vuex的actions支持使用异步函数定义,这样我们就可以使用异步操作了. herolist.js // initial state import axios from 'axios' ... // actions 定义业务逻辑 const actions = { async appendHero(context, payload) { let score = Math.floor((Math.random() * 100) + 1); let heroObj = Object.assign(payload.heroObj, { score }) let validated = heroValidate(heroObj) if (validated) { console.log(heroObj) let response = await axios.post( 'http://localhost:5000/hero', JSON.stringify(heroObj), { headers: { 'Content-Type': 'application/json' } } ) if (response.status !== 200) { console.error(`添加到服务器失败`) console.error(response.data) } else { heroObj = response.data.data console.log(heroObj) //context.commit('appendHero', { heroObj }) } } else { console.error(`添加hero失败,验证错误`) } }, async updateHero(context, payload) { let heroId = payload.heroId let source = payload.source let response = await axios.put( `http://localhost:5000/hero/${heroId}`, JSON.stringify(source), { headers: { 'Content-Type': 'application/json' } } ) if (response.status !== 200) { console.error(`更新到服务器失败`) }else{ context.commit('updateHero', payload) } }, async deleteHero(context, payload) { let heroId = payload.heroId let response = await axios.delete( `http://localhost:5000/hero/${heroId}`, { headers: { 'Content-Type': 'application/json' } } ) if (response.status !== 200) { console.error(`从服务器删除失败`) }else{ context.commit('deleteHero', payload) } }, async syncHeros(context) { let response = await axios.get('http://localhost:5000/hero') let heros = response.data.result console.log(heros) let payload = { heros } context.commit('syncHeros', payload) } } // mutations 定义数据状态的操作 const mutations = { syncHeros(state, payload) { let heros = payload.heros state.heros = heros }, appendHero(state, payload) { let hero = payload.heroObj state.heros.push(hero) }, deleteHero(state, payload) { state.heros = state.heros.filter((i) => i.id !== payload.heroId) }, updateHero(state, payload) { let heros_copy = [...state.heros]; let hero_list = heros_copy.filter(hero => hero.id === payload.heroId) if (hero_list.length !== 0) { let hero = hero_list[0] Object.assign(hero, payload.source) state.heros = heros_copy } } } ... 可以看到我们把所有除更新state外的操作全部移除出了mutations,而在actions中我们增加了从服务器获取全部heros的异步方法syncHeros, 同时写操作也都会先通过api接口修改线上的,再修改本地的状态.为了保证数据最新,我们在Dashboard和Herolist上使用钩子created和api服务同步数据. ... created: function() { this.$store.dispatch(\"herolist/syncHeros\"); } ... Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:06:38 "},"web前端技术/Vue/属性展示.html":{"url":"web前端技术/Vue/属性展示.html","title":"属性展示","keywords":"","body":"属性展示 现在我们的英雄指南项目只是列出了英雄的名字和id,还没有展示英雄的细节属性,我们来重新设计英雄的属性数据,并结合v-charts项目构造各个英雄的属性雷达图. 这个项目的代码在hero-detail分支.主要是展示如何使用v-charts构造数据分析常用的图形以及如何在vue组件中使用异步函数. 英雄属性 我们定义英雄的属性有6个维度--破坏力,速度,射程距离,持久力,精密度,成长性. 我们的接口服务提供一个接口Get /hero/:id来获取特定id的英雄的各项属性.如果正常返回,其结果的result字段形式为: { \"type\": \"object\", \"required\": [\"name\", \"quality\"], \"properties\": { \"name\": { \"type\": \"string\" }, \"quality\": { \"type\": \"object\", \"required\": [\"速度\", \"成长性\", \"持久力\", \"破坏力\", \"精密度\", \"射程距离\"], \"properties\": { \"速度\": { \"type\": \"integer\", \"maximum\": 100, \"exclusiveMinimum\": 0, }, \"成长性\": { \"type\": \"integer\", \"maximum\": 100, \"exclusiveMinimum\": 0, }, \"持久力\": { \"type\": \"integer\", \"maximum\": 100, \"exclusiveMinimum\": 0, }, \"破坏力\": { \"type\": \"integer\", \"maximum\": 100, \"exclusiveMinimum\": 0, }, \"精密度\": { \"type\": \"integer\", \"maximum\": 100, \"exclusiveMinimum\": 0, }, \"射程距离\": { \"type\": \"integer\", \"maximum\": 100, \"exclusiveMinimum\": 0, } } } } } 由于我们的英雄属性是进入详情页后再加载的,因此我们需要访问接口/hero/:id获取要展示的内容,这种策略在web服务中相当常见.我们主要修改的是Herodetail.vue文件, 其他只有store中的代码需要做小幅的修改以适应新的访问逻辑. Herodetail.vue 英雄详情 名字： 提交 后退 名字： 随机生成 提交 英雄属性 import { mapActions } from \"vuex\"; import { random100 } from \"../utils\"; export default { name: \"herodetail\", data: function() { return { hero: { name: \"\", quality: {} } }; }, props: { id: { type: String, default: null } }, computed: { has_quality: function() { if (Object.keys(this.hero.quality).length !== 0) { return true; } else { return false; } }, chartData: function() { let data = { columns: [ \"name\", ...Object.keys(this.hero.quality) ], rows: [ { name: this.hero.name, ...this.hero.quality } ] }; return data; } }, methods: { ...mapActions(\"herolist\", [\"appendHero\", \"updateHero\"]), afterconfig: function(option) { console.log(option); option.radar.indicator.forEach(i=>i.max=100) return option; }, submitHero: function() { if (this.id) { let hero = { ...this.hero }; this.updateHero({ heroId: Number(this.id), source: hero }); this.hero = Object.assign(this.hero, hero); } else { let hero = { ...this.hero }; this.appendHero({ heroObj: hero }); this.hero.name = \"\"; this.hero.quality = {}; } }, randomHeroQuality: function() { this.hero.quality = { 速度: random100(), 成长性: random100(), 持久力: random100(), 破坏力: random100(), 精密度: random100(), 射程距离: random100() }; }, goBack: function() { window.history.length > 1 ? this.$router.go(-1) : this.$router.push(\"/\"); } }, watch: { id: function(newVal, oldVal) { if (newVal === null) { this.hero = { name: \"\", quality: {} }; } } }, created: function() { if (this.id) { let heroId = Number(this.id); this.createdPromise = this.$axios.get(`/hero/${heroId}`); } }, mounted: async function() { if (this.id) { let heroId = Number(this.id); let response = await this.createdPromise; this.hero = response.data.result; } } }; vue-cli-plugin-axios插件 我们在从后端同步数据一文中是使用的axios来请求数据的.但那仅限于在少数模块中简单使用,一旦涉及到复杂的统一配置,将会难以维护. 一个更加优雅的方法是使用插件vue-cli-plugin-axios,它可以像其他插件一样的被安装使用,它只是axios的简单包装,将配置统一放置在了plugins/axios.js中,同时将实例绑定到了window对象和vue的所有模块对象上.要在Vue组件中使用axios可以通过对象this.$axios.要在其他地方使用则可以通过对象window.axios. 我们在plugins/axios.js中定义了整个项目http请求的基本设置: let config = { baseURL: process.env.baseURL || process.env.apiUrl || \"http://localhost:5000\", timeout: 60 * 1000, // Timeout // withCredentials: true, // Check cross-site Access-Control }; 使用异步钩子获取英雄属性 vue的钩子并不能等待异步函数执行完,但它可以先触发执行异步函数.我们可以使用两个钩子协同操作来获取英雄的属性. ... created: function() { if (this.id) { let heroId = Number(this.id); this.createdPromise = this.$axios.get(`/hero/${heroId}`); } }, mounted: async function() { if (this.id) { let heroId = Number(this.id); let response = await this.createdPromise; this.hero = response.data.result; } } created钩子会执行请求操作,但我们在这里并不关心结果,我们会把这个请求的Promise赋值给当前的这个组件 mounted钩子会在渲染好后执行,此时我们取出Promise中获取到的英雄数据将其赋值给我们组件中的data中的hero字段. 由于mounted钩子执行时已经使用默认的hero对象渲染完成了,之后再取出英雄的属性重新赋值相当于刷新组件的hero字段. 我们当然也可以在created钩子里定义好给data中的hero字段赋值的语句,它也会正常执行,但我们就无法控制它是在什么时候赋值完成的了. 组件监听id值避免bug 在之前的例子中我们修改了hero的名字提交后无法直接体现在组件的变化上,需要刷新下页面才会有变化.这是因为我们的实现是利用id构造一个惰性的computed,我们展示的是这个computed的中hero的值.由于id没有变化所以hero在修改前后都不会变化.而修改我们利用了一个中间量hero_name,它不会直接体现在hero上.这个逻辑并不好,我们可以改为直接操作data下的数据hero,这样就可以实时的进行改变. 使用v-charts展示英雄属性 v-charts是echarts的封装,和echarts一样,它使用声明式的语法,我们只要按规定的样式设置好要展示的数据即可. 它的安装也很简单:npm i v-charts echarts -S v-charts通过绑定data属性来获取数据,通过settings属性来设置图形的样式等,而events则可以用于绑定事件的回调函数 我们使用的是雷达图,只需要设置数据即可,我们直接使用原始设置. computed: { ... chartData: function() { let data = { columns: [ \"name\", ...Object.keys(this.hero.quality) ], rows: [ { name: this.hero.name, ...this.hero.quality } ] }; return data; } }, 由于v-charts的雷达图无法直接设置各个维度的最大值,它的默认值是所有行的同列最大值. 好在它提供了钩子after-config可以在渲染之前修改实际要渲染的echarts图像的配置.我们借助它修改雷达图各个维度的最大值. 这个属性的值必须是一个回调函数,这个回调函数满足签名function afterconfig(options:Object)->options:Object. ... methods: { ... afterconfig: function(option) { console.log(option); option.radar.indicator.forEach(i=>i.max=100) return option; }, ... 补充:异步computed属性 另一种实现方式是使用异步的computed,这不是vue原本支持的方法,要实现这个需要安装插件vue-async-computed实现,它可以定义asyncComputed来替换computed字段,这样在其中定义异步函数即可.使用方法是先将插件模块注册到vue中: import AsyncComputed from 'vue-async-computed' /* Initialize the plugin */ Vue.use(AsyncComputed) 然后在组件中定义asyncComputed字段: ... asyncComputed:{ hero: async function(){ if (this.id) { let heroId = Number(this.id); let response = await this.$axios.get(`/hero/${heroId}`); return response.data.result; } } } ... 这种方式不推荐使用,读者感兴趣可以自行实现试试效果. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-17 21:28:12 "},"web前端技术/Vue/优化项目.html":{"url":"web前端技术/Vue/优化项目.html","title":"优化项目","keywords":"","body":"优化项目 本部分是对vue.js基础用法的优化补完,对应代码在optimization分支. 我们的英雄手册项目已经能满足所有功能了,但交互体验上还有一些瑕疵.我们可以利用一些小技巧和html5的一些技术掩盖这些缺陷提高交互体验. 本文也是这部分的最后一篇文章,接下来我们会进入PWA应用阶段,进一步将我们的网页改造成PWA应用. App.vue细节优化 功能决定一个产品能不能进入市场,细节决定了一个产品在市场上的生存状况.网页的细节很多时候就体现在交互的连贯性上. 这部分主要就是在交互的连贯性上做文章. router切换点击优化 我们的router组件可以工作,但很容易出现点击后没有反应的情况,这是因为我们为了演示如何用vue-router将router-view放在了el-menu-item内部,我们必须点到这个标签才会跳转. 实际上el-menu已经实现了和router-view的继承,只需要将el-menu的router属性点亮并且将el-menu-item的index改为路由的路径,即可. ... 仪表盘 英雄列表 创建英雄 ... 这样修改后点击行为就可以得到优化了. 另一个瑕疵是当我们选中某个路径后刷新,页面会刷新--导航栏会回到初始状态,但router-view中的内容不会改变.这就会很奇怪了,一个比较简单的方式是利用html5的sessionStorage将当前的页面路由缓存下来.sessionStorage只对浏览器当前页面有效,多开多个浏览器页面不会相互影响,并且它会在页面关闭时删除,这就非常适合现在这个场景了. 我们需要定义一个memu.js的vuex对象.它用于管理这个缓存. const state = { current_index: \"/\" } // getters const getters = { } // actions 定义业务逻辑 const actions = { changeCurrrentIndex: function (context, payload) { sessionStorage.setItem(\"current_index\", payload.current_index) }, loadCurrrentIndex: function (context) { let current_index = sessionStorage.getItem(\"current_index\") if (current_index) { console.log(`load index from storage: ${current_index}`) let payload = { current_index } context.commit('changeCurrrentIndex', payload) } else { console.log(\"no index in storage\") } } } // mutations 定义数据状态的操作 const mutations = { changeCurrrentIndex(state, payload) { let current_index = payload.current_index state.current_index = current_index console.log(`load current_index ${current_index}`) } } export default { namespaced: true, state, getters, actions, mutations } 可以看到其中定义了两个方法: changeCurrrentIndex当页面跳转到index对应路径时调用,用于缓存页面数据,这个可以通过为el-menu的select事件绑定回调函数实现 loadCurrrentIndexapp节点创建时调用,将缓存下来的index信息加载到current_index router切换过渡效果 目前我们点击导航切换view比较生硬,我们可以通过vue自带的过渡动画标签transition来为router-view部分的加载提供过渡效果. transition实际上我们还是使用的css的过渡效果定义.因此我们需要定义css部分. 最终我们的App.vue修改为了: 英雄指南 仪表盘 英雄列表 创建英雄 export default { name: \"app\", data() { return { activeIndex: \"/\" }; }, methods: { changeIndex: function(index, indexPath) { console.log(index); this.$store.dispatch(\"menu/changeCurrrentIndex\", { current_index: index }); } }, created: function() { this.$store.dispatch(\"menu/loadCurrrentIndex\"); this.$store.dispatch(\"herolist/syncHeros\"); console.log(`app create ${this.$store.state.menu.current_index}`); this.activeIndex = this.$store.state.menu.current_index; } }; #app { font-family: \"Avenir\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } .slide-enter-active, .slide-leave-active { transition: opacity 0.5s; } .slide-enter, .slide-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; } detail.vue细节优化 detai.vue组件是我们主要用于和用户交互的组件,其他更多的是展示,这块也是最需要优化的部分. 由于有表单要填而表单实际上是最容易体验差的部分,想象下有很多机构的官方网站,你要申请一个什么东西,他们就会给你一个表单让你填. 然后悲剧的是如果中途你有事就退出去了或者因为网络问题死活提交不上去,下次回来你就得从头再填一遍,往往这种表单还特别长,这就会体验很差甚至还不如去线下处理. 另一个点是处理网络连接.我们无法保证网络的稳定性和可用性,这是网络自身的特点.因此像详情页这样需要现从网络上获取数据的页面就会很不好处理,用户需要知道页面是否准备好了. 因此我们就需要有一个加载动画来告诉用户页面有没准备好. 等待加载动画 element提供了Loading模块可以用于提供一个等待画面. 这个模块提供一个vue指令v-loading用于掩盖组件和其子组件,并提供了修饰符来定义掩盖的范围和特点.它支持的修饰符有: 参数 说明 类型 可选值 默认值 target 需要覆盖的DOM节点.可传入一个DOM对象或字符串;若传入字符串则会将其作为参数传入document.querySelector以获取到对应DOM节点. object/string --- document.body body 以使遮罩插入至DOM中的body上 boolean --- false fullscreen 全屏遮罩 boolean --- true lock 锁定屏幕的滚动 boolean --- false 而其值必须是一个布尔值,true表示显示加载动画,否则不展示 我们使用它默认的转圈圈样式简单展示下. ... ... export default { ... computed: { ... show: function() { if (this.id && !this.hero.name && Object.keys(this.hero.quality).length === 0) { return true; } else { return false; } }, ... } 缓存已经生成但未提交的英雄 我们希望生成英雄的缓存是无感的,那我们就需要启动一个监听器来一直监听hero对象的变化情况然后根据其变化情况做缓存,而在组件创建时(即利用钩子created)我们需要根据是否有id来判别是不是创建页.也就可以判别需不需要加载缓存的已生成未提交的英雄.这个页面中我们没有将这个存储逻辑放在vuex中处理, 是因为这个业务的缓存数据怎么也不会有别的组件需要知道.而App.vue中则有可能会有一些子组件需要知道当前所在的index信息. 此处的实现我们依然使用的是sessionStorage,这也就意味着如果退出页面,这个缓存就会消失,如果想实现退出页面也不会消失可以改用localStorage接口是一致的. 最终我们的herodetail.vue这样: 英雄详情 名字： 提交 后退 名字： 随机生成 提交 英雄属性 import { mapActions } from \"vuex\"; import { random100 } from \"../utils\"; export default { name: \"herodetail\", data: function() { return { hero: { name: \"\", quality: {} } }; }, props: { id: { type: String, default: null } }, computed: { show: function() { if (this.id && !this.hero.name && Object.keys(this.hero.quality).length === 0) { return true; } else { return false; } }, has_quality: function() { if (Object.keys(this.hero.quality).length !== 0) { return true; } else { return false; } }, chartData: function() { let data = { columns: [\"name\", ...Object.keys(this.hero.quality)], rows: [{ name: this.hero.name, ...this.hero.quality }] }; return data; } }, methods: { ...mapActions(\"herolist\", [\"appendHero\", \"updateHero\"]), afterconfig: function(option) { option.radar.indicator.forEach(i => (i.max = 100)); return option; }, submitHero: function() { if (this.id) { let hero = { ...this.hero }; this.updateHero({ heroId: Number(this.id), source: hero }); this.hero = Object.assign(this.hero, hero); } else { let hero = { ...this.hero }; this.appendHero({ heroObj: hero }); this.hero.name = \"\"; this.hero.quality = {}; } goBack() }, randomHeroQuality: function() { this.hero.quality = { 速度: random100(), 成长性: random100(), 持久力: random100(), 破坏力: random100(), 精密度: random100(), 射程距离: random100() }; }, setCreatedHero: function(newVal, oldValVal) { if (newVal.name !== \"\" || Object.keys(newVal.quality).length !== 0) { if (this.id) { } else { sessionStorage.setItem(\"created_hero\", JSON.stringify(newVal)); } } }, goBack: function() { window.history.length > 1 ? this.$router.go(-1) : this.$router.push(\"/\"); } }, watch: { id: function(newVal, oldVal) { if (newVal === null) { this.hero = { name: \"\", quality: {} }; } }, hero: { handler: \"setCreatedHero\", deep: true, immediate: true } }, created: function() { if (this.id) { let heroId = Number(this.id); this.createdPromise = this.$axios.get(`/hero/${heroId}`); } else { let created_hero = sessionStorage.getItem(\"created_hero\"); if (created_hero){ this.hero = JSON.parse(created_hero); } else { } } }, mounted: async function() { if (this.id) { let heroId = Number(this.id); let response = await this.createdPromise; this.hero = response.data.result; } } }; 提交后返回 在用户提交好修改或者新增后,用户在这个页面上的工作就已经结束了,我们应该自动退出这个详情页.这边我们在submit的回调函数种复用goBack即可 利用sse优化数据流 另外两个页面其实都是拿我们向服务器请求来的英雄列表信息进行的展示.他们都会使用钩子created在每次进入页面时拉取更新这个数据. 这确实可以在大多数情况下满足需求,但其实并不好--每次拉取的都是当时的全量数据,在数据量很大数据增量很大的情况下就很难满足需求了.有什么办法呢? 当然我们可以使用websocket,但这就需要服务端大改,并不能平顺的迁移,而我们只是要一个轻量级的推送功能而已.这种时候就可以使用sse技术了.这个技术在除微软家浏览器外的浏览器上都可以正常工作. 为了提高兼容性,我们肯定还是会保留原来的逻辑,但会为使用新技术的用户提供更好的体验.我们修改我们的api服务器,在其中新增返回流的部分,并且这个流在第一次连接的时候会返回当前的全量数据, 之后的每次推送则是提供对现有这份全量数据的修改事件数据,以保持和服务端的实时同步; 而服务端我们提交的所有修改操作,包括创建,更新,删除,这些除了入库写入数据库外,也会返送一份消息到redis的pub/sub模式. 在服务端的流部分,我们监听这个channel,一旦有新的事件数据,我们的流就会将其发送给客户端. 在客户端我们只需要读入流,监听好其中的事件并响应的操作数据即可.我们定义同步用的action: syncHerosBySSE(context){ function initEventSource(url = \"http://localhost:5000/stream\") { let evtSource = new EventSource(url, { withCredentials: true }) evtSource.onmessage = function (e) { let { status, result } = JSON.parse(e.data) switch (status) { case 200: { context.commit('syncHeros', { heros: result }) } break; case 100: { let { event, hero } = result switch (event) { case \"create\": { context.commit('appendHero', { heroObj: hero }) } break; case \"update\": { context.commit('updateHero', { heroId: hero.id, source: { name: hero.name } }) } break; case \"delete\": { context.commit('deleteHero', { heroId: hero.id }) } break; default: { console.log(`unknown event ${event}`) } break; } } break; default: { console.log(`unknown code ${status}`) } break; } } evtSource.onerror = function (e) { if (e.readyState == EventSource.CLOSED) { console.log(\"Connection lost. reconnect...\") evtSource.close(); initEventSource() } else{ console.log('error', e); evtSource.close(); } } evtSource.onopen = function (e) { console.log('sse reconnected', e); } } initEventSource() }, 这个函数只需要在App节点创建时启动一次即可,我们将其挂在App.vue的created方法上. 由于这个方法必须要浏览器支持SSE,所以先要有个判断: created: function() { ... if (window.EventSource){ this.$store.dispatch(\"herolist/syncHerosBySSE\"); }else{ console.log(\"browser not support sse, use api\") this.$store.dispatch(\"herolist/syncHeros\"); } ... } 其他的两个组件Dashboard.vue和Herolist.vue我们也需要同样处理下调用this.$store.dispatch(\"herolist/syncHeros\")的逻辑. 总结 至此,我们的英雄指南项目第一阶段已经告一段落了.这一部分,我们完成了一个基于vue.js的完整的前端项目,从组件到数据再到路由;从完成功能到优化交互体验,再到使用SSE提高数据传输效率. 真实一段漫长的旅程.但现在离结束还远,这才只是基于vue的客户端项目的开端,在接下来的部分我们将进一步优化我们的英雄指南项目,使其称为一个pwa网站. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-17 21:28:12 "},"使用Javascript搭建后端服务/":{"url":"使用Javascript搭建后端服务/","title":"使用Javascript搭建后端服务","keywords":"","body":"使用Javascript搭建后端服务 通常后端服务埋得越深越不会选择使用js来构建,但现在微服务架构盛行,js也凭借其纯异步支持高并发和开发调试简单的特点成了后端服务的可选项之一. 通常js在后端的角色更多的是: 微服务架构中作为组件提供接口 作为连接前端的APIgateway根据业务需要聚合后端接口 而常见的技术主要是: 基于HTTP的RESTful接口服务 基于Websocket的长连接服务 GRpc提供的接口服务 而后端相关的技术有: 关系数据库技术,常见的有PostgreSQL,业务上一般使用orm来操作数据库.常用的orm有sequelize配合pg和pg-hstore使用 共享内存技术,常见的是Redis,我们使用node-redis配合bluebird 消息队列技术,常见的有rabbitMQ,我们使用rabbit.js 消息的发布订阅工具,常见的有Redis,rabbitMQ,postgreSQL zmq一种基于通信模式的消息组件框架 webrtc一种在浏览器端也有实现的p2p即时通信技术 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"使用Javascript搭建后端服务/http接口服务.html":{"url":"使用Javascript搭建后端服务/http接口服务.html","title":"http接口服务","keywords":"","body":"使用Javascript构建http接口服务 js有很多优秀的http服务框架,目前最受我个人喜爱的是koa.这个框架非常轻量,要正常使用几乎必须使用插件.先来一个helloworld这个例子没有方法判断,没有路由,没有权限控制,什么都没有只是给出一个最最基础的http服务而已. import Koa from 'koa' const app = new Koa() app.use(async ctx => { ctx.response.type='application/json' ctx.body = JSON.stringify({ 'message': 'Hello World' }) }) app.listen(3000) http协议是本文的基础,不知道http协议或者想对其了解更加深刻的可以去看看图解HTTP. koa的原理 koa的调用结构类似洋葱,请求会封装成请求响应的上下文对象会一层一层的传递给下一层的异步函数,直到最后一层处理完再原路一层一层的返回去,再在终点时拆成响应传递出去提供服务. 请求响应的上下文对象 这个对象的具体接口可以查看koa的官网,内容很少这边也不再重复,最基本的就是其中 ctx.request是一次http的请求对象 ctx.response是与ctx.request对应的http的响应对象 我们要做的就是根据ctx.request构造ctx.response. ctx也提供了几个特殊对象方便我们构造响应. ctx.app对象,即这个服务本身的app对象,这样我们就可以像app对象上挂各种有必要的东西这为服务构造提供了灵活性 ctx.cookies,可以获取或设置cookie,使用get和set方法 ctx.throw([status], [msg], [properties]),抛出http异常,直接中断后续的异步函数操作构造错误响应并传回去 另外由于每次写上response或者request太长了,ctx中也提供了一些快速访问特定字段的快捷方式: Response: 对象 可访问性 说明 ctx.body 读写 响应的body体 ctx.status 读写 响应的状态码 ctx.message 读写 响应的状态消息,通常与响应状态码有关 ctx.length 读写 Content-Length设置,类型为int ctx.type 读写 Content-Type设置,具体的可以看MDN上的介绍 ctx.headerSent 只读 用于检查是否已经发送了一个响应头,用于查看客户端是否可能会收到错误通知 ctx.lastModified 只写 将Last-Modified标头设置为适当的UTC字符串,常使用new Date() ctx.etag 只写 设置包含\"包裹的ETag响应,常见用法ctx.etag = crypto.createHash('md5').update(ctx.body).digest('hex') ctx.redirect(url, [alt]) 方法 执行[302]重定向到url.字符串\"back\"是特别提供Referrer支持的,当Referrer不存在时,使用alt或\"/\" ctx.attachment([filename]) 方法 将Content-Disposition设置为\"附件\"以指示客户端提示下载.(可选)指定下载的filename ctx.set(field,value) 方法 设置响应标头field到value ctx.append(field,value) 方法 用值val附加额外的标头field ctx.remove(field) 方法 删除标头field Request: 对象 可访问性 说明 ctx.header/ctx.headers 只读 请求头 ctx.method 读写 请求的http方法 ctx.url 读写 请求的url路径 ctx.originalUrl 只读 获取请求原始URL ctx.origin 只读 获取URL的来源,包括 protocol 和 host ctx.href 只读 获取完整的请求URL,包括 protocol,host 和 url ctx.path 读写 获取请求路径名 ctx.query 读写 获取解析的查询字符串,当没有查询字符串时返回一个空对象. ctx.querystring 读写 根据?获取原始查询字符串 ctx.host 只读 获取请求的host(hostname:port) ctx.hostname 只读 获取请求的hostname ctx.fresh 只读 检查请求缓存是否\"新鲜\",也就是内容没有改变.此方法用于If-None-Match/ETag,和If-Modified-Since和Last-Modified之间的缓存协商.在设置一个或多个这些响应头后应该引用它. ctx.stale 只读 与ctx.fresh相反 ctx.socket 只读 请求套接字 ctx.protocol 只读 返回请求协议即'https'或'http'。当app.proxy是true时支持X-Forwarded-Proto ctx.secure 只读 通过ctx.protocol == \"https\"来检查请求是否通过TLS发出 ctx.ip 只读 请求远程地址.当app.proxy是true时支持X-Forwarded-Proto ctx.ips 只读 当X-Forwarded-For存在并且app.proxy被启用时,这些ips的数组会被按从上游到下游的排序返回.禁用时返回一个空数组. ctx.subdomains 只读 将子域返回为数组 ctx.is(types...) 方法 检查传入请求是否包含Content-Type头字段,并且包含任意的mime type.如果没有请求主体返回null.如果没有内容类型或者匹配失败则返回false.反之则返回匹配的content-type ctx.accepts(types) 方法 检查给定的type(s)是否可以接受 ctx.acceptsEncodings(encodings) 方法 检查encodings是否可以接受 ctx.acceptsCharsets(charsets) 方法 检查charsets是否可以接受 ctx.acceptsLanguages(langs) 方法 检查langs是否可以接受 ctx.get(field) 方法 返回请求头中对应field的值 插件 这个框架过于轻量以至于几乎无法在稍微复杂的环境下单独使用.要用它必须依赖插件. 自己写个插件 我们的第二个例子C1就是一个自己写的插件,这个插件实现一个没什么用的功能--给所有的response的json体内加上author:hsz. 插件和业务逻辑都是使用app.use()来调用,但不太一样的是插件是一个包含ctx和next两个参数的协程函数,而await next()则是进入下一层的标志,在其上的是处理请求,在其下的是处理响应. 这个就有点像python中使用contextlib.contextmanager写上下文管理器. 使用插件 和业务逻辑一样,插件也是使用app.use()来使用.只是需要注意使用的顺序,即先use的在外层,后use的在内层.这个在例子C1中也有体现 常见插件 但是总不能啥都自己写插件实现,实际上现在已经有不少靠谱的插件可以现成的使用了 koa-route一个用来实现路由的优质插件,它不光可以管到路由,还可以管到http方法.我们的RESTful接口核心插件就是它了. koa-compose将多个中间件合成一个,配合上面的koa-route,我们可以将路由模块整个打包成一个插件. koa-compress用于使用zlib压缩请求体 koa-body用于将body体解析为更易懂的形式,比如json这类 koa-jwtjwt认证 koa-pino-logger一个机遇pino的logger,默认的log形式为json更容易被elasticsearch解析 koa2-cors服务端解决跨域问题 koa-sse-stream,一个用于构造sse的插件. 关于跨域 关于跨域的问题我写在前端部分,有兴趣的可以看下. 一个完整例子 我们用例子C2来封装一个服务资源--Notification. 这个Notification包含如下字段: { \"id\":int,//事件id \"creater_id\":int,//创建者id \"create_time\":DATETIME,//创建时间 \"notify_time\":DATETIME,//提醒时间 \"notify_uid\":JSON,//要提醒的目标用户 \"message\":string,//提醒内容 \"status\":ENUM('Pendding', 'Canceled','Done','Error'),//状态 \"status_log\":JSON//状态转化的log信息,其结构为`[{from:xxx,to:xxx,at:xxx,msg:xxx},...]` } 同时会为每个创建了的Notification创建一个定时任务的promise,这个任务将会向一个redis的目标用户uid为名的channel发出一个发布订阅的发布请求. 而我们的/stream/:uid将会监听redis的uid对应的channel以推送提醒. 这个例子实际上是3个资源加一个sse推送流 main,也就是存放Notification和相关资源的容器 NotificationList,管理所有Notification实例的容器 Notification,管理单个Notification实例 stream,管理流数据的推送. 这个例子中使用到了最常用的几个插件,实际上只是将数据库中的数据做了下封装. 这个项目使用的mvc模式设计,因为对于接口来说view层实际上就是json的样式,所以主干在如下两个文件夹 controller管理资源和路由 module管理数据库连接和表设计 剩下的是一些辅助工具: cmd.js管理命令行解析 config.js管理配置文件和默认配置 app.js用于生成app实例 pubsub.js用于管理redis的发布订阅 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-17 21:31:24 "},"使用Javascript搭建后端服务/Websocket接口服务.html":{"url":"使用Javascript搭建后端服务/Websocket接口服务.html","title":"Websocket接口服务","keywords":"","body":"使用Javascript构建Websocket接口服务 js可以使用ws这个框架来实现websocket接口的构造.接口文档 我们依然从一个helloworld开始.这个例子我们在客户端连同服务端后立即发送一个helloworld消息给后端服务器,服务器接到后则返回一个helloworld消息给客户端.客户端在接收到服务器消息后发送一个close消息给服务器,服务器就断开和客户端的连接. 客户端 const ws = new WebSocket('ws://localhost:3000') ws.on('open', () => { ws.send('helloworld') }) ws.on('message', (data) => { console.log(data) assert.equal(data, 'Hello World') ws.close() }) ws.on('close', () => { console.log('disconnected'); }) 服务器 import WebSocket from 'ws' const wsserver = new WebSocket.Server({ port: 3000 }) wsserver.on('connection', ws => { ws.on('message', message => { console.log('received: %s', message) switch (message) { case \"close\": { ws.close() } break case \"helloworld\": { ws.send('Hello World') } break default: { ws.send('unkonwn command') } } }) }) websocket的连接原理 首先明确下几个概念: WebSocket是一个双工通信协议.意味着一旦建立连接它可以从一端向另一端推送数据 WebSocket协议是一个和html同一级别的协议(第七层),归属于IETF WebSocket API是一个Web API,归属于W3C 广义上讲WebSocket API包含于HTML5,我们知道html协议是特性集合,它的每一项特性都是独自实现的,它本身只是一个集合概念. websocket最终建立的是tcp连接,它只是通过http进行握手. TCP(socket)管的是第四层协议,websocket是第七层,这意味着websocket做好了分包组包(会话层)和编码解码(表示层)的协议.所以接口会更友好,但也就无法针对特定业务优化这些协议的性能(话又说回来自己做的会话层和表示层未必有现成的性能好,更不要说通用性了). 我们知道websocket是借助http协议进行握手,之后再提升进行连接的,其原理具体是这样: 客户端带着型如下面的形式的http头请求http服务器 GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com 主要起作用的就是Upgrade: websocket和Connection: Upgrade,它通知服务端需要使用websocket协议 Sec-WebSocket-Key是一个浏览器随机生成的Base64 encode的值,通知服务器并验证是不是真的是Websocket服务. Sec_WebSocket-Protocol是一个用户定义的字符串,用来区分同URL下不同的服务所需要的协议. Sec-WebSocket-Version是告诉服务器所使用的Websocket Draft(协议版本),这个是个历史遗留问题,只是为了解决各家浏览器实现上的不统一,现在直接填13即可. 服务端返回一个型如下面的response通知客户端即将升级为websocket协议 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat 其中 Sec-WebSocket-Accept是经过服务器加密过后的Sec-WebSocket-Key 这步结束后http握手部分即结束 再上面的握手成功后客户端和服务器会建立TCP连接,后续就可以进行TCP通讯了 需要注意这个lib的接口和Websocket API的并不一致.比如onmessage中的回调函数参数为获取的数据而非一个messageEvent. 传递二进制数据 ws即然是一个双工通信协议,那他自然支持流数据的推送. 这主要是靠send接口,send支持的数据类型包括 USVString 文本字符串.字符串将以UTF-8格式添加到缓冲区,并且bufferedAmount将加上该字符串以UTF-8格式编码时的字节数的值. ArrayBuffer 可以使用一有类型的数组对象发送底层二进制数据;其二进制数据内存将被缓存于缓冲区,bufferedAmount将加上所需字节数的值. Blob Blob类型将队列blob中的原始数据以二进制中传输.bufferedAmount将加上原始数据的字节数的值. ArrayBufferView 可以以二进制帧的形式发送任何JavaScript类数组对象;其二进制数据内容将被队列于缓冲区中.值bufferedAmount将加上必要字节数的值. 这边的例子C1以ArrayBuffer为例演示了传递二进制数据的方式,其中主要的注意点是: 客户端需要指明ws.binaryType = \"arraybuffer\"或ws.binaryType = \"blob\" 如果是arraybuffer需要在客户端按它的类型转换下data = new Float32Array(data) 实现广播 另一个常见的应用是广播,即服务端向全体用户发送同样的消息.这个可以借助ws.clients来实现,它是一个维护全体客户端连接的set. 这个例子C2会向全体客户端发送一个welcome+客户的名字的消息,这个例子我们会将数据已json的形式传递,已其中的event字段来判断触发的事件 服务端 ```js import WebSocket from 'ws' const wsserver = new WebSocket.Server({ port: 3000 }) wsserver.broadcast = (data) => { wsserver.clients.forEach((client) => { if (client.readyState === WebSocket.OPEN) { client.send(data) } }) } wsserver.on('connection', ws => { ws.on('message', message => { console.log('received: %s', message) //----这段以下是判断是否符合格式规范 let data = null try { data = JSON.parse(message) } catch (error) { ws.send('message is not json') return } if (!data || !data.event) { ws.send('no event') return } //----这段以上是判断是否符合格式规范 switch (data.event) { case \"close\": { ws.close() } break case \"helloworld\": { console.log(data.message) wsserver.broadcast(JSON.stringify({ event: \"helloworld\", message: `helloworld ${data.message}` })) } break default: { ws.send('unkonwn command') } } }) }) ``` 我们可以为wsserver封装一个方法`broadcast`用于做广播,这个方法只是遍历所有客户端连接,只要状态是`open`我们就向他发送消息. 客户端 const ws = new WebSocket('ws://localhost:3000') ws.binaryType = \"arraybuffer\" ws.on('open', () => { ws.send(JSON.stringify({ event: 'helloworld', message: 'hsz' })) }) ws.on('message', (message) => { let data = null try{ data = JSON.parse(message) }catch(error){ ws.send('message is not json') return } if (!data || !data.event){ ws.send('no event') return } switch (data.event) { case \"close\": { ws.close() } break case \"helloworld\": { console.log(data.message) assert.equal(data.message, \"helloworld hsz\") ws.close() } break default: { ws.send('unkonwn command') } } }) ws.on('close', () => { console.log('disconnected'); }) 广播排除发件人 很多时候广播是由客户端发起希望发给处掉自己外的其他人,那我们就还得再做一些处理 下面的例子C3展示了如何实现这个功能. 我们在C2的基础上为ws封装一个publish方法,它会排除掉自己向其他一个server的用户发送消息. 实现推送 很多时候我们需要的不光是请求响应,作为一个双工通信的协议,我们也需要可以向客户端推送数据. C4是一个简单的推送任务,它会每隔10s向全体广播一次当前时间. 这个例子使用了setInterval做周期性的推动,当然了更常见的是监听一个redis或者其他中间件,如果有消息传过来就推送.这个可以留着自己研究下. 路径 我们常见的websocket连接通常不会是一个光秃秃host,而是会根据http路径区分功能.这个当然可以通过nginx来解决,但如果我们希望直接一个服务解决那该如何操作呢? 我们就需要结合http服务模块来做了.例子C5 服务端 import WebSocket from 'ws' import http from 'http' import url from 'url' const server = http.createServer() const wss1 = new WebSocket.Server({ noServer: true }) const wss2 = new WebSocket.Server({ noServer: true }) wss1.on('connection', ws => { ws.on('message', message => { console.log('received: %s', message) switch (message) { case \"close\": { ws.close() } break case \"helloworld\": { ws.send('Hello World') } break default: { ws.send('unkonwn command') } } }) }) wss2.on('connection', ws => { ws.on('message', message => { console.log('received: %s', message) switch (message) { case \"close\": { ws.close() } break case \"helloworld\": { ws.send('Hello World') } break default: { ws.send('unkonwn command') } } }) }) server.on('upgrade', (request, socket, head) => { const pathname = url.parse(request.url).pathname console.log(pathname) if (pathname === '/room1') { wss1.handleUpgrade(request, socket, head, ws =>{ wss1.emit('connection', ws, request) console.log(\"emit room1\") }) } else if (pathname === '/room2') { wss2.handleUpgrade(request, socket, head, ws => { wss2.emit('connection', ws, request) console.log(\"emit room2\") }) } else { socket.destroy() console.log(\"destory socket\") } }); server.listen(3000) 用户管理 用户管理有两种思路 一种是借助http服务器动态的创建wsserver,比如channel,一个channel就是一个单位,在其中只有广播.这种方式好处是简单,不需要了解细颗粒度的信息. 一种是使用中介模式,通过一张map来映射用户和用户的socket,在用户首次登陆时需要附带用户的辨识信息.当用户退出时这张map也要删除对应的用户socket.这样用户就可以指定单独的某个用户来实现互发消息了,同时广播也可以指定用户. 借助http服务器动态的创建wsserver 例子C6演示了如何创建动态的wsserver. 为了保持回调函数不要太长,我们可以将回调函数定义在外面,然后通过闭包在每个wss和ws中绑定. const onMessage = wws => ws => message => { console.log('received: %s', message) ... } ... wss = new WebSocket.Server({ noServer: true }) wss.cid = channel_id wss.on('connection', ws => { ws.publish = message => { wss.clients.forEach(client => { if (client !== ws && client.readyState === WebSocket.OPEN) { client.send(message) console.log(`send message ${message}`) }else{ console.log(`client status ${client.readyState}`) } }) } ws.on('message', onMessage(wss)(ws)) }) 我们创建了一个全局的Map--CHANNELS用于管理维护所有的频道,并使用一个定时任务每5分钟清理一次没有客户连接的频道 使用中介模式 使用中介模式我们一样是用一个Map集合client,这样要使用时只要用client的名字来查找即可. C7是一个简易的聊天室应用.我们可以通过event:client_list获取当前有哪些用户,然后根据这个指定用户去通过`event:talk_with来发送消息. 这个例子需要有一套用户系统,这边做了相当的简化. 只有用户名 验证的token只是token的base64转码 用户完全没有服务端的保存,只是做个用户名的去重而已 在服务端使用一个Map的常量CLIENTS来管理所有的用户名,ws对,在验证用户和用户退出时会对这个map做增删. 这个例子的流程是: 建立连接后客户端向服务端发起验证请求 服务端处理验证请求后创建一个token发回给客户端 客户端收到token后发起查询用户列表的操作,服务端将当前的用户名列表发送回去给客户端 客户端收到用户列表后发起talk事件,代上消息给服务端,客户端发送talk事件的消息会根据用户列表的长度来判断,如果长度>3,那么使用一个随机数判断要通过字段with_cilents发给第一个人还是第二个人,否则就不带字段with_cilents 服务端收到talk事件后如果没有字段with_cilents则发起广播,否则查找with_cilents列表中的用户发送 客户端 ```js import faker from 'faker' import WebSocket from 'ws' const ws = new WebSocket('ws://localhost:3000/channel?id=1') const self = faker.fake(\"\") let token = null console.log(`I'm ${self}`) ws.on('open', () => { ws.send(JSON.stringify({ event: 'auth', message: 'auth', user: self })) }) ws.on('message', (message) => { let data = null try { data = JSON.parse(message) } catch (error) { ws.send(JSON.stringify({ event: \"error\", message: 'message is not json' })) return } if (!data || !data.event) { ws.send(JSON.stringify({ event: \"error\", message: 'no event' })) return } switch (data.event) { case \"close\": { ws.close() } break case \"user_list\": { if (data.message.length > 2) { console.log(\"get user list:\") console.log(data.message) let chosen = data.message[Math.random() >= 0.5 ? 1 : 2] console.log(`chosen ${chosen}`) ws.send(JSON.stringify({ event: \"talk_with\", auth: token, with_cilents: [chosen], message: `hello ${chosen},I'm ${self}` })) console.log(`send message to ${chosen}`) } else { ws.send(JSON.stringify({ event: \"talk_with\", auth: token, message: `hello all,I'm ${self}` })) } } break case \"message\": { console.log(`get message: ${data.message}`) } break case \"error\": { console.log(`error:${data.message}`) } break case \"token\": { token = data.message ws.send(JSON.stringify({ event: \"user_list\", auth: token })) } break default: { ws.send(JSON.stringify({ event: \"error\", message: 'unkonwn command' })) } } }) ws.on('close', () => { console.log('disconnected'); }) ``` 服务端 import WebSocket from 'ws' const wss = new WebSocket.Server({ port: 3000 }) let CLIENTS = new Map() const onClose = wws => ws => () => { if (CLIENTS.has(ws.user)) { CLIENTS.delete(ws.user) } } const btoa = message=>Buffer.from(message).toString('base64') const atob=message=>Buffer.from(message, 'base64').toString() const onMessage = wws => ws => message => { console.log('received: %s', message) let data = null try { data = JSON.parse(message) } catch (error) { ws.send(JSON.stringify({ event: \"error\", message: 'message is not json' })) return } if (!data || !data.event) { ws.send(JSON.stringify({ event: \"error\", message: 'no event' })) return } switch (data.event) { case \"close\": { ws.close() if (CLIENTS.has(ws.user)) { CLIENTS.delete(ws.user) } } break case \"auth\": { if (!data.user) { ws.send(JSON.stringify({ event: \"error\", message: 'auth error,no user' })) ws.close() } else { if (CLIENTS.has(data.user)){ ws.send(JSON.stringify({ event: \"error\", message: 'auth error,user name already exist' })) ws.close() }else{ ws.user = data.user CLIENTS.set(data.user, ws) ws.send(JSON.stringify({ event: \"token\", message: btoa(data.user) })) } } } break case \"error\": { console.log(`error:${data.message}`) } break case \"user_list\": { if (!data.auth){ ws.send(JSON.stringify({ event: \"error\", message: 'auth error,no token' })) ws.close() }else{ if (!CLIENTS.has(atob(data.auth))){ ws.send(JSON.stringify({ event: \"error\", message: 'auth error,already closed' })) ws.close() } else{ ws.send(JSON.stringify({ event: \"user_list\", message: Array.from(CLIENTS.keys()) })) } } } break case \"talk_with\": { if (!data.auth){ ws.send(JSON.stringify({ event: \"error\", message: 'auth error,no token' })) ws.close() } else{ if (!CLIENTS.has(atob(data.auth))){ ws.send(JSON.stringify({ event: \"error\", message: 'auth error,already closed' })) ws.close() } else{ if (!data.with_cilents) { ws.publish(data.message) } else { ws.talk_with(data.with_cilents, data.message) } } } } break default: { ws.send(JSON.stringify({ event: \"error\", message: 'unkonwn command' })) } } } wss.on('connection', ws => { ws.talk_with = (with_cilents, message) => { with_cilents.forEach(client => { if (CLIENTS.has(client) && CLIENTS.get(client).readyState === WebSocket.OPEN) { CLIENTS.get(client).send(JSON.stringify({ event: \"message\", message: message })) console.log(`user ${ws.user} send message ${message}`) } else { console.log(`client status ${client.readyState}`) ws.send(JSON.stringify({ event: \"error\", message: `user ${ws.user} send to ${client} error` })) } }) } ws.publish = message => { wss.clients.forEach(client => { if (client !== ws && client.readyState === WebSocket.OPEN) { client.send(JSON.stringify({ event: \"message\", message: message })) console.log(`user ${ws.user} send message ${message}`) } else { console.log(`client status ${client.readyState}`) } }) } ws.on('message', onMessage(wss)(ws)) ws.on(\"close\", onClose(wss)(ws)) }) 当然了这两种管理用户的方式也是正交的,我们完全可以结合使用.如何结合有兴趣的可以自己尝试. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "},"使用Javascript搭建后端服务/GRpc接口服务.html":{"url":"使用Javascript搭建后端服务/GRpc接口服务.html","title":"GRpc接口服务","keywords":"","body":"GRpc接口服务 GRpc正如其名,是一种RPC.它实际上和RESTful接口在功能上是相近的,本质都是一种请求响应模式的服务.只是作为一个RPC,GRpc一般描述动作而非资源,并且它可以返回的不光是一个数据,而是一组流数据. GRpc是一种跨语言的Rpc,它建立在http2上使用protobuf作为结构化数据的序列化工具, 它有4种形式: 请求-响应 请求-流响应 流请求-响应 流请求-流响应 其基本使用方式是: 服务端与客户端开发者协商创建一个protobuf文件用于定义rpc的形式和方法名以及不同方法传输数据的schema 服务端实现protobuf文件中定义的方法 客户端调用protobuf文件中定义的方法 在js中我们需要使用包grpc和@grpc/proto-loader来实现上面的三个步骤 请求-响应 这个例子C0我们来实现一个简单的服务--输入一个数,输出这个数的平方 创建一个protobuf文件 创建protobuf文件的语法可以看protobuf的语法指南 我们将函数命名为Square,每次传传入的数据是一个double型的数,传回的也是一个double型的数. syntax = \"proto3\"; package squarerpc_service; service SquareService { rpc square (Message) returns (Message){} } message Message { double message = 1; } 服务端实现定义的方法 服务端通过使用protoLoader.loadSync来实现加载protobuf文件中package的功能.导入后通过grpc.loadPackageDefinition来将这个protobuf文件作为一个对象.然后为grpc的服务器创建一个实例 const server = new grpc.Server() 同时定义一个对象用于存放rpc中函数的实现,需要注意的是函数的实现只有两个参数: call请求对象,通过call.request获取请求的message callback一个用于返回结果的函数,其第一位参数是,第二位参数是返回结果的对象 需要注意请求和响应的结果都需要符合proto文件中定义的结构. 定义好后需要使用server.addService将protobuf文件中的定义与实现绑定 最后使用server.bind绑定host和grpc.ServerCredentials.createInsecure()创建出来的rpc实例.之后server.start()启动服务 import grpc from \"grpc\" import * as protoLoader from \"@grpc/proto-loader\" const PROTO_PATH = __dirname + \"/../schema/square_service.proto\" const HOST = \"0.0.0.0\" const PORT = 5000 const PackageDefintion = protoLoader.loadSync( PROTO_PATH, { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true } ) const rpc_proto = grpc.loadPackageDefinition(PackageDefintion).squarerpc_service const SquareService = { square(call,callback){ let result = call.request.message**2 callback(null,{ message: result }) } } const server = new grpc.Server() server.addService(rpc_proto.SquareService.service,SquareService) function main(){ server.bind(`${HOST}:${PORT}`, grpc.ServerCredentials.createInsecure()) console.log(`start @ ${HOST}:${PORT}`) server.start() } main() 客户端实现方式 客户端一样通过使用protoLoader.loadSync来实现加载protobuf文件中package的功能.导入后通过grpc.loadPackageDefinition来将这个protobuf文件作为一个对象 然后实例化一个客户端并使用bluebird将其Promise化. const clientcb = new rpc_proto.SquareService( host, grpc.credentials.createInsecure() ) const client = bluebird.promisifyAll(clientcb) 后面要调用这个客户端只需要在方法后面加上Async即可 import grpc from \"grpc\" import * as protoLoader from \"@grpc/proto-loader\" import * as bluebird from 'bluebird' const PROTO_PATH = __dirname + \"/../schema/square_service.proto\" const HOST = \"0.0.0.0\" const PORT = 5000 const PackageDefintion = protoLoader.loadSync( PROTO_PATH, { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true } ) const rpc_proto = grpc.loadPackageDefinition(PackageDefintion).squarerpc_service const clientcb = new rpc_proto.SquareService( `${HOST}:${PORT}`, grpc.credentials.createInsecure() ) const client = bluebird.promisifyAll(clientcb) async function main() { let result = await client.squareAsync({ message: 12.3 }) console.log(result.message) } main() 这个服务我们将其封如dockerimage中,方便其他文章使用. 请求-流响应 这种需求比较常见,有点类似,python中的range函数,它生成的是一个流而非一个数组,它会一次一条的按顺序将数据发送回请求的客户端. 这个例子C1实现了给出一个正整数,它会返回从0开始到它为止的每个整数的平方. 修改protobuf文件 响应流只需要在返回部分前面申明是流即可 ... service SquareService { rpc rangeSquare (Message) returns (stream Message){} } ... 修改服务端 服务端的不同之处在于不再需要callback参数,改为直接向在call中调用write方法写入流数据,再在最后结尾处使用end方法标明流结束 const SquareService = { rangeSquare(call) { let limit = call.request.message for (let i = 0; i 修改客户端 由于js的流处理基于event emitter,我们无法使用promise解决.这里我们只能老老实实的监听响应的结果. let call = clientcb.rangeSquare({ message: 12.3 }) call.on(\"data\",(message)=>{ console.log(message.message) }) call.on(\"end\",()=>{ console.log(\"stream end\") }) 流请求-响应 这种需求不是很多见,可能用的比较多的是收集一串数据后统一进行处理吧,流只是可以确保是同一个客户端发过来的而已. 这个例子C2实现了传过来一串数,之后返回他们的平方和 修改protobuf文件 响应流只需要在请求部分前面申明是流即可 ... service SquareService { rpc sumSquare (stream Message) returns (Message){} } ... 修改服务端 服务端的不同之处在于需要监听call的data和end事件,在data事件中我们收集数据,在end事件中我们收到事件结束的标志,调用收集到的数据进行处理,再使用参数callback向响应一样的返回. (call, callback)=>{ let container = [] call.on(\"data\", (message) => { console.log(`get ${message.message}`) container.push(message.message) }) call.on(\"end\", () => { console.log(\"stream end\") callback(null, { message: container.map(e => e ** 2).reduce((x, y) => x + y) }) }) } 修改客户端 客户端传输流比较特殊,需要先以一个以error, message为参数的回调函数作为参数创建一个可写的call对象,之后使用这个call对象的write方法写入流,然后在流结束时使用call的end方法结束流. let call = clientcb.sumSquare( (error, message) => console.log(`result: ${message.message}`) ) for (let i = 0; i 流请求-流响应 将上面两种方式结合起来,就是我们的第四种方式,请求为一个流,响应也是流.这两个流可以是相互交叉的也可以是请求完后再返回一个流.他们在写pb文件时是相同的写法 service SquareService { rpc streamrangeSquare (stream Message) returns (stream Message){} } 请求流完成后返回流 这个例子C3实现了传过来一串数,之后以流的形式返回这组数每个的平方. 修改服务端 streamrangeSquare(call) { let container = [] call.on(\"data\", (message) => { console.log(`get ${message.message}`) container.push(message.message) }) call.on(\"end\", () => { console.log(\"stream end\") for (let i of container) { call.write({ message: i ** 2 }) } call.end() }) } 修改客户端 let result = [] let call = clientcb.streamrangeSquare() call.on(\"data\", (message) => { console.log(`get message ${message.message}`) result.push(message.message) }) call.on(\"end\", () => { console.log(`stream end with result: ${result}`) }) for (let i = 0; i 请求的进行中就返回响应 这个例子C4实现了传过来一串数,每收到一个数就处理了进行返回. 修改服务端 streamrangeSquare(call) { call.on(\"data\", (message) => { console.log(`get ${message.message}`) call.write({ message: message.message ** 2 }) }) call.on(\"end\", () => { console.log(\"stream end\") call.end() }) } 两种方式的不同之处 这两种方式的不同之处只在于服务端的数据处理是在data事件还是在end事件时触发. grpc的坑 grpc的精度会在传递中有不一致的情况,比较建议使用字符串传递需要精确的数据(比如金融领域) 虽然看起来流请求-流响应的模式写起来和websocket很像,但他们有本质区别--grpc必须由客户端发起,而websocket不需要. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 23:10:24 "}}