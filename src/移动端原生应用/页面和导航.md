# 页面和导航

和标准的Vue单页应用不同,nativescript-vue的应用更加接近多页面应用,但开发的时候我们却更加接近单页应用的开发方式.其中有两个比较特殊的组件:

+ [Frame](https://nativescript-vue.org/en/docs/elements/components/frame/)标签,相当于使用浏览器时的一个窗口,它是页面的载体.nativescript允许一个应用中存在**至少一个**Frame.我们的应用是允许多个Frame同时出现在屏幕上的因此我们也常利用这一特性构造导航逻辑.`Frame`是允许嵌套的,这也就是说即便是使用多`Frame`模式我们也可以固定一个root Frame以达到代码形式上的一致.一般来说,在nativescript-vue中,要利用Frame组件导航,我们会需要为不同的Frame设置不同的`id`属性.他有如下事件可以监听

    + `layoutChanged`
    + `loaded`
    + `propertyChange`
    + `showingModally`
    + `shownModally`
    + `unloaded`

+ [Page](https://nativescript-vue.org/en/docs/elements/components/page/)标签,相当于一个web应用中的一个html文件.它必须作为一个Frame的子组件.一个Frame中可以包含多个Page组件,但需要注意Page并不能够直接并行显示.我们使用[Manual Routing](https://nativescript-vue.org/en/docs/routing/manual-routing/)方式在定义的多个page间进行跳转.它同样有如下事件可以监听

    + `layoutChanged`
    + `loaded`
    + `navigatedFrom`
    + `navigatedTo`
    + `navigatingFrom`
    + `navigatingTo`
    + `propertyChange`
    + `showingModally`
    + `shownModally`
    + `unloaded`

而其余的组件我们可以大致分类为:

+ 容器组件,用于组织其他组件
+ 导航组件,用于导航页面组织视图间的关系
+ 展示型组件,用于展示排版内容
+ 输入型组件,用于让用户输入信息
+ 提示型组件,用于提示用户并做出进一步反应
+ 功能型组件,一些特殊功能的组件.

本文将介绍容器组件和导航组件,同时结合这些组件介绍原生应用页面导航的一般组织形式.但在那之前,我们先来总体上介绍下页面的构成.

## 页面构成

一个Page组件默认由两部分组成

1. ActionBar
2. 主体部分

### ActionBar

actionbar指的是手机屏幕上部窄窄的一条空间,这个位置在人正常竖屏使用手机时属于在最显眼的位置但手指按起来需要够,因此注定是给高曝光但操作低频的功能使用的.因此这块空间通常是作为功能区使用的,比如bilibili首页上ActionBar提供了提醒页,游戏页面的入口以及一个搜索栏,贴吧则提供了直播,关注,推荐,热榜以及搜索页的入口.而在表现形式上actionbar毕竟地方小,因此多用图标而非文本进行展示,交互上也以点击为主,一般除非放了个搜索栏不会要输入.因此这块的核心基本可以认为就是找到一个好图标.

我们也可以在`<Page>`组件中通过设置`actionBarHidden=true`关闭ActionBar的展示

ActionBar一般用在**高曝光但操作低频的功能上**,以**点击操作为主**,主要**靠图标辨识功能**.设计的时候只要记住把重要但不高频的功能进入按钮放在这里并给他们找个合适的图标就行.

Nativescript-Vue中这块有专门的控件控制.分别是

+ [ActionBar](https://nativescript-vue.org/en/docs/elements/action-bar/action-bar/),这个组件是ActionBar部分的根组件,其中包含的子节点都会放在ActionBar中.它比较重要的属性有:
    + 提供了一个`title`属性,会在屏幕的左上角`NavigationButton`后面展示
+ [ActionItem](https://nativescript-vue.org/en/docs/elements/action-bar/action-item/),这个组件用来提供按钮.它比较重要的属性有:
    + 提供了`android.position`(enum: actionBar,popup,actionBarIfRoom)和`ios.position`(enum: left,right)属性用于设置展示位置,
    + 提供了`text`属性用于设置展示的文本,注意这个属性无法设置图标
    + 提供了`icon`属性用于设置图标.
+ [NavigationButton](https://nativescript-vue.org/en/docs/elements/action-bar/navigation-button/),这个组件是iOS后退按钮和Android导航按钮的通用抽象,位置固定在最左上角,基本没啥可扩展的,用法也基本固定为`<NavigationButton text="Go back" android.systemIcon="ic_menu_back" />`一般用的比较少,毕竟后退操作实现的方法太多了而这个位置是人第一个会注意到的位置,不好好利用过于可惜.

除了上面的专用组件.我们还可以单独使用如下组件,他们会覆盖`ActionBar`的`title`的位置:

+ [SearchBar](https://nativescript-vue.org/en/docs/elements/components/search-bar/),搜索框,挺常用
+ [Label](https://nativescript-vue.org/en/docs/elements/components/label/),标签,用来展示一些信息,有时候会用
+ [Button](https://nativescript-vue.org/en/docs/elements/components/button/),按钮,用来控制一些点击行为
+ [Image](https://nativescript-vue.org/en/docs/elements/components/image/),图片,地方小一般不会用,但确实可以放

我们也可以使用[StackLayout](https://nativescript-vue.org/en/docs/elements/layouts/stack-layout/)来组合上面几种组件替代单个组件.

### 主体部分

主体部分就是真正展示内容,实现业务逻辑的部分了.主体部分是展示和业务逻辑落地的部分,我们既然使用nativescript那自然是希望可以一次开发,ios和android出来的结果尽可能的一致了.要实现这一期望有两种思路:

1. 使用原生组件,然后根据不同的平台单独进行调整以达到基本统一
2. 使用跨平台统一风格的组件.在navite-script下就是使用[nativescript-community/ui-material](https://github.com/nativescript-community/ui-material-components)了.

我个人会比较推荐使用第二种思路,毕竟对于我这样的业余玩家来说并没有那种要设计多么出众的需求,只要简单大方省心就好,material这样一套现成的风格统一的组件就太省事了.

不过原生组件尤其是上面已经介绍的`Frame`,`Page`以及容器组件依然无可替代.

本文不会介绍主体部分用到的组件,这些内容将在接下来的文章中介绍.

### Material

[material](https://material.io)准确地讲是一套设计语言,它最重要的特点就是跨平台统一.可以将其理解为在设计这个概念之上的一层抽象,通过一些新增的概念和最佳实践以及与之对应的属性或对象将复杂的设计简化,以达到一种整体协调的设计语言.这一套概念和最佳实践就是Material Design,而其实现就是material components.

我们在[资源设置一文]中已经介绍过如何使用material design icons(mdi)了.这里则会介绍如何使用material components.

要使用material components我们需要针对不同的平台做一些额外设置.

#### 主题颜色

Material Design官方提到了在设计最主要的可以用于凸显应用主题特色的颜色有3类:

+ `Primary Color`即主色调,也就是应用中最广泛使用的色调,通常我们会选择饱和度高(400)的颜色比如青色色的`#3f51b5`.
    与之匹配的还有比它更深一些的阴影色`Primary Color Variant`以及在主色调上展示的前景的颜色(比如按钮上的文本)`On Primary Color`通常我们不需要额外设置`Primary Color Variant`和`On Primary Color`,默认的就很好
+ `Secondary Color`即辅助色调,其颜色应该与主色调保持相似,比如青色就可以选蓝色,但要在主色调的基础上加深(700)或者变浅(100),以上面青色为例,可以使用更深的`#1976d2`或者更浅的`#bbdefb`,辅助色主要起过度的作用,体现层次感.
+ `Accent Color`即强调色,其颜色一般和主色调明显不同,比如青色可以选红色作为强调色,但其饱和度应该介于主色调和变浅(500),比如`#e57373`

除此之外还有`Surface Color`即表面色调,它会在cards,sheets, menus这类组件上作为默认的背景色,与之对应的`On Surface Color`则是这些组件上文本这类前景的颜色.

需要注意的是在nativescript中主题颜色的应用在不同平台还是有区别的,使用Material只能做到风格大致相同不能做到一一对应.

本段落参考自博文<https://www.jianshu.com/p/4c1f6960e3cb>和<https://blog.csdn.net/googledevs/article/details/109567406>,更多可以参考[官方文档](https://material.io/design/color/the-color-system.html#color-usage-and-palettes).我们也可以使用[官方提供的选色工具和调色板](https://material.io/design/color/the-color-system.html#tools-for-picking-colors)确定这几个颜色

#### 元素高度

Material Design中规定了一个组件的高度(`elevation`)概念(或者说z轴或者图层可能更准确),它可以用于体现组件堆叠的层级,同时也限制了阴影的使用.计算方法是从一个组件的顶面到另一个组件的顶面.高度的大小可以暗示用户两个组件间的距离大小以及投影的深浅,范围`0~24`,单位像素
与之对应的是高度的动态补偿(`dynamicElevationOffset`)概念,它用于描述一个组件从其默认高度朝着目标高度所做的位移变化,单位像素.

关于`elevation`的详细设计说明可以参考<https://www.zcool.com.cn/article/ZNTEwNDgw.html>

#### 水波纹

水波纹特效(ripple)是Material Design中非常常用的一个动画设计,它会在点击时触发一个由内向外的环形扩散动画,这个动画可以非常清晰的表现点击行为

#### 在nativescript中应用material-components

在nativescript中使用material-components在不同平台上设置并不一致

##### android端的设置

1. 要使用`material-components`需要在项目的`App_resources/android/res/values/styles.xml`文件中将`Theme.AppCompat`全部替换为`Theme.MaterialComponents`
2. 要设置主题色调,需要在项目的`App_resources/android/res/values/styles.xml`中定义需要的颜色然后修改`App_resources/android/res/values/styles.xml`中的`LaunchScreenThemeBase`和`AppThemeBase`以应用这些颜色

    + `colors.xml`

    ```xml
    <resources>
        ...
        <color name="ns_primary">#3F51B5</color>
        ...
    </resources>
    ```

    + `styles.xml`

    ```xml
    <resources>
        ...
        <style name="LaunchScreenThemeBase" parent="Theme.MaterialComponents.Light.NoActionBar">
            ...
            <item name="colorPrimary">@color/ns_primary</item>
            ...
        </style>
        ...
        <style name="AppThemeBase" parent="Theme.MaterialComponents.Light.NoActionBar">
            ...
            <item name="colorPrimary">@color/ns_primary</item>
            ...
        </style>
    </resources>
    ```

    其中可以使用的属性可以参考上文介绍

##### ios端的设置

1. 要使用`material-components`需要在项目的`App_Resources/iOS/Podfile`文件(没有就创建)中添加`platform :ios, '10.0'`

2. 要设置主题色调,则需要在入口文件`app.ts`中进行设置

    ```ts
    import { themer } from '@nativescript-community/ui-material-core';
    if (global.isIOS) {
        themer.setPrimaryColor('#bff937');
        themer.setAccentColor('#ff8a39');
        themer.setSecondaryColor('#a830d7');
    }
    ```

    可以设置主题颜色的包括:

    + `setPrimaryColor(value: string | Color)`
    + `setPrimaryColorVariant(value: string | Color)`
    + `setOnPrimaryColor(value: string | Color)`
    + `setSecondaryColor(value: string | Color)`
    + `setAccentColor(value: string | Color)`
    + `setSurfaceColor(value: string | Color)`
    + `setOnSurfaceColor(value: string | Color)`

##### 使用material扩展所有组件的样式

我们可以使用如下设置让所有组件获得如下三个css属性:

+ `elevation`设置范围`0~24`,单位像素,不同MaterialComponents组件有不同的默认值,原生组件除了button是2外其他全部是0
+ `dynamicElevationOffset`设置范围`0~24`.不同MaterialComponents组件有不同的默认值,原生组件除了button是6外其他全部是0
+ `rippleColor`水波纹颜色,设置后获得水波纹特效

要可以使用这3个css属性我们需要修改入口文件`app.ts`

```ts
import { installMixins } from '@nativescript-community/ui-material-core';
installMixins();
```

光有页面我们通常很难有效的组织应用的交互逻辑,通常我们都需要配合页面跳转来讲复数个页面串接起来从而实现应用的功能.

## 页面跳转

页面的跳转在nativescript-vue中最常见的是通过调用`this.$navigateTo(<页面B>, options)`实现的.其中页面B也是一个`Page`标签为最外层标签的vue对象.我们可以通过在`options`中设置导航的具体参数,主要包括:

+ `props`属性传递跳转去页面所需的`props`
+ `transition`或者`transitioniOS`和`transitionAndroid`来设置页面跳转的过渡动画,支持的过渡类型有:

| 选项                | ios可用 | android可用                      |
| ------------------- | ------- | -------------------------------- |
| `fade`              | T       | T                                |
| `flip`/`flipRight`  | T       | T                                |
| `flipLeft`          | T       | T                                |
| `slide`/`slideLeft` | T       | T                                |
| `slideRight`        | T       | T                                |
| `slideTop`          | T       | T                                |
| `slideBottom`       | T       | T                                |
| `curl`/`curlUp`     | T       | F                                |
| `curlDown`          | T       | F                                |
| `explode`           | F       | Android Lollipop(21) and up only |

+ `frame`属性,用于设置在哪个frame上切换Page

## 容器组件

在开始介绍页面与导航的常用模式之前我们先可以了解下nativescript支持的容器组件,他们既可以用于组织多个Frame之间的排版,又可以在Page中组织其他组件的排版,还可以通过设置容器的高度(`width`),宽度(`height`),背景色(`backgroundColor`)等来控制其管辖内元素的布局样式.

### [AbsoluteLayout](https://nativescript-vue.org/cn/docs/elements/layouts/absolute-layout/)

NativeScript最简单的布局容器,即绝对位置容器.使用`top`和`left`来定位组件位置

有以下行为:

+ 使用一对绝对左/上坐标来定位其子项.
+ 不对其子项强制执行任何布局约束.
+ 在大小更改时不会在运行时调整其子项的大小.

### [DockLayout](https://nativescript-vue.org/cn/docs/elements/layouts/dock-layout/)

将子元素停靠到布局的边或中心的容器

有以下行为:

+ 使用`dock`属性指定子元素停靠到布局的`left`,`right`,`top`,`bottom`位置.
+ 最后一个子元素(子元素不指定`dock`属性且`DockLayout`设置属性`stretchLastChild="true"`)表示放置在中间
+ 当其大小发生变化时,将在运行时调整其子元素的大小.

### [FlexboxLayout](https://nativescript-vue.org/cn/docs/elements/layouts/flexbox-layout/)

[CSS Flexbox布局](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)的非精确实现.此布局允许水平和垂直排列子组件.

### [GridLayout](https://nativescript-vue.org/cn/docs/elements/layouts/grid-layout/)

网格布局容器.网格布局是客户端常用的布局模式,nativescript中网格由行,列和单元格组成.单元格可以跨越一行或多行以及一列或多列,它可以包含多个子元素,这些子元素可以跨越多个行和列,甚至可以相互重叠.

默认情况下`GridLayout`只有一列一行.我们可以配置`GridLayout`组件的`columns`和`rows`属性来添加列和行.他们的值是如下三种字符串作为元素,以`,`分隔的字符串列表.如`rows="120,auto,*"`
这三种元素为:

+ 绝对数字: 表示固定大小,单位像素
+ `auto`: 使列与其最宽的子项一样宽,或使该行与其最高的子项一样高.
+ `*`: 填充所有自动和固定大小的列或行后占用的空间尽可能多.

而其中的元素则需要使用`row`和`col`属性指定所在的网格位置,使用`rowSpan`和`colSpan`指定该元素在行列上跨越的格数

### [StackLayout](https://nativescript-vue.org/cn/docs/elements/layouts/stack-layout/)

堆叠布局容器,其中的元素将按`orientation`属性指定的方向队列放置.

`orientation`的可选值有:

+ `vertical`(默认)横向
+ `horizontal`纵向

### [WrapLayout](https://nativescript-vue.org/cn/docs/elements/layouts/wrap-layout/)

带换行的堆叠布局容器,其中的元素将按`orientation`属性指定的方向队列放置.当放置满时会另起一行/列继续放置.

`orientation`的可选值有:

+ `vertical`(默认)横向
+ `horizontal`纵向

上面这些容器之中通常比较常用的是`GridLayout`,`StackLayout`和`FlexboxLayout`.

## 导航组件和常用模式

导航组件可以看做是针对导航功能的一组按钮.他们通常有集中,简洁的特点,一般用在页面跳转,相关功能集中展示等情况下.由于移动端屏幕小,通常位置也和固定,按出现位置和形式分可以分为3类:

1. 固定导航,固定在屏幕顶部或底部的导航,一般来说手机纵向空间会大些,固定导航通常会放在这里.顶部/底部固定导航的优点是稳定直观,它总是可见,因此用的最多,多数内容类app都会用它,甚至同时有顶部和底部固定导航.缺点也是稳定,总是可见,它会一直占据屏幕.

2. 底部弹出导航,通常是由tap行为触发,弹出一个导航列表,这种导航优点类似桌面端的右键菜单,但固定从底部弹出,毕竟手机屏幕就那么大.比如图片列表就可以设置长按弹出一个带分享,下载,转发,编辑的底部弹出导航

3. 滑动边栏导航,平时隐藏看不见,只有特定方向的`swipe`(滑动手势)行为发生时才会弹出,且弹出方向和滑动方向也一致.这种导航的优点是不占空间,缺点是欠缺稳定性,毕竟手势操作本身不稳定.如果我们通过额外的按钮呼出侧栏那就和底部弹出导航在形式上重复了.

这三种导航组件并不是孤立的,他们也可以相互配合,但每个导航组件通常最佳使用方法是固定的因此下面我们来结合组件介绍他们的最佳使用方式

### 固定导航

nativescript原生就给了一个`TabView`组件用于在顶部底部构造固定导航,`nativescript-community/ui-material-components`中又进一步将拆分,提供了顶部导航`@nativescript-community/ui-material-tabs`和底部导航`@nativescript-community/ui-material-bottomnavigationbar`

#### [TabView](https://nativescript-vue.org/cn/docs/elements/components/tab-view/)

TabView是nativescript原生提供的导航组件,他有如下特点:

1. 在ios下固定在顶部,在android中则可以使用属性`androidTabsPosition`设置在顶部(`top`)还是底部(`bottom`).
2. 可以通过设置`selectedIndex`来设置选中index的初始值,`selectedTabTextColor`来设置被选中index的高亮颜色.
3. 子组件`TabViewItem`按顺序从0开始计数.
4. **每个`TabViewItem`中只允许有一个直系子组件**.且**子组件只在构造页面时渲染,切换index不会重复渲染**
5. 点击切换index切换其对应的`TabViewItem`中的子组件展示.我们可以通过监听事件`selectedIndexChange`来监听index的变化,但无法借助这个回调控制修改选中的index.`selectedIndexChange`触发后会给绑定的回调函数传递一个对象,理论上它应该满足[SelectedIndexChangedEventData](https://v7.docs.nativescript.org/api-reference/interfaces/_ui_tab_view_.selectedindexchangedeventdata.html)接口,但实际上这个对象没有`newIndex`和`oldIndex`属性,但有`value`和`oldValue`属性做同样的事情,这应该是一个bug.因此在ts下我们需要对回调的参数声明做一些改动:

```ts
...
import { EventData } from "@nativescript/core/data/observable";

interface SelectedIndexChangedEventData extends EventData {
  oldValue: number;

  /**
   * The new selected index.
   */
  value: number;
}

...
methods: {
  ...
  tabChangeHandler(evt: SelectedIndexChangedEventData){},
}
```

由于有上面介绍的性质,tabview和我们期望的仅做为按键集合有着较大区别,它基本只能作为一个根Page的最外层的容器使用
它的使用方式可以分为两种思路:

1. 用于导航组件集合.这是最简单的用法,本质上它并不是导航,只是展示的组件进行切换而已.这种用法多用在相关且处于同一层次结构的内容组之间进行导航,还是同一个Page内元素组合的切换,比如有个户口本页面就可以将爸爸,妈妈,孩子三个人的信息使用TabView进行导航.

    > 例子: 切换内容

    + `views/Main.Vue`

    ```Vue
    <template>
      <Page actionBarHidden="true">
        <TabView
          selectedIndex="1"
          selectedTabTextColor="#e57373"
          @selectedIndexChange="tabChangeHandler"
        >
          <TabViewItem title="Tab 1">
            <Label text="Content for Tab 1" />
          </TabViewItem>
          <TabViewItem title="Tab 2">
            <Label text="Content for Tab 2" />
          </TabViewItem>
          <TabViewItem title="Tab 3">
            <Label text="Content for Tab 3" />
          </TabViewItem>
        </TabView>
      </Page>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    // import NavMDBottom from "../components/NavMDBottom.vue";
    import { EventData } from "@nativescript/core/data/observable";

    interface SelectedIndexChangedEventData extends EventData {
      oldValue: number;
      /**
       * The new selected index.
      */
      value: number;
    }

    export default Vue.extend({
      methods: {
        tabChangeHandler(evt: SelectedIndexChangedEventData) {
          console.log("!!!!");
          console.log(evt.eventName);
          console.log(Object.keys(evt));
          console.log(evt.oldValue);
          console.log(evt.value);
        },
      },
    });
    </script>
    ```

2. 用于导航多个Frame,这种方式适合需要多个Frame的情况,一般这些Frame是平行关系,且不会相互影响.比如我们希望一个tab下进行一些操作后点击另一tab再进行一些操作,回到原来tab下不会重新渲染.具体一点比如文本编辑器中多个文件间的切换就可以用这种逻辑.

    > 例子: 导航多个Frame

    + `views/Main.vue`

        ```vue
        <template>
          <Page actionBarHidden="true">
            <TabView
              selectedIndex="0"
              selectedTabTextColor="#e57373"
              @selectedIndexChange="tabChangeHandler"
            >
              <TabViewItem title="Tab 1">
                <Frame id="home-frame">
                  <HomePage/>
                </Frame>
              </TabViewItem>
              <TabViewItem title="Tab 2">
                <Frame id="page-frame-1">
                  <Page1/>
                </Frame>
              </TabViewItem>
              <TabViewItem title="Tab 3">
                <Frame id="page-frame-2">
                  <Page2/>
                </Frame>
              </TabViewItem>
            </TabView>
          </Page>
        </template>

        <script lang="ts">
        import Vue from "nativescript-vue";
        // import NavMDBottom from "../components/NavMDBottom.vue";
        import { EventData } from "@nativescript/core/data/observable";
        import HomePage from "./HomePage.vue";
        import Page1 from "./Page1.vue";
        import Page2 from "./Page2.vue";

        interface SelectedIndexChangedEventData extends EventData {
          oldValue: number;
          /**
          * The new selected index.
          */
          value: number;
        }

        export default Vue.extend({
          components: { HomePage, Page1, Page2 },
          methods: {
            tabChangeHandler(evt: SelectedIndexChangedEventData) {
              console.log("!!!!");
              console.log(evt.eventName);
              console.log(Object.keys(evt));
              console.log(evt.oldValue);
              console.log(evt.value);
            },
          },
        });
        </script>
        ```

    + `views/HomePage.vue`

        ```Vue
        <template>
          <Page actionBarHidden="true">
            <StackLayout>
              <Label text="Home"></Label>
            </StackLayout>
          </Page>
        </template>
          
        <script lang="ts">
        import Vue from "nativescript-vue";
        export default Vue.extend({
          mounted: function () {
            console.log("&&&&mounted home frame");
          },
        });
        </script>
        ```

    + `views/Page1.Vue`

        ```Vue
        <template>
          <Page actionBarHidden="true">
            <StackLayout>
              <Label text="Page 1"></Label>
            </StackLayout>
          </Page>
        </template>
          
        <script lang="ts">
        import Vue from "nativescript-vue";
        export default Vue.extend({});
        </script>
        ```

    + `views/Page2.Vue`

        ```Vue
        <template>
          <Page actionBarHidden="true">
            <StackLayout>
              <Label text="Page 2"></Label>
            </StackLayout>
          </Page>
        </template>
          
        <script lang="ts">
        import Vue from "nativescript-vue";
        export default Vue.extend({});
        </script>
        ```

当然了上面两种思路也是可以融合的,具体怎么用还是要看业务需求.

#### [@nativescript-community/ui-material-tabs](https://www.npmjs.com/package/@nativescript-community/ui-material-tabs)

原生tabview组件的material风格扩展,它在使用思路上和原生的完全一样只是主要多了如下细节:

1. 无论在ios还是android中都可以使用属性`tabsPosition`设置在顶部(`top`)还是底部(`bottom`).
2. 没有`selectedTabTextColor`属性了,高亮选中的index使用material风格
3. 增加`swipeEnabled`属性用于开启滑动
4. 增加`offscreenTabLimit`属性,当tab过多是可以用它设置屏幕上展示的个数,隐藏的可以滑动后找到

要用它我们当然需要先设置Material.然后安装`@nativescript-community/ui-material-tabs`,然后在入口文件中导入它

```ts
import TabsPlugin from '@nativescript-community/ui-material-tabs/vue';

Vue.use(TabsPlugin);
```

> 例子: 由于用法思路一样我们就用`@nativescript-community/ui-material-tabs`复刻上面第二个例子,我们只要改`Main.vue`的写法就可以无缝替换,主要看tab功能写法上的不同.

+ `views/Main.vue`

    ```Vue
    <template>
      <Page actionBarHidden="true">
        <MDTabs selectedIndex="0" tabsPosition="bottom"  swipeEnabled="true">
          <!-- The bottom tab UI is created via TabStrip (the containier) and TabStripItem (for each tab)-->
          <MDTabStrip>
            <MDTabStripItem>
              <Label text="Home"></Label>
            </MDTabStripItem>
            <MDTabStripItem class="special">
              <Label text="Page1"></Label>
            </MDTabStripItem>
            <MDTabStripItem class="special">
              <Label text="Page2"></Label>
            </MDTabStripItem>
          </MDTabStrip>

          <!-- The number of TabContentItem components should corespond to the number of TabStripItem components -->
          <MDTabContentItem>
            <Frame id="home-frame">
              <HomePage/>
            </Frame>
          </MDTabContentItem>
          <MDTabContentItem>
            <Frame id="page-frame-1">
              <Page1/>
            </Frame>
          </MDTabContentItem>
          <MDTabContentItem>
            <Frame id="page-frame-2">
              <Page2/>
            </Frame>
          </MDTabContentItem>
        </MDTabs>
      </Page>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    // import NavMDBottom from "../components/NavMDBottom.vue";
    import { SelectedIndexChangedEventData } from "@nativescript-community/ui-material-core-tabs/tab-navigation-base";
    import HomePage from "./HomePage.vue";
    import Page1 from "./Page1.vue";
    import Page2 from "./Page2.vue";

    export default Vue.extend({
        methods: {
            tabChangeHandler(evt: SelectedIndexChangedEventData) {
                console.log("!!!!");
                console.log(evt.eventName);
                console.log(Object.keys(evt));
                console.log(evt.oldIndex);
                console.log(evt.newIndex);
            },
        },
        components: { HomePage, Page1, Page2 }
    });
    </script>
    ```

#### [SegmentedBar](https://nativescript-vue.org/cn/docs/elements/components/segmented-bar/)

原生的离散选择导航,他和上面连个组件不同点在于它没有固定位置,基本可以理解为就是按钮集合.要使用它我们需要结合容器组件.

`SegmentedBar`通过监听`onIndexSelected`事件来导航,其中元素从0开始计数.
我们可以通过设置`selectedIndex`来设置选中index的初始值,使用`selectedBackgroundColor`设置选中项的背景色.

它的最佳使用方法是结合Frame使用,思路是

1. 在root-frame中构造一个main-frame用于展示主体
2. 导航放置在root-frame中和main-frame平级,main-frame中放置被导航的页面
3. 监听组件`SegmentedBar`的`onIndexSelected`事件导航页面
4. 使用`GridLayout`组件排版nav-frame和main-frame,`<GridLayout rows="auto,*">`为顶部导航,`<GridLayout rows="*, auto">`则为底部导航

> 例子:我们用`SegmentedBar`来继续为HomePage,Page1,Page2三个页面导航.我们只要修改`Main.vue`并增加一个`NavMDBottom.vue`组件用于抽出导航逻辑

+ `views/Main.vue`

    ```Vue
    <template>
      <Page actionBarHidden="true">
        <!--底部导航-->
        <GridLayout rows="*, auto">
          <Frame id="main-frame" row="0">
            <HomePage />
          </Frame>
          <NavSegmentedBar row="1"/>
        </GridLayout>
        <!--顶部导航-->
        <!-- <GridLayout rows="auto,*">
          <NavSegmentedBar row="0"/>
          <Frame id="main-frame" row="1">
            <Home />
          </Frame>
        </GridLayout> -->
      </Page>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    import NavSegmentedBar from "../components/NavSegmentedBar.vue";
    import HomePage from "./HomePage.vue";

    export default Vue.extend({
      components: { NavSegmentedBar, HomePage },
    });
    </script>
    ```

+ `components/NavSegmentedBar.vue`

    ```vue
    <template>
        <SegmentedBar selectedBackgroundColor="#e57373" selectedIndex="0" @selectedIndexChanged="onIndexSelected" id="nav-segbar">
            <SegmentedBarItem title="Home" />
            <SegmentedBarItem title="Page1" />
            <SegmentedBarItem title="Page2" />
        </SegmentedBar>
      </template>
        
      <script lang="ts">
      import Vue from "nativescript-vue";
      import { SelectedIndexChangedEventData } from "@nativescript/core/ui/segmented-bar";
      import HomePage from "../views/HomePage.vue";
      import Page1 from "../views/Page1.vue";
      import Page2 from "../views/Page2.vue";
      export default Vue.extend({
        methods: {
            onIndexSelected(evt: SelectedIndexChangedEventData) {
            console.log("!!!!!");
            switch (evt.newIndex) {
              case 0:
                {
                  this.$navigateTo(HomePage, {
                    transition: { name: "fade" },
                    frame: "main-frame",
                  });
                }
                break;
              case 1:
                {
                  this.$navigateTo(Page1, {
                    transition: { name: "fade" },
                    frame: "main-frame",
                  });
                }
                break;
              case 2:
                {
                  this.$navigateTo(Page2, {
                    transition: { name: "fade" },
                    frame: "main-frame",
                  });
                }
                break;
              default:
                console.log(`unknown index ${evt.newIndex}`);
            }
          },
        },
      });
      </script>
    ```

上面的例子是最基本的用法,就像上面说的`SegmentedBar`本身与位置无关,因此使用上非常灵活.几个扩展思路总结如下:

1. 顶栏底栏双层`SegmentedBar`.类似桌面端的侧栏和顶栏配合用法,只是侧栏被替换成了底栏.底栏更容易触达,用于应用整体导航,顶栏触达会稍微远一点,用于页面逻辑中的导航
2. 滑动边栏和底栏双层`SegmentedBar`.滑动边栏用于导航最外层的业务分类,底栏用于复杂业务页面的导航.

#### [@nativescript-community/ui-material-bottomnavigationbar](https://www.npmjs.com/package/@nativescript-community/ui-material-bottomnavigationbar)

material风格的离散选择导航,要使用它需要设置Material.它和`SegmentedBar`一样并没有固定位置,而且更加接近按钮集合的概念,我们用它需要结合容器组件.

要用它我们当然需要先设置Material.然后安装`@nativescript-community/ui-material-bottomnavigationbar`,然后在入口文件中导入它

```ts
import BottomNavigationBar from '@nativescript-community/ui-material-bottomnavigationbar/vue'
Vue.use(BottomNavigationBar);
```

`MDBottomNavigationBar`通过监听`tabSelected`事件来导航,其中的元素按顺序从0开始计数.
我们可以通过设置`selectedTabIndex`来设置选中index的初始值,`activeColor`来设置被选中index的高亮颜色,`badgeColor`来设置未被选中的高亮颜色.
每次切换index后绑定的回调函数会收到一个`TabSelectedEventData`对象,它会包含`oldIndex`和`newIndex`两个属性分别表示上一index和当前的index.

和上面`SegmentedBar`一样它的最佳使用方法是结合Frame使用,思路是

1. 在root-frame中构造一个main-frame用于展示主体
2. 导航放置在root-frame中和main-frame平级,main-frame中放置被导航的页面
3. 监听组件`MDBottomNavigationBar`的`tabSelected`事件导航页面
4. 使用`GridLayout`组件排版nav-frame和main-frame,`<GridLayout rows="auto,*">`为顶部导航,`<GridLayout rows="*, auto">`则为底部导航

> 例子:我们用`ui-material-bottomnavigationbar`来继续为HomePage,Page1,Page2三个页面导航.我们只要修改`Main.vue`并增加一个`NavMDBottom.vue`组件用于抽出导航逻辑

+ `views/Main.vue`

    ```Vue
    <template>
      <Page actionBarHidden="true">
        <!--底部导航-->
        <GridLayout rows="*, auto">
          <Frame id="main-frame" row="0">
            <HomePage />
          </Frame>
          <NavMDBottom row="1"/>
        </GridLayout>
        <!--顶部导航-->
        <!-- <GridLayout rows="auto,*">
          <NavMDBottom row="0"/>
          <Frame id="main-frame" row="1">
            <Home />
          </Frame>
        </GridLayout> -->
      </Page>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    import NavMDBottom from "../components/NavMDBottom.vue";
    import HomePage from "./HomePage.vue";

    export default Vue.extend({
      components: { NavMDBottom, HomePage },
    });
    </script>

    <style scoped lang="scss">
    @import "@nativescript/theme/scss/variables/blue";

    .info {
      font-size: 20;
      horizontal-align: center;
      vertical-align: center;
    }
    </style>
    ```

    作为入口`Page`,`Main.vue`负责为导航和主Frame搭好框架分配好屏幕的占用.

+ `components/NavMDBottom.vue`

    ```Vue
    <template>
      <MDBottomNavigationBar
        activeColor="#e57373"
        badgeColor="#1976d2"
        selectedTabIndex="0"
        @tabSelected="onBottomNavigationTabSelected"
      >
        <MDBottomNavigationTab title="Home" />
        <MDBottomNavigationTab title="Page1" />
        <MDBottomNavigationTab title="Page2" />
      </MDBottomNavigationBar>
    </template>
      
      <script lang="ts">
    import Vue from "nativescript-vue";
    import { TabSelectedEventData } from "@nativescript-community/ui-material-bottomnavigationbar";
    import HomePage from "../views/HomePage.vue";
    import Page1 from "../views/Page1.vue";
    import Page2 from "../views/Page2.vue";
    export default Vue.extend({
      methods: {
        onBottomNavigationTabSelected(args: TabSelectedEventData) {
          console.log("!!!!!");
          console.log(args.oldIndex);
          console.log(args.newIndex);
          switch (args.newIndex) {
            case 0:
              {
                this.$navigateTo(HomePage, {
                  transition: { name: "fade" },
                  frame: "main-frame",
                });
              }
              break;
            case 1:
              {
                this.$navigateTo(Page1, {
                  transition: { name: "fade" },
                  frame: "main-frame",
                });
              }
              break;
            case 2:
              {
                this.$navigateTo(Page2, {
                  transition: { name: "fade" },
                  frame: "main-frame",
                });
              }
              break;
            default:
              console.log(`unknown index ${args.newIndex}`);
          }
        },
      },
    });
    </script>
    ```

    `NavMDBottom.vue`负责将导航逻辑打包好,使用`MDBottomNavigationBar`的最大优点就是它并不与位置绑定,你甚至可以在顶部底部的滑动边栏导航中使用它.

上面的例子是最基本的用法,就像上面说的`MDBottomNavigationBar`本身与位置无关,因此使用上非常灵活.几个扩展思路总结如下:

1. 顶栏底栏双层`MDBottomNavigationBar`.类似桌面端的侧栏和顶栏配合用法,只是侧栏被替换成了底栏.底栏更容易触达,用于应用整体导航,顶栏触达会稍微远一点,用于页面逻辑中的导航
2. 滑动边栏和底栏双层`MDBottomNavigationBar`.滑动边栏用于导航最外层的业务分类,底栏用于复杂业务页面的导航.

**不过需要注意**:

1. MDBottomNavigationBar无法使用Vue上后绑定的方法,比如下面的底部弹出导航就无法使用

### 底部弹出导航

这个没有原生的,只有[@nativescript-community/ui-material-bottomsheet](https://www.npmjs.com/package/@nativescript-community/ui-material-bottomsheet)这一个选择.

要用它我们当然需要先设置Material.然后安装`@nativescript-community/ui-material-bottomsheet`,然后在入口文件中导入它

```ts
import BottomSheetPlugin from '@nativescript-community/ui-material-bottomsheet/vue';
import { install as installBottomsheet } from "@nativescript-community/ui-material-bottomsheet";
installBottomsheet();
Vue.use(BottomSheetPlugin);
```

每个vue实例会获得

+ 方法`$showBottomSheet(Component, options)`,执行后就会弹出底部弹出导航.options满足接口 [VueBottomSheetOption](https://github.com/nativescript-community/ui-material-components/blob/master/src/bottomsheet/vue/index.ts),除了文档中列出的属性可以设置外我们也可以用属性`prop`传递参数给`Component`.需要注意的是
  
    1. `options`中可以设置`closeCallback`属性,它的参数为`...args`,当它弹出的底部弹出导航被关闭后它会被调用.
    2. 亲测`BottomSheet`无法与`MDBottomNavigationBar`配合使用,

+ 方法`$closeBottomSheet(...args)`,执行后如果有参数,则会被传递给`$showBottomSheet`中设置的`closeCallback`中作为参数.

> 例子:我们使用一个顶部按钮来呼出底部弹出导航,然后用它继续为HomePage,Page1,Page2三个页面导航.

+ `views/Main.vue`,我们用一个按键的tap事件触发弹出底部弹出导航页面

    ```vue
    <template>
      <Page>
        <GridLayout rows="auto,*">
          <Button text="change" @tap="onButtonTap" row="0" id="change-btn" />
          <Frame id="main-frame" row="1">
            <HomePage />
          </Frame>
        </GridLayout>
      </Page>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    import { TapGestureEventData } from "@nativescript/core/ui/gestures";
    import HomePage from "./HomePage.vue";
    import NavSegmentedBar from "../components/NavSegmentedBar.vue";
    export default Vue.extend({
      components: {
        HomePage,
      },
      data: {
        defaultIndex: 0,
      },
      methods: {
        onButtonTap(evt: TapGestureEventData) {
          this.$showBottomSheet(NavSegmentedBar, {
            dismissOnBackgroundTap: true,
            props: {
              canCloseBottomSheet: true,
              defaultIndex: this.defaultIndex,
            },
            closeCallback: (...args: any) => {
              console.log("bottom sheet closed", args);
              this.defaultIndex = args[1];
            },
          });
        },
      },
    });
    </script>
    ```

+ `components/NavSegmentedBar.vue`,导航组件很遗憾我们无法使用上面的`NavMDBottom.vue`,这里使用`NavSegmentedBar`来实现,

    ```Vue
    <template>
      <SegmentedBar
        selectedBackgroundColor="#e57373"
        :selectedIndex="defaultIndex"
        @selectedIndexChanged="onIndexSelected"
        id="nav-segbar"
      >
        <SegmentedBarItem title="Home" />
        <SegmentedBarItem title="Page1" />
        <SegmentedBarItem title="Page2" />
      </SegmentedBar>
    </template>
        
    <script lang="ts">
    import Vue from "nativescript-vue";
    import { View } from "@nativescript/core";
    import { SelectedIndexChangedEventData } from "@nativescript/core/ui/segmented-bar";
    import HomePage from "../views/HomePage.vue";
    import Page1 from "../views/Page1.vue";
    import Page2 from "../views/Page2.vue";
    export default Vue.extend({
      props: {
        canCloseBottomSheet: {
          type: Boolean,
          default: false,
        },
        defaultIndex: {
          type: Number,
          default: 0,
        },
      },
      methods: {
        onIndexSelected(evt: SelectedIndexChangedEventData) {
          console.log("!!!!!");
          switch (evt.newIndex) {
            case 0:
              {
                this.$navigateTo(HomePage, {
                  transition: { name: "fade" },
                  frame: "main-frame",
                });
              }
              break;
            case 1:
              {
                this.$navigateTo(Page1, {
                  transition: { name: "fade" },
                  frame: "main-frame",
                });
              }
              break;
            case 2:
              {
                this.$navigateTo(Page2, {
                  transition: { name: "fade" },
                  frame: "main-frame",
                });
              }
              break;
            default:
              console.log(`unknown index ${evt.newIndex}`);
          }
          if (this.canCloseBottomSheet) {
            let obj = evt.object as View;
            try{
                this.$closeBottomSheet(obj.id,evt.newIndex);
            } catch (e){
                console.log(`try to closeBottomSheet get error: ${e}`)
            }
          }
        },
      },
    });
    </script>
    ```

    由于`BottomSheet`并不是一个单独的Frame而是每次呼出时重新渲染,因此我们必须修改`NavMDBottom`让他可以从外部传入初始化参数,否则每次呼出都会回到首页.这里我们使用了vue的`props`来做单向数据传输,当然做的复杂也可以使用vuex.同时我们还必须可以将选中的index传出给调用它的组件,以便下次再呼出底栏时可以知道要用哪个index作为初始值,这里可以很好的利用`$showBottomSheet`的可选参数`closeCallback`.

    构造`SegmentedBar`实例时最开始就会根据`selectedIndex`设置index进行渲染,这会触发我们的`onIndexSelected`,但此时`this.$closeBottomSheet`中实际上调用会报错,因为`$showBottomSheet`实际上并没有处理完.因此我们需要用`try`语句处理下这个问题.

### 滑动边栏导航

滑动边栏导航我们可以使用[@nativescript-community/ui-drawer](https://github.com/nativescript-community/ui-drawer).它支持四个位置的边栏.要用它我们需要安装`@nativescript-community/ui-material-bottomsheet`,然后在入口文件中导入它

```ts
import DrawerPlugin from '@nativescript-community/ui-drawer/vue'
import { install as installUIDrawer} from '@nativescript-community/ui-drawer';
installUIDrawer()
Vue.use(DrawerPlugin);
```

使用方法可以总结为:

1. 页面最外层使用组件`<Drawer ref="drawer">`,其中每个元素可以使用属性指定功能:
    1. `~leftDrawer`,左侧边栏
    2. `~rightDrawer`,右侧边栏
    3. `~topDrawer`,顶部边栏
    4. `~bottomDrawer`,底部边栏
    5. `~mainContent`主体部分

2. 如果要直接呼出边栏或收回边栏可以在组件中使用`this.$refs['drawer'].open('left');`或`this.$refs['drawer'].close('left');`,其中open和close的参数可以是`left`,`right`,`top`,`bottom`,其含义是呼出或者收回那个侧栏.

>例子: 设置四个方向的滑动边栏导航,用它们继续为HomePage,Page1,Page2三个页面导航.

我们将上下两个方向的设为`NavMDBottom`,剩下侧边的重新弄一个竖排版的组件`SideSheet`

+ `views/Main.vue`

    ```vue
    <template>
      <Page>
        <Drawer ref="drawer">
          <SideSheet ~leftDrawer />
          <SideSheet ~rightDrawer />
          <NavMDBottom ~topDrawer />
          <NavMDBottom ~bottomDrawer />
          <Frame ~mainContent id="main-frame"><HomePage /></Frame>
        </Drawer>
      </Page>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    import HomePage from "./HomePage.vue";
    import SideSheet from "../components/SideSheet.vue"
    import NavMDBottom from "../components/NavMDBottom.vue";
    export default Vue.extend({
      components: {
        HomePage,
        NavMDBottom,
        SideSheet,
      },
    });
    </script>
    ```

+ `components/SideSheet.vue`

    ```Vue
    <template>
      <Stacklayout backgroundColor="white" padding="25">
        <Button id="to-homepage-btn" @tap="toHomePage" text="Home Page"></Button>
        <Button id="to-page1-btn" @tap="toPage1" text="Page 1"></Button>
        <Button id="to-page2-btn" @tap="toPage2" text="Page 2"></Button>
      </Stacklayout>
    </template>

    <script lang="ts">
    import Vue from "nativescript-vue";
    import { TapGestureEventData } from "@nativescript/core/ui/gestures";
    import HomePage from "../views/HomePage.vue";
    import Page1 from "../views/Page1.vue";
    import Page2 from "../views/Page2.vue";
    export default Vue.extend({
      methods: {
        toHomePage(evt: TapGestureEventData) {
          this.$navigateTo(HomePage, {
            transition: { name: "fade" },
            frame: "main-frame",
          });
        },
        toPage1(evt: TapGestureEventData) {
          this.$navigateTo(Page1, {
            transition: { name: "fade" },
            frame: "main-frame",
          });
        },
        toPage2(evt: TapGestureEventData) {
          this.$navigateTo(Page2, {
            transition: { name: "fade" },
            frame: "main-frame",
          });
        },
      },
    });
    </script>
    ```